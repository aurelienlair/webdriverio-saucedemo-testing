{"info":{"type":"runner","start":"2022-02-18T02:03:22.038Z","_duration":23541,"cid":"0-21","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_1863395733"},"goog:chromeOptions":{"debuggerAddress":"localhost:55868"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"8485aeb6ba7e87307a7e5fcf20524052"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js"],"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","isMultiremote":false,"instanceOptions":{"8485aeb6ba7e87307a7e5fcf20524052":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:03:45.579Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":23541,"start":"2022-02-18T02:03:22.039Z","end":"2022-02-18T02:03:45Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:03:22.067Z","_duration":23420,"tests":[{"type":"test","start":"2022-02-18T02:03:22.072Z","_duration":23393,"uid":"test-00-0","cid":"0-21","title":"Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","fullTitle":"UserStory: Reset Cart State.Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a686835f-9d07-4988-a775-1f35fd607dd9"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/clear","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/clear","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/value","body":{"text":"performance_glitch_user"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5d2a7686-10c7-4a8d-aba9-b9639d2cbf65"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/clear","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/clear","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/value","body":{"text":"secret_sauce"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6759d260-6d7a-4ed3-ae95-c64144a60f79"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6759d260-6d7a-4ed3-ae95-c64144a60f79/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6759d260-6d7a-4ed3-ae95-c64144a60f79/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"905ffeab-5d9e-4247-80f5-4dc47ad28cf6"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/905ffeab-5d9e-4247-80f5-4dc47ad28cf6/text","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/905ffeab-5d9e-4247-80f5-4dc47ad28cf6/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"da121951-e537-459d-a481-e61627f2afad"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/da121951-e537-459d-a481-e61627f2afad/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/da121951-e537-459d-a481-e61627f2afad/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9aeb8528-e21d-43a7-af40-ed2c55e89847"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9aeb8528-e21d-43a7-af40-ed2c55e89847/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9aeb8528-e21d-43a7-af40-ed2c55e89847/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bad451cd-4d37-4c22-8802-4254f3b3803c"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bad451cd-4d37-4c22-8802-4254f3b3803c"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bad451cd-4d37-4c22-8802-4254f3b3803c/text","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bad451cd-4d37-4c22-8802-4254f3b3803c/text","body":{},"result":{"value":"2"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"bad451cd-4d37-4c22-8802-4254f3b3803c"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2186bbcc-0ce7-4d02-ae65-e897df80f65b"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2186bbcc-0ce7-4d02-ae65-e897df80f65b/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2186bbcc-0ce7-4d02-ae65-e897df80f65b/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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mufjU2/Vqdf2/giuCABwoSFIAAAAAAAAiGNp379Vl/6uReaSb430UgAAFyiCBAAAAAAAgDiXYLFo8s+f0LTa32p89oKRXg4A4AJDkAAAAAAAADBKJFmvUsZLv9HkRzcoMXPGSC8HAHCBYNgyAAAAAADAKGNeepMmXL9YHS88qwSLZaSXAwAY4wgSAAAAAAAARqEEi0UT77xnpJcBALgA0NoIAAAAAAAAAAAYIkgAAAAAAAAA/n/27j5Wsru+8/z7PD9V1b11u/u6TRsTQmJw1kmaZMGK7EQCZdQMo05GOInC7iSAHKxhjJglkx1QFjMZjCagTMaaCC8rZ6yQsLNBzBhN0lri1kZmlRixhmHoEA8OThwHm8bt2923Hs/z0/7xK1+McbnbuJtunM9LuqJUt+qcc0/dazW/z+/7/YqIyFoKEkREREREREREREREZC0FCSIiIiIiIiIiIiIispaCBBERERERERERERERWcu91BfwTG84+guX+hJEROQiuvfYJy/1JYiIiIiIiIiIyPOgigQREREREREREREREVlLQYKIiIiIiIiIiIiIiKx12bU2UssLEREREREREREREZHLhyoSRERERERERERERERkrcuuIkFERERERERE5HvBG47+wqW+BBERke8KVSSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWggQREREREREREREREVlLQYKIiIiIiIiIiIiIiKylIEFERERERERERERERNZSkCAiIiIiIiIiIiIiImspSBARERERERERERERkbUUJIiIiIiIiIiIiIiIyFoKEkREREREREREREREZC0FCSIiIiIiIiIiIiIispaCBBERERERERERERERWUtBgoiIiIiIiIiIiIiIrKUgQURERERERERERERE1lKQICIiIiIiIiIiIiIiaylIEBERERERERERERGRtRQkiIiIiIiIiIiIiIjIWgoSRERERERERERERERkLQUJIiIiIiIiIiIiIiKyloIEERERERERERERERFZS0GCiIiIiIiIiIiIiIispSBBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrKUgQEREREREREREREZG1FCSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWe6kv4FntHOfd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nnaM9CQnPvXbvHMVkAx++pc5ooIEEREREREREREREXkBrL7v+0t9Ed9m5zjvvvluHjqPl157y0e44+i3DjFe/vUxPvjrH+fEapHdH22zlQBtyu5OSgWAxyt+9tf44Ntezfg5BjNPvvhx3vehYzzy1IJ9uMnBsQ9U7D4xXR0L/O3reft7/ylHf/CZq/8r7ZTPfuR9fPhPd/bOP75yTACUkx0mxXkeJ32Y37/tX/OHf/3cw5THP/Eu7njPjecxdPqbQ6KP3v5Jbj18rteLiIiIiIiIiIiIyOViPjdtcE6cOHHBj334sFkwdi/4kS8Dgx88yoc+8Xoe++xx/vD4fZx4eIdTczCL99dxwz94PT/30zfyivG5jgTjH/8l7vzEm3jsi/dz/Ph9fPavvs6pJ8ywY3+0zeHDr+d1P3MjR165/dwHcja54Z9/hD9+84Mc++Nj3Pu5h3n8iR0mq+O84keu5w1Hj3Dkh7fxn2vxP7mGt/zWxzjyl/fxh//pGH/xdxNOzeu963npq8xxjh4+x/WIiIiIiIiIiIiIiJyHy7MiQUREREREREREREREzum7UZHw4pqRICIiIiIiIiIiIiIiF5SCBBERERERERERERERWUtBgoiIiIiIiIiIiIiIrKUgQURERERERERERERE1lKQICIiIiIiIiIiIiIiaylIEBERERERERERERGRtRQkiIiIiIiIiIiIiIjIWgoSRERERERERERERERkLQUJIiIiIiIiIiIiIiKyloIEERERERERERERERFZS0GCiIiIiIiIiIiIiIispSBBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrKUgQEREREREREREREZG1FCSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWggQREREREREREREREVlLQYKIiIiIiIiIiIiIiKylIEFERERERERERERERNZyL/UFPNMbjv7Cpb4EERG5iO499slLfQkiIiIiIiIiIvI8qCJBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrXXatjdTyQkRERERERERERETk8qGKBBERERERERERERERWUtBgoiIiIiIiIiIiIiIrKUgQURERERERERERERE1lKQICIiIiIiIiIiIiIiaylIEBERERERERERERGRtRQkiIiIiIiIiIiI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"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:45.465Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:03:22.072Z","_duration":23393,"uid":"test-00-0","cid":"0-21","title":"Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","fullTitle":"UserStory: Reset Cart State.Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a686835f-9d07-4988-a775-1f35fd607dd9"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/clear","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/clear","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/value","body":{"text":"performance_glitch_user"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a686835f-9d07-4988-a775-1f35fd607dd9/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5d2a7686-10c7-4a8d-aba9-b9639d2cbf65"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/clear","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/clear","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/value","body":{"text":"secret_sauce"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5d2a7686-10c7-4a8d-aba9-b9639d2cbf65/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6759d260-6d7a-4ed3-ae95-c64144a60f79"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6759d260-6d7a-4ed3-ae95-c64144a60f79/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6759d260-6d7a-4ed3-ae95-c64144a60f79/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"905ffeab-5d9e-4247-80f5-4dc47ad28cf6"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/905ffeab-5d9e-4247-80f5-4dc47ad28cf6/text","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/905ffeab-5d9e-4247-80f5-4dc47ad28cf6/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"da121951-e537-459d-a481-e61627f2afad"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/da121951-e537-459d-a481-e61627f2afad/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/da121951-e537-459d-a481-e61627f2afad/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9aeb8528-e21d-43a7-af40-ed2c55e89847"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9aeb8528-e21d-43a7-af40-ed2c55e89847/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9aeb8528-e21d-43a7-af40-ed2c55e89847/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bad451cd-4d37-4c22-8802-4254f3b3803c"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bad451cd-4d37-4c22-8802-4254f3b3803c"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bad451cd-4d37-4c22-8802-4254f3b3803c/text","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bad451cd-4d37-4c22-8802-4254f3b3803c/text","body":{},"result":{"value":"2"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"bad451cd-4d37-4c22-8802-4254f3b3803c"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2186bbcc-0ce7-4d02-ae65-e897df80f65b"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2186bbcc-0ce7-4d02-ae65-e897df80f65b/click","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2186bbcc-0ce7-4d02-ae65-e897df80f65b/click","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892"}},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":false},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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mufjU2/Vqdf2/giuCABwoSFIAAAAAAAAiGNp379Vl/6uReaSb430UgAAFyiCBAAAAAAAgDiXYLFo8s+f0LTa32p89oKRXg4A4AJDkAAAAAAAADBKJFmvUsZLv9HkRzcoMXPGSC8HAHCBYNgyAAAAAADAKGNeepMmXL9YHS88qwSLZaSXAwAY4wgSAAAAAAAARqEEi0UT77xnpJcBALgA0NoIAAAAAAAAAAAYIkgAAAAAAAAA/n/27j5Wsru+8/z7PD9V1b11u/u6TRsTQmJw1kmaZMGK7EQCZdQMo05GOInC7iSAHKxhjJglkx1QFjMZjCagTMaaCC8rZ6yQsLNBzBhN0lri1kZmlRixhmHoEA8OThwHm8bt2923Hs/z0/7xK1+McbnbuJtunM9LuqJUt+qcc0/dazW/z+/7/YqIyFoKEkREREREREREREREZC0FCSIiIiIiIiIiIiIispaCBBERERERERERERERWcu91BfwTG84+guX+hJEROQiuvfYJy/1JYiIiIiIiIiIyPOgigQREREREREREREREVlLQYKIiIiIiIiIiIiIiKx12bU2UssLEREREREREREREZHLhyoSRERERERERERERERkrcuuIkFERERERERE5HvBG47+wqW+BBERke8KVSSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWggQREREREREREREREVlLQYKIiIiIiIiIiIiIiKylIEFERERERERERERERNZSkCAiIiIiIiIiIiIiImspSBARERERERERERERkbUUJIiIiIiIiIiIiIiIyFoKEkREREREREREREREZC0FCSIiIiIiIiIiIiIispaCBBERERERERERERERWUtBgoiIiIiIiIiIiIiIrKUgQURERERERERERERE1lKQICIiIiIiIiIiIiIiaylIEBERERERERERERGRtRQkiIiIiIiIiIiIiIjIWgoSRERERERERERERERkLQUJIiIiIiIiIiIiIiKyloIEERERERERERERERFZS0GCiIiIiIiIiIiIiIispSBBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrKUgQEREREREREREREZG1FCSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWe6kv4FntHOfd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nnaM9CQnPvXbvHMVkAx++pc5ooIEEREREREREREREXkBrL7v+0t9Ed9m5zjvvvluHjqPl157y0e44+i3DjFe/vUxPvjrH+fEapHdH22zlQBtyu5OSgWAxyt+9tf44Ntezfg5BjNPvvhx3vehYzzy1IJ9uMnBsQ9U7D4xXR0L/O3reft7/ylHf/CZq/8r7ZTPfuR9fPhPd/bOP75yTACUkx0mxXkeJ32Y37/tX/OHf/3cw5THP/Eu7njPjecxdPqbQ6KP3v5Jbj18rteLiIiIiIiIiIiIyOViPjdtcE6cOHHBj334sFkwdi/4kS8Dgx88yoc+8Xoe++xx/vD4fZx4eIdTczCL99dxwz94PT/30zfyivG5jgTjH/8l7vzEm3jsi/dz/Ph9fPavvs6pJ8ywY3+0zeHDr+d1P3MjR165/dwHcja54Z9/hD9+84Mc++Nj3Pu5h3n8iR0mq+O84keu5w1Hj3Dkh7fxn2vxP7mGt/zWxzjyl/fxh//pGH/xdxNOzeu963npq8xxjh4+x/WIiIiIiIiIiIiIiJyHy7MiQUREREREREREREREzum7UZHw4pqRICIiIiIiIiIiIiIiF5SCBBERERERERERERERWUtBgoiIiIiIiIiIiIiIrKUgQURERERERERERERE1lKQICIiIiIiIiIiIiIiaylIEBERERERERERERGRtRQkiIiIiIiIiIiIiIjIWgoSRERERERERERERERkLQUJIiIiIiIiIiIiIiKyloIEERERERERERERERFZS0GCiIiIiIiIiIiIiIispSBBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrKUgQEREREREREREREZG1FCSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWggQREREREREREREREVlLQYKIiIiIiIiIiIiIiKylIEFERERERERERERERNZyL/UFPNMbjv7Cpb4EERG5iO499slLfQkiIiIiIiIiIvI8qCJBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrXXatjdTyQkRERERERERERETk8qGKBBERERERERERERERWUtBgoiIiIiIiIiIiIiIrKUgQURERERERERERERE1lKQICIiIiIiIiIiIiIiaylIEBERERERERERERGRtRQkiIiIiIiIiIiIiIjIWgoSRERERERERERERERkLQUJIiIiIiIiIiIiIiKyloIEERERERERERERERFZS0GCiIiIiIiIiIiIiIispSBBRERERERERERERETWUpAgIiIiIiIiIiIiIiJrKUgQEREREREREREREZG1FCSIiIiIiIiIiIiIiMhaChJERERERERERERERGQtBQkiIiIiIiIiIiIiIrKWggQREREREREREREREVlLQYKIiIiIiIiIiIiIiKylIEFERERERERERERERNZSkCAiIiIiIiIiIiIiImu5l/oCRERELqXd3emlvgQRkfOytbX5XT+n/hspIiIiInLhXIp/018oqkgQEREREREREREREZG1FCSIiIiIiIiIiIiIiMhaam0kIiJ/r30vlxWKyIvf5dRa6HP/7yc5e3rCYJDQdj1pmjLa2MC2LWzHxXEczpw+zeZog6au6YHR5gY7T55iPN7C8z2yLMV1Xdq2IUkSPNdnOp1iWRaLRUrXtgyHA6qixHJtiqKgKkqS4QDHcdjY3GQxmVOUBV3fYzs2nuuyWC4J/Ij92/s4c3qHdJkz2hhQljlBEFJWNUEQMBgMSdOUrmtxXQ/P81fX71DkOZvjDSa7uxRFged5HNi/TZanYNl4nkuZlwyGIyaTs7Rdx2K2BAtsC4ajEWVZsFympGlKFMWMx1uk6QLLsqmqmijySZIY1/Xoe5hMZxy84iB5nhFFEU1T0bQtruPRdT3z+Yw4ifE8nyxNsS0b3/XwPI9TOzuEUcDJbzxBW7dsbm7Qti2HrjrEfD5lPpsBNhsbY+aLOZZtUVY1rg1W71I3JW3bEScDgsDlwP4t2r7Htm26tqPrOsbjMWma0gNt21GVJV3TEkcRQRzSti3pMqVuGgaDAcvlEs/zKMqCOIpxXQfLAtt2ybKcwXCAZ9vM5jN6IEkSzpw5g+d5uK4LdHieT9/1zKZzNsebzKZzXM8l8D2iKKEsC6q6AgvyNCVOBpRFSRiG0PdsjIZM5zMsy2Wyu8uVh15CnuX0Xcf2FVdQ1zV937OYzEgGA/Iypes6hoMRabrAcWzCMKKqalzXJctSPM9nsVzSY7E53sR2LfI0YzQcUdc1YDGdzXA9m43NEZOzU2zLYTSK8fyQ2WzOfLbgwPZ+8iwFoG/B9z0sy6IDfN/Htm0WizkAm+Mt/tFNb70kf+siIiJyYV1O/6Z/IVSRICIiIiIi57SYpxRFyXw2p2lqwjAizzPCMALgGydPsjEa4QceVxzcZjgaYq0W2Nu2YTqZ4Dou9B3j8RZlWTKdTWnbhrZtCAKP/dsH8H2foixYLhdYWAyGQ3zfZzAckmcpjuvQti1JklAWJWVZ4boutg1FVuB7AfFqET+KEizLwnFcxuMtwijC9Twcx6VtW6aTGXlRUJYFjuNwemcHy7KxLItBMsCyYJAM8H0f3/OxbJuzZ8/QWxZN0wA9bduysbnJbDrDshwcx8W2HWzLpus6Nje3zEL0fI7juHiuj4VFWRXEcUTfd7RtQ1kW1HWNYzsATCa7DIZDqqoiiWOapmEwHNDTr+67T1VVZMsljuNiWTZt23Py5Ekef/zr5EXJfL7ka4/9HdPplCdOnmJy5ixt05BmS9q2Y5kuyfIU13X2FtibumEy2aUsK7q2Y5mmLBdL6Hu6vmO5XJJmqVkcny+pqgbf8+m6Ftu2sCyL0WhEGIbMZjNz73wf6Dl75jTT6YQoirBtm9lsRrpc0tQNXddh2w6B72MBnufQNi1d29K2NZZtUdc1bdtA32FbNm3X0dMTBD6e5xOEAbbjsH//AeIoYmPDhFoAg+EI27Yp8py6qnA9j7at8T0fsFim5j76fkDX9XRtS9M0jEYbOI6N77kMhwPm8znpMsX3fcqi5G//9m+pqgrHdsiynKpsiJMB0+mUum6JwpC+71dB1oDRxgaO65IkA6IoZjQa0fcdTVvTdS2DwZAgDNndPXtJ/s5FRERE1lFFgoiIiIiInNPOk6exbRvf80jTFM8LiKKQU6dOsTneom1bsuWStg1ouxrfD7BdG8/3mc+mRGFM13VgQRCE5HlBUZjFW8d2yLMFZbFLEPgslguuuPIgfQd93xOGIW3b4LouHS1xHO8tWJ/d3WUwGNC2DWfPnqFtO6688iW0bYvr+Ux2d5lMp9R1jed5bGxskNU1ruswGMZg9Rw4sA+w2T1jESUxFlDXNcs0xXEcLCxcx2E2M7vJHNcnCmNCL+Ls5AyLxYKmbZlN52D1tE1H1wM9pOkSP/B5xQ+8grIs6PuesiwZjAZY2HsL3X3f0/c9WZbh+T6e55GlGUHoc+rUEyRJwmw2I/B8+q4jjiIc2+FVr7qWh//6YfZ5Y2zHIUkSNjfHLJczbMtj+4oDpGnOfDojSWL27d9HWZvd9l1XY9k26WJhFvddjzNnTrO5OSbPC86ePUvgB2R5TlXV1FWN67uEcUyeZWRZjuM4eL5DHA9J0+XedQ8GA2zbpmkaqqrAdVzyrqOsa/YnCT1QliXj8RZ1VVHkBRaQLVOS2ARAruty6KqX4Lgu89mMrm2xLZvBxgbT2YzRaIMsy0wVRddTlQVtXTMYjWi7jul0ykuvvhrLqpjPZ8ymEwbDAYNhwu6ZXTzf/F75gY+Nhed5ACbkmE4JwxDXdQAfx3FwXJe8zFkuF+zb2mLn1GkOHXopZVESxCGWA2EYMplMCCMTpOR5hucH2LZNXVf4vk+eF3RdS113JkCqGvreoioLXM8hTVOKPL8Ef+UiIiIi66kiQUREREREzsl1PQbDAU3XEAQB0INlsW9rH33bmXZArktTN9BblGUBfb/XkqesCqbTKekyI89y6rqmazumuxPqumZr35jhcMBiaVrZ2LZDGIbkWUaapua4QNu0tF1LXVf09Fi9RZaa9jRN05iFXwuqqsK2bZLBkDiK8f0Ay7KwbVNx0AN+4DNIhuRZQV1V+EFA13WEYUgURWb3el3jei5VWbK1uUmSDEiimL7rsawe1/VMiJJm9IDjuFRVSV2VlGVJ3/fYlsXm5gjP87AdB8/3sS3HtOmpylVbH4uug83xmLZtVz9PRVPX2LbDcrlkNNqgLEsWiwWe52NZFnES8bKXvYzRxoCNzSGOY+H7LgcPHsTzHFzHJgwDNjZHHDy4Td91OI6N53ss0yV935EkCfPZnLZt2Le1H8uyV+FMR7pM6dqOtu3wvaft/LcdbNsmjAKCwKdpTXujruuwLJhMJvR9T1GUdG2LZVnm82tbzp417Yy6rsMCHMfB9zyapsG2bTzPo6xquq7DcR3msxllWZBmKX3fmSoT22H/gQNsbG7Qte1eyON5/t7v7P79B3AcB3rwPZ8gDMGCsioIwgAs8Hwf13WxLIuqqk3LqsUCPwgIo4goTui6HvqeQRKzf98+RsMRWbpkOEywbHB9sz/PdXyKoiRNlwSBzxVXXGmqZSybJI4B83vpewFlWZIMEsZbW2xsbjDaGLD/wD48z2M8HhNF0XfpL1tERETk/ChIEBERERGRc7ry0JVYtoXr+Qw3NkiSAXEcsVwucByLl7/8+wii0LTv8Tz6rmc+na3a1HgEfsBwOMSyLM6ePUtbN4RhyHjfmJ7OLARbZqF5NBqR5xnL5YLtK7Zp6hrX9ajqmt6G0XBE1/S0dYPrObiuy779+4nCkCAwu8jTdInrudR1SVWX1HXF9hUHCMOIvu9xHZe26cmyHCybLMup6woLaNoW23HMwnMPeZ4zm80o8oIkiYiigDzPaTuwLIumbvG8APqOtmnYf2A/GxsbBGFA05jgZTaZUuU5tmUxSBKKLKfIS3zfx/Vcur6nrmuqsiIKQ0Yjc6/atiFOYuIkAXoGoyFxktD1HQDz+Zw4DqmqiiLPKIqcvu+pm5ogDJjNF5RlQRiGpFlGWZlwYz6dUOYFZVFyeucsZ85OaZuGIDAL8UHoszkeY1k2gR8QxyGOa+O6DrPpFD/wSAYxWBZYNkVZUK3mBdiOg+/7RHFEXTfYjktZlWxtbZld/z3YtkUQeFRlQegHWD3YlmXmQRQ5QRTghwFZmlEVJX0HQRDQdj3z+YK+75lOJswmUxzXXd1HDxybIstpm4a6aZjP59iOg2VbRFFEFMXkWYkf+MyXC+aLBY7jYLsuddfQtC1VXZGMEizH5smdJ+n6jjTN2HnyNNPJnK61SJc5WBZd31HVNWVRUtU1y8WcQZzgui6ObdP3NstlSlGWbG6akKhtG5Z5StXUtLRsbm4SBAFf+7tHacqKbJmRLrNL9acuIiIi8qwUJIiIiIiIyDm1bUOapmbBvapJl0uyZYprOTiODX1H1/d4vs9kMqFZ7TyvqoqiyMnSFMdx91r4VGVF2zYMV3MAHMfFdhyuPHglGxubtI3ZxX7mzGnTj74sCPyQpm0oqoK6aRhtbOL7gVnQ7TqGwyFt0zCbTYjjGNuyKMuSjY1N6rrmzOkzlGWB73s4jkOWZkRRSF1Xq4V6024nWFUmjDZMf/z5bGZaLEUhcRzhB96qH79FXVXkRU5RFNi2Q9f3DIcjHNehKHLiVRugvu+JkwTHcSjKEsd1V+2FevquJ4ljNjc2qauK2WxGXdccOHCA4XCE53r0XUdRmHtflBUWDnXTUNc1tm0TxzG+77OxsUFdV9Cb3kqWxapKo6eqKjzfp6lr/MBUFbiuy/4D+1bBhU2apbRtQ5ZlzBdzPN8jjEKWyyWu660GY89Ny6K6xlm17FmsZgfYts3m5iau61JVNXmWk6UZSRLvzQoww60L8rxYDb32SJIYPwjMbIHKzODYPXuWrm1XFQolZVngus6qlVFHnmUmVGlbksGAOEmoqoq6qU1Fyur34qlwZbFYsHtml6ZpmM3mpp2SZWPZNq7rEgYBtmXTYyobXNd8pcuMujEVMU1d4zimlZJl2bi2Y34m26FtGvNZDgbEUUSepZRFsZqfkLKYz3FdlygKGW+OOfXEE+ycOk3btjx56knAVHCY8EgVCSIiInJ5UZAgIiIiIiLn1DQtw+GIuq72dnz7q4XlpqqxLMssrLoOvh+wMdpgc3MLx3EYDjf4vpd/P0EQcMUVV5iZA65LU7f81UN/xXy12z9LUyzHpq5rojAiiiOiOMYPzADepwYwW7aF47qrFkalaTszGLBYLOj6jrZtCcJorx2Q63oMh0M8P8D3fcLVIF7btqmqinS5ZLK7S5zE5HlGu2rFU5YlaZquXmvhOjZlUXD29BnCMNgLJMLAVATM53NO75wGepqm3lv0rut6b8d+UZjBzmZnestsNqPrOtMXv8jxfZ8gCDh9egfLlhGoPQAAIABJREFUstjZ2eHkyW/w+ONfJwwi6CGKE87u7lI3JkSwbXtvkb4o8tU5G6IoYv/+fQSBT5ZldH3HYjEnCExrnQMHDpDEMWEY4K7mWVjY+H5AWZTEcUzT1FR1iec55HlKVdUkiWlh9BTXcUiihO3tgziOw+7uLo7rUFW1mffge9CbwITetKdyXZ8giFYtp2xsy8GyLKIoNtdfloRhSBhGtE3LaDjiwIFtHMcEME/NYEjTlOFwRBRFOI7D2TOnTestC9quJYxCPM/8niZJTNf3poXU5hZRaGZtnD1zhqYxA5+jKGTf1n6yZc7Jk99YtT2yV79HZuCy49j4q3saRjF1UdPUFXEc0rYtddXQdZDl+So8cnFdjyzPaZuOnR3z2W6MNpnPFjz++OP4vs+BA9sMBjFhFDDe2rhkf+siIiIiz+byHLa8c5x333w3D53jZf5om5e+6nre8LNHOfojm888CMd+7Z3c+dXncd43vp9733Hds1zPgxz742Pc+2cP8sjEDEMj3OTgNddx5MhNHL3hEAPn2970nZ//PH/+Z7r2lo9wx9Ht8379Q//hbbz7j1LgEG//6B3cdNVzvPg8rskfbbP1fddx08+/iaOHn3EdL/T95+P5fk4X8D6f816+0HN9B+8/evsnufXw8zyhiIiIyBpN05iqgdXCeNdB3TTYlk0YRTRtQ9t1OK5LvVyS5zlhGOIHAUVWMJ1MCcKQLE1JkoSyKJlMZoyGGziOQ1mVDDyP6WSC7/mAhWM5BIOQ9qlFedelrWusHvzAw7ZtgiDEsixmsxl+4DOdTukJKMuC0WiDoiho2w7LssnTnOFgQBRGpjIh8Oj7ns3NMWVVkWc5GxubeKuB0kmSkAwGBL5PWZW0bUfdNSyWGW5ZmQHEdU1Z1que9j1xnLBYLICeQZIQBD4WvVl89kMzD8GCLM/wPZ8wCMmyHM/1sFcDhp3aZnv7CqazGYPBAMty8L2ApjYtl+IwIBlEFGXBcrGgXe3Ip4eug6atv2WxPY4T0jQzoUcYkecZtmXhOGax33EsRpsb9H0PFiyX6d6O/ySJabsOzw0oy4oo8lksFti2jes4ZtaE51NXNW3b0bYNTV0R+L4JCXrwfZ/6qRkXbUvg+eRpShj4tE1L33e4nkccxTy58yS+79OXHUEQ0bWdeX/XkOU5fddSliWua36WJBkQRhHW6thJMqCuKlzHxfbsVeBh7n/bttR1Td/1ppohjmlaEyCUZUmSRFiWhe8HtG1PFEWMRkOyNKWqKpIkJs1SXM8lCBKausbCIo5ibNdiMtklDCOKvDDHbVr8IMSyLXzf32tXVNctVVlS1y2O45JnOZ7vMd7aoq1q8qIwLbdERERELiOXeUWCx2B7m4NXPsvXdgLzHR75/DHu/N9u5d3Hdi7C+VMe+dQH+JmbP8Cdf/Slby5OAxRTTn35fn7/t97N/3TL3XxhfhFOfzEVD/DHf5KC7+Fzkj+89+EXfMhqvsOpL9/Hnbe9kzd/9EGW37X3X+LP6SLcSxEREZHLTVVVQM9oODQ95R2bum0J45CyKk27l7ZjuVgwHI6wV22MirwwYUJZ0tQNRVGwmM9p25aeDtf12Lf/AOPxmDAKSaKYpmmY7E6YTCZ4rkddNYBtdrXT4ziOWdwvCsLAx/c9M4zZtokHA8IoBiwWywV1XWPZNkFghgS7nrdqt1TSdQ11XeH5JpQwC+sVTdsShhFlWeLYLn0PgRuwWGYUeUmW56YiAouyqnAcZ6+10L59W3i+j+M49FgURUkyGBKEET3Q9ab1zXhzzGi0ycbmGN8PaJqatjOtioIwJI5jyqKkrRuiIMRzXaazKbP5hDxPSZdLfNflqqsO0fdQ5MWqvZJNWZQ0TUOW5UwmU2arljqu6+L5HkWRY1ngODZNY67fsW1sy6Kpa6Dbm2kBsFwsVrMkzEiEOIkJgoCmbYnCiKwoKIqSOA6xradmEYQcOLCPMPJJ0yVlVdH1PVEQUZWmkqLtGvOxWpCXBZYFg8FgFXjEOLbFbD7n7GRKWdaURUHTtKs5Dj1d3eA5Dk1ZEscmTOi7joNXXsm+rU22xmMCL6DvLbq2NwOj/QDHNhUhlm0xn81xHR9v1cao7RuW2YI0W2JZPXmRk2UZaZYzX6TkRcFisWR3d0qRF/RtS9+1+K5HEg8YjIb0mMHffhiSpbn5PbJsPN8FzN8EPdhYHNi/Zdov5TmL+ZyiKHA9z3SmEhEREbmMXJ4VCXtezlt+84Os3WTf7vCFu3+b2489ykN3/Sb3vPrZd9U/3536T1nefzfv/r0Hqdjkhre9i7cceSVXJ575ZpXy2Ffu4/f//cf57M5xbvvANh/78FEOfltlwndw/u0j3HHsyLc9ferY+3jrXQ/DK2/mY//2CAef90/0TdV/fYDPVDB44+t5zaeP85k/uZfP/pNruCE81zuv4da713wmxUm+8Ae/w+3HHmXy6d/kzh++i/fcmFzg93+77/hzukD3+bzu5QX7TJ/j/omIiIhcTH2P7/nEYcR8PmO8NWbnyScJQp8oDGiblqZpaJqGoiwIgoA4TsjzjDzP8TyfZbpkczxmsrtLmqUMBkOwoK4rwjhmPp0QxwlBb9H3c+I45syZ07RNw8bmJmVW4gcBruczn8+Jwoh4kND3PWmWYXUWo9EI27bNQq7nk6arHeRhiG3b+L5PY9m4rkfT1Hutdeh7HM/Dth2yNMX3feI4oes6mrpmvpgzGI6Yzub4gWn9U5UVeVYQxzFZljLe2jKDjsuS8T6zQEwPTVObxXrH9N93bBNC1HWN53lUVYnveVgWRFFEEAScOXOGKAyh7ynLkqLMcV0Hy7bp2pY4jgmDgLquydIlo40NLMte9ddPzK58113twDc739vW7IQPgmDvPNPphKIoqaqaKArBshgMh1hY2La1qsRo6Psep3WoypKiyAlDUy2wu3sWz/Po+o6yNDvx0+WSjY0Nqqoiz3PKsmAwGBCGpjolCH3SLMVxHbMjvyqAHqszMwi8ICAKY5q6piwriqIgGcQURb6qsrCwbY+uMfM2HMdhPp+zXKQEYURVVViWRVVVTCYTgjCk7zoTFq3aWUVWQJ6bKo2maYGOqixougZ6a68d0mK+IIwi5rMZSZIQuQm2bTOfz3Fd0yorSzPyvKDtWmzLZjgcUle7gGnBZXWdaS1Fi+N6jEYjmqZmOBwRBAGbm2PyImM2m7F/az9d25nKFREREZHLyGVekXAOzjavueVdvPlKgJPc98ULWZWQ8oU/vZ8KuPZXPshtb7rum4vTAH7C1YePctu/exev8YGvfoJ7/vICnv6imvKZ4/cDHq/7iV/kxtd5UN3PsfunL+yw4SFec8v7ec9PeUDNZ/70S8+vKuE7ev+l/pwu0r0UERERudz0Pf2qLc1wNMS24YqDV5Bnudnhn5vwwPVcXMfBthxTJYDFcDAwsxXynDRd4gcBnufh+Z5ZqG9burZjsVisFs0zDr7kCizb7G7P8oyyqghDMyOgLEosLDzfo2kazp49i+OYgbl5kZMkyd78A8exKYvKDOGtGxaz+ap6osFxHLquM1UITUNZFCwWc7OrvyyZzqacevIU09kM23aIk4S2bVZBRUsPbG3to+vMwm9VVji2g+N6WFiEQYDjmvkFpu2P2U2/WC5Is5SqKlmmSzzPJ4oiyqIgy1I8zyMMQ6IopigKzu6exfU8gsAniWMCP8C2LQDOnj5DFEWEQYDnOriumduQrBbuoyhc7XDv6HvM95IBRZGbwcZ1TZqaaxltbBAG/qoqoceyTDCTJAPatmUwGLC5uckVVxwkjhNc1zEL+bZDXdcsFgscx8XzA2azGYvF0gQrdUWSJMznU/quxbJgvLVFUZSUVUmWpXutj0YbG7SNqRSxHRc/8AmjYPW/ET09nu8RxTGeZypJqrqirk1LoK7rKFcVEkVZkCQJWZpSliVhHNJ2DVEUEkYBs+kUyzKDqpMkwYK9MKwsSzMroixo6ooojgnCkLqpCcKAg1dcie/7JrSwwXJs+tVsDAuLZDDE8z3arjFBCz1JMqDvOizLosgL2qamKHKgx3NdPNddVVuYdlAiIiIil5Pv7SABgEP8wP9gHj3yjQsZJJzkb/67efQDL3uO7d/jG/mZnwJ8n1NnvkcWj7/+59xzAvBfzw0/nPCan7geHzjxX/6cx17wwc3xAPjLr/I3F/39l/hzuqj3UkREROTyMR5v7S3aOo6D67rYtoXjuGBZOJ7LYmGqBGzHAXqatsVetZFxbBs/CGgas7BaNzVlWVDXFfP5jNlsymi0Qdd1tG1PXTfYtkMQRcRxwnKxxPd92ralrCqwbaq6NkOGo5CuMzvTR8MRzWqQsed5RFHCYDikbVratiNJBmbB33EZDkdYtr1azDWL5mbWgZFn6d7O8H0HDnD69A6249D3MBgMTYuczpwnSRI8zyUIAhzHXlUgONiWqULwPM/MUyhy6M1iuud7OLZD17bUVU3XdpRFSZ6bcAYLXM9jMBys7reNZVlmKHAYsVwscFehRbOaVwE9zmr4srWaueC5LovFgqapTYVH2+C6Hp7rsr29jee5DIZDsiylaUz1geu59PS0bUvT1HszE6qqIssyiqIw/f8ti6ZtiKKYuq5NJYjvY1kObdPi+yY0MoOkA6I4oqprsizDX+3G77HMnIW2MQONRyNsx6anw3ZsNsebZoHegsV8znw2p64qyrKgKEvapiWKIjzf7PZv2w7HcelaMxA6CAP63lQkeJ4Jn6qqJAhCiiKnaU37q7br6Lse3/fN4n/bspgvcFxzrDzPGSQDFvMFbddSlgVlaWYZ1E1t2i75Af6qUqQqS+qqNgOry4o8y/aqEcZb+3Fcj763cB3XfK5tx3w+xwJQayMRERG5zHzvBwnpA9z3Z+bha1718gt44G8GFH/x3x99zle+5p9/knvv+T1u/+lnDny+PD32+ft4DBj8w5/ksAP+a9/A0RHwtU9x/CsX8EShT3DR339pP6fv2r0UERERucQ83zcLwHlB3/YMBoPVoOGSvjfDg7uux7YdXMejrCozcLbvKcrK7NauG7KsIE1T9h84QNebHvR939F1HclggOO4pk2P7RCEIePx2FQ6OC5d19J25phlWTKZTCjKiq7tqOuaMDSBQp7l9L0ZAjyfTalWbYFc114NgTZDdU3QEOG5ZnG5bhr6HqLYVDTYqyBgNNqgLErKsqKtW+qyoq5NtUMcx4RRQNu1puoiyxjECX3X0q2+PM8lDAOSVRumsixwbDNTousaHMcMPo6SAa7rUdUNRVXRdWZBP0li+t4MWu4By7bI0hzLcoiTgWlVFJrhy1mWYtsWbVtTFAVd368W9lkNHjZDicMg4MCBA4RBSByZNkJFUVCWJXmekaUpy8ViNbjYwfNc0iwjy/JVaOPS1I1ZKK9b6qrC931838d2HIIgXP3sZqB133X4nqkc9gJ/b3G+qhq6tqPvO7Pjv23AspjP59S1qRSZzidMZ1Pm8zld2+P7Lr7vM13NFHBc0182iWOWacpima7aFVkkg5h9+7YYjYbkWY5tO4RRSN00BGGEZduUZcGZs2eoqorxaAyra51MJnh+gOeZ/1dirf4W+r43cx/qCjfwCVdVInmec/rsWabTOZ7n4vsevu+bcMH3iZOEMAqJ4hDX9+j6nq7vSdOUsqwJ4wF9b5mZHKpIEBERkcvM926Q0Nac+tv7ufPXf4fPVMD+I9z0E+fup3/+El7zj48wBh77xPv4uff8Hxz7/KOcKi7gKS6F9mGO33MSSDjyk9eY55xruPGnEyDl2L0PUL2gE6R84XMPmIeHr+EVF/39l/Bzuuj3UkREROTy4TjOakByT29BVVdgWXttYVzHIQxDFvMFRZHjee7eDvWiyCiLgiiO6boW27Koq4rADwgCs0jb9z3dqoqgrs3Q4eViwXR3tlo89kmXKbblmLZInofrurSrFkV13dC2HZ7nUZYlXddSNzVJkpgd83HMYDAgL3Lqpl59meHPbddRNzV5lhMEAV3XmmNWFU3TkmUplm3Rdz1lVYJlduqnaUrTtmRpTtOYNk5t1zKdTVfBQk1dN2RpRtd3tE0LQJblFEWJZYFtWRR5TlGYKoSu70mz1AQZtk0QhIRhiOuuKjtWn0PTmKqCruvI8mxvA/tTlQv2aoc99HshSxCY+22tKh3KslzNb3Apywp6ezVEGuq6wbJs+h4sy2L//gPYlgV9x87ONyvBkyTBsi3qxlRUpGlG17Zm9/5wSNs2DIdDwigyrZSa2rQYamt8z6fIc6IwxHFdEzytZhlYlkVVV5RVgYWNbZlKECxwXZ/FYont2LR9S1U3LNOUrmtXrYNsqqrG9U1wsVwuqWoza+GpigTT+qokCDziJFm1uKpXMyE6PNeEImEQUuRm0HRRFHuhVRAEeJ6P63jQdwS+h21DGJg2TEkywLYduq43lQ70+IHPcmEGX/uBj4VN13VYts3meLxX/dJ15hwiIiIil5PLfILTw9x58y9w5zle5f/gUW779V/i8JpBwQ/d9U7ecNe5znWEDx27mcNPe2Zw+Gbu+NUp7/3IA5z6yn3c+ZX7zPlG2/zQ4Ru54fof40dfew1Xn2NA8Xd6/ouh+vy9HJsDL3sTR175zeev/Qdv4upPfZzHPnOcz7zteo6Mv4Nj7zzM8d/7HX73/hrY5OiRH+P57KP5Tt9/oT6n5+ti3sv1zu9vgje+n3vfcd2FPLGIiIj8PdfUNaMNszM/CAOKosD1HNI0o6rMIrXvB8znpoWO55u+/GVZEIUxVVXiei7D4ZA8z2i7lsVyaXaiB8FeOx571eonDALyLOMbJ08S+sHeTnzb6Qlj06oGy8N1HKqqNoOGV+GBbdvEcbjXpshNPdqmoWla/MAnzzMz4NgP99oNJVGM57k4tk2epquZAAltC7PplKausWyXQTLAsnscxyziz+dz8jRla99+s/s8CMjzBV3bmRkHeQmseuK3Ha5jU1c1YRStZhHAaDiirGqwYJkusW3b9PbPUlzXoWlqBoMhi8WCPM8IgpDlYmn68LsuZVWSpmax3LJWi9NYlEVB55md7+PxlhkIPT7I7u4uk8kE3/dW7X8sM9OibVbtnWImuxMWiwVRGNG2HU1T47oOXd+xsTHaCxiCKMIuzWDntjPtlM6cOc14vB/HMfvW2rZjvpjjemaGRZwkWJZFXZdUZUkySGjamq4zw5ObxtyLtmn2qg1sy7SLgp6yqijy0lRaAL7n0dNTVRW27TCdTHEcB8/3GQxj0mxJkReEYWxaKvmmSiKKI/xVIDWbz1YtkMBxXOI4Np+F4+D7nvnd8X2KIse2LZLBYPWztdD1zNM5FjaDZMBsNqfrTNDUd6Z6wbIssmVK13fEscdsOsVzzUBnx3FwbAfLtsBxKMty9bOKiIiIXD4u8yDBY7A9ZvC0f0Mtz+6wrAA2ueFtv8zPvfZ6rr3KW3eAF+zg6/4FH7thhxPHj3PPZ/6cv/jrKdV8hxN/9ilO/NmnAI+DP34T/8uvvonDo4t2GRdIzRc+Z3bJX3vkeq5++reu+kluOvxx7jjxIPd85iRH3nRozTHOZyHb49q3/Sve/iPP9rm80Pc/u+/+53Qh7qWIiIjI9w7Xc2mbdjU4uCXLc1zXVB1UVY3vu7Rdg21ZhEEI9MRRbHZ5F2YQ83KxwLZNS6G264iikOFwSJZluLZr2uMEodkdXparBV2XIssIwhBr1Q4oXS7xPBfXNVUDg8GQs2fOMp1MiWLTtqipa0rLIk6SVVukjjiOmM3n+J6H5/kkgwGzb0yxLRvXM68pytwskPseWDZ9ZxHs9zlz5ixlVVE3Na7n4ABJMvj/2Xv3WFvTu77v81zfy7rsfc5csLELqghERg5yC2lCPQn1tJITt0PSQlxowRDRQBGUhBTJtKS0TRMllhKhUpOCnQgahIgKLRGjGsMfYxFsNTQ4uArCKoREGAz2jM/Ze6+13ttz7R/Pu9cYYs/geDxnbD8fyfI5Z/be63nfdy3pnN/l++F4OmLbFmstGViWmZxLxP0yL8QUabu2FMKtIaXiDZBS0nc9wzCAFEgpSd5xeXl5dhWU6XmPVKo4CdZGhZSyyITnmTknrG24vrmh6zqCD+Q2gxCEmJAqr18/EYKnaVpAsCzL+vNjiXmyZZPheDgi5Ho/xuKjaGzDsix0fTnvxcUlzgXkWvQ2xmKELaJi7+m6DTml8+ZE3/ekHBEIEJwL/rObySnSti3DNLDf77i6uirC5lWkDJCzQwhB1/aEFMr2ScoE77lz5xLnlvLeSBm3TAhZPBLzNGGMwmiDV56+71nmBa075nliu91hbRFbn4aBzWbD9dUNm36DX++/EGLdgimNruA9d+/cZTidaNuGeZzWzwUY0xTpuLVkSjzSsvo4hIAQ0iqe3tF3luF0woeyLaNWcbX3pWGTqyShUqlUKpXKS4yXeCPh3+Qb/sZf44mPdujGp3nX//xXeMu7rnnPk7/IY1/+GK96np/yqm9+K9/3xHOIeJ8P+yiveeLrec0TXw/Rc/rdf8k/+eVf5KmffYr/9zcHPvTef8B3//l/yre99a/xxMs/Ba//QnH1Czz5Lg+8mj/12O8/zyX/zle8Gt73K3zg/3iK9/+Zr+dVn+AQjL3zKF/8Rx7n9W98Pa/7/E88ZuqT/f5P9jl9QnyK7+XH54v4tr/3+z4TlUqlUqlUKi8CQgjmuRRJ+37L4hzX19c0TbPG9GTapiGFyDIv9NsNu92O4/HEkiDnSGsbTsNQivFaYawBirDZGotaC8felQl3awz9tmeei5h3XkrBOAZP35csfmss1hguLvaM04wSCq0UkBiGASEVw3Biuy0NC+c8AmiahuE0YLShacrGQ1wLxVormq7l+v4B50vRWygwVuGd5+bmQGMtTduePQslliafi8reP+sOSF1H07QM44gQsN1ucc6Xr02Z2TlsY2lkQ9MYpCgT+zEltLY451ZxsiTljF+K8DqlxLIErDVcXFyyLAvD2nSJMeIWR9e1DKeBprEIIfnIR54p0mFtca5sbzRtQ2NtcTNMEylFtNK0bYdSmrZtyTmhlGKaVu9CY4oA2zTEUCTJ/abn+v59ICOUODsZUsp0XY9UkuPhhBQZ5zzBe5q2ZfGe3XZPWj0QUgpiEqUJtUy84nNfucZOtUzzvIqpI7vdDm1LXFDwESElm37DxZ0LxtPIMIwMp5G2a2jbbt0WKY2G7W67NiAEeZq4vLzkcDgwzwsPP/LoGjc1gxDsd4a0NtF22yLunoaRtEZVOe+xTUNMmZQTSgga2xB9YCGfmxX3710xzws3N0de/vLPIaXE6cPPsN3ucOt7PlEcEJtN9zE+hZVKpVKpVCoPjpd4I+FjoB7ldX/xr3H68HfyA7/6i7zlv/173HnrN/GaF1KP8Jyvb9i+8ot43Su/iNc98fXw9C/zA3/9b/Hkv/g13v5D7+ax/+ExXtAkmxeQD7zrSd4HwK/wfW96I9/38b7w8E5++v/5Gl715R9rI+CTLWS/SIXwT/FzemHuZaVSqVQqlcqnD5mEVJJpnmmWlpwyjbWkWJwHWtuyrZATyTnUrAg+ME0zWilyzGgtMdYglKRpbMnxj5EYA81aoDXWlKK6bRBSEkIg5sRpGtnv9jjnmOeJZVnQWpeCe4hnr0HMCWJeNycy3odzkT2mBDkzr4LonPN5CjwtFCFxThBgnhaEVGhtuL6+RmuzSpnjebJdeo9SihACbdMSYgQBQkh2uz0pRLq2oe07QvCkVSTctk2JHxKCpmk5nI5kMvv9DucWICNQxSchyz/ZYoxorbi6f4VSCiEkTdOc45FSSrjVheDXc9nGnifcpZR47zBGc7g5IaQkA7vtluA9KUWCT7RdxzAMmM6wlTsA2rZlXmXTUCKHTNvRNi3DMNL3HUIJxuFUoogiGK2JsTQfxnFEyuIqAIG1e+LqrbiVMYcQmOYiebbWFteDkmhtOJ5OCEpjIud09mPM81zOHSKLm+n7DZlEihFtyhaAknJ1UUBKkaaxkDNKKeZpQgpJXJ0SOaYii5aKxS3l+bQtGUjre+W2SWStLU2n9SxSFncHgA8RYyGsTovD4cCyTIQYMNYSQ3GApJxXp8eMbZrV7ZGQEpT+9NUZViqVSqVS+czk0/NvJ+pRnviv38SrLPCRn+V7/84vcnqBX+JD7/gbfO2feyNf+bZfee4vfPTf4tv+8lfxMsC99//jN1/gc7xwfJB/8tQHKXFRj/Kyl3+c/+0N4HnXO36Bqwd95D8AD+Y5fWbey0qlUqlUKpXn4nC4oW0b2rblenUGeOfJec2mF4Jxmun6js1ui9KK6+sblmXBtg3X1zfM84JWmrt3HypbCNauYl3J4twqc2adto/kFLm6vkLr4kIQFOFt0zQ453HOce/efaZ5Lg0AARcXF2hr0NrQNC1SSmzTIGTJorfWIEQpzN9OgW82m9JESEWILIRkHCdubm6IMdG1Pd45hIC+72nbIkCepgkAKSXLspxjn5q2QSmFVIKu6zC6xCaVBkApsttVBCyEYLffs9luaLtuvS5/LiqfTkdSSqQUub6+JsbMsrhzYbvEKjVkSmNHrxE5SkkEkGJiu92WDQ9ryxlkkSp770uRPCXIAoBxGBGU5kyIgWE44r1jWWaEYL33jk3f8/BDd5ESxmk4eyduGyTl/1kl0nMRSaeE1prhdCLGVCKPYiILEFJijC0NnlSsykopmqbhcHPEe4+xury/Nj13795BrdFKRZpcIrGmaWSaR9qu5XNe9jns9zsu9nt2ux0hhNVrcUMM5fnHmBjHCak02liMtSzLjFIatQrEQwjEGDkcDozTiHOOpmmxTbM+m4RzC7vdHq0NzjmOxxM5Fz9ESqX5sdn09H2PbSwxJo6HA9pqtDHM80SKsURyLY579+49iI95pVKpVCqVysfl028j4ZZHX8+b3/QLfOPf/TXcP/prXVc9AAAgAElEQVRB3v74q/nOL33h1hLu7jdczcDP/zLv/6ZXP3c0TbfhDvChF+zVPwX86lP8+G8C9nH+ytu+idd8vOv51R/lq9/8JKf3PclTv/04X/XKF/OQnzgP5Dl9ht7LSqVSqVQqledCSb3m/wti8CitSjyRsaTVA3BzONB1GmMU3gfaruH+vfvsdtsSzWMMLnjy6Yg2htNwou96lNYlT997bGtp2hILczu937Udw2lASYlW8tyAuJ0av91ssE2HkALnFowyaFPODKXonlZpcNd2TPNM17VorZnGCakkxmh8CGvhOLHZbIqPwTZIpQgx4tzMsnhyysS1wDwMA3fu3MEaSxABpVTZBJByLTI7tFZooxmHAe8DZAgh4ENAKEn2kd1uyzSOdH3PvCy0bVdkvpRrbJq2NDZu3Qo5cXnnkhRL82MIw3kLIISw3pvyLIqvwBfXQNdhrEUqSWMtw3AixohShhDLtP04DuSckFKuTgOBMZqcE9ponHc01mAbw83NDWmVJGulabsWpWTZbFhdB0KUGbayNZJRUpSJfa2KiFuq1TNgiTHSa4PzCzFGjscT+4sLUsoMxyNKaWII5FTOV1ogGaMN2hpySuSYME3DvdOJvdwVh0Uu0/4pJnIGaxu0MSWu6vpmdW54TjkzjAN9XxpIMYbzlkdaX9P7sp3hQyhfkyJd33M8HhjHibZpSSnSdR2b7QbvPUKAQOBWx4M2hpwy41i2OoqwOqGkJpMe0Ce9UqlUKpVK5WPz6bmRsPKy/+hb+YbPBxj42bf+n7w/vnA/237ZH+N1Fji8k7f9xL98zo2HD/3fv8D7Af7wK3nZC3eEFxDPe975Tk7A9k//iY9f+Ab44sf52s8H+CA//s5fe3GO90nw4j+nz9x7WalUKpVKpfJceBeY5wXvF2xTpumNMbRdR7/pIGcu9pdr4TWxLK64B3Jmmmbu3L0LgLUlykZKUQrv65R4IiON5DScmKcSAxNjoOtamrZhs91yOBxK3I1SuGVmv93Rti37/QUXF5e0jUUAUpQIpRD8OTYnr1P9Skoaa4ghcOfuJSFGjqeBeZrxPqCkxPvAsiyr8LhMqJeJ9CPOBQ6HI6fTqRT3rSX4gLVN8SX0XYknyqCVJvpyfQhw3rEsntPxVIrdORNjQkuFkoqr+/eBImoOoUT2xJiYpum8oWCspmmbMsGeEt45hnEs0UumbGGEEHjmmWewtinxRyEwDDNC3DYVihR722+wtgEhkFKQYkBrRcoJqcQ59qnInx3eexBgrGVaZq4PB2LKNE1L23VkoO1avHMlfkgpNpsNfV/8BNvdnrZteejhh2i7Z70LIkMIvoip24aUMk17K912PPLIw0hRRNun0wnnFsZpJMRQ3ktK0bVdiQeay7NSUqLWaKzTMJByRkuFRNLYFq0tbdvjFlc2Aqbx3BCbl6VEH80LV1f3cUuJUBJSghDYtkUoiV9l0otzKK0JoTSIlNKl6eQD292OTb8h50zXdiitzl6NFIuQumkamqbEhfXdBiU13r2A/7itVCqVSqVSeQH4tG4koF7BV33z60vW/Uee5Pt+4oMv3M9u/xjf8I1fhMXz/h97M//ZX/5R3vUvnub897noOf32r/DkW9/MN//dXwMueeJNj780GwnzP+Xd7/HAhtf/u1/0PF/8Cv7o468A4PQz7+Q986f8dJ8cL/Zz+ky+l5VKpVKpVCrPQabE8HR9T9f3XFxcrLEvnpzh/v37a657Rgi5RgVlLu9cIqQkpYxzZcLcO0cKEWtKDIxfY412uz1KStyyIBBopUs2fozknEg5YY0tMgME87zQdR0xhjXPvlkn68tkd1gn9VPKhBBJqWwmDONEzuCcZ5ompBTnrPuwCnRTzCipsWsh3i1lmt/5haYxeF9Exdvtjv1+V4rWMQAlf19KWab+dWl8WNNwdf8+TdvQb/oy5a8k2pQlcWsbjC5iY3E7Y5/TOSrIWotWmpwSbdux3e7o+w0xJaRQhBjwrmyKlAz/cu5pmjidhlIIX0XPyzKv1y1BlMZLSonGNmy6TXE7dP3qIlBIWYrqUpUNhw9+8INM88T1zXWZ0FcKIW7PnFFaleegNd6HIlaOkbA2Vaa5eDOM1qtIWgLivOFhmyKCzhm0MatnYeBwOGJts244iLLJkhJK67NgOsaEtS0ZAVmUWCxtSqySNUil8MEzTeP69ZG2a+j6HiFKo2u72yBluZ7ynihy53EYzo2veZ4hZ+Lq5lCqXLM2BmsN3jv0upnivV+bCAYlFV3Xcn3/HrvdttxTIZFCnM8zzfUfDpVKpVKpVF56fPpGG63YL/kavv1PPsX/9I88H/iJ/5UnH/9XRb7vf9u386fe9gf5aa/nbz75Tbxm/d3Lnvhv+D7/t/nOH/4V3K8/yVv+4pMf5xCP8tpv/16+7Us+tlD3X/f1Xyiu3v2zvMsB+8d57Iuf/+s/73VP8Jof/kHe597Nk+9+E6/9Dy5f4BO9sLxQz+kPwoO/l7/GD3zTG/mBP8iXvuF7eee3vvqTfL1KpVKpVCqVwsXFJTGVSB+5xgs577DKcjoeS22fjNaGw80BqQTGZIzWbLodVzdXCClYlpmu7VmWmZSK2DbGUiz3PtBvNoh13innhNa2TPQDxqgSMRQ8LkROww2bvlsL9+I8oa+0Zp5GvA8IIZFSFCFy1yIkzNOMkKI4B4KnaVoQkHPZBHBuYXEL+4sLTscTMZTJeedL/FLf98zTshbJ3bNT/UKci/45Z4QszQ7bWMSyYG1xTADMy4K1lmkcadsGpcv0/G63I2XOOfxN07IsM23blc0KMlLAdrsjpcSyzGit8c4zDEMpsK+F7dK46LDGksi0bUffb+j77dpIUDQpsd/viutiLlsHbdfi3O1GhkFKhXPldcZxJsaS/T9OE488tCPlRCbjgieEwKbvVydCXt0RoNazSinxwfPwww+XqKvFo3QRI4cQmcaR3f6iFO8TaGVomoZhGFCNRGt1btTc+h22my3OF69E2/f4EDA2c31zs0q1WTdkLP12g3OBm5trmqal73uMMvRdz7xM+BBobIvTjs2mZbfbcbi5wjvP4XhkK7cYY7i+umK339M2bXF0pFQcHtPEbr8vIvKUuLm5oWtbjLWcTkekFDSqRSuFVhprG1KKjOO4Oh5mlPr0nverVCqVSqXymclnwN9QNrz2v/hW/qgF3K/x9v/thRQvb/iC/+R7+em//xbe/KbHeM3LL7Hn/2bYPvpqXvem7+BtP/xW/rvXPfocP+dB8jTvfmcREX/eVz3Oq/4g33LnT/DEnyy/fN8//AU+8Ck72wvFi/WcPhvuZaVSqVQqlcrHJqeERJBTXiNcEilGjDFkQArFPE0opc5xQvM8k8ksy0zfdey2O2KMiJzZ7y8QojQkhBB455nGgWVZIOe1YaE5nYYydS8lw2koZ8mQYkQrfZ5Y11rjFr8KfRVpLSDf+hOapkFJiTUWpTTGGMhl00JKSc4wrfFG3gemceL6+prD4cA8TzRtiWnS2pBymVSHfJ5sz7nEDrVtQ9/3aKMRQiDWJsYwDutk/8Q4jWw221X2G4vHIARuDgcW55jnuUiqmyJt7rqesLobSsa+Z7vdkqE0FpTCObc+m8h2uwMEm80WKQX95lmXnPeuiKnh2W2QlIpbwWhSTsRQYpeEEGuTR6KVWd0CmTuXF4QQ2Wy2KF2kxD4Eurbk/Gujy7YDGW00Sklyimw2m9L4UMUVscwLXb/BaIugbEVsd3tAELwHilNhGE7rEooAUeKF5mXBWIOxlpjK9oix9tyoCd6fGy0pJmzTFOm2EGTSumlRmj7OLTRtg7UN1li886RY7lFxRZQ4p91+j7GGprF0fYcAQoyQM9bas/DbO4fW5X2ppELIkod6G7tVRM76LBZHCISQdF3PZtOfheCVSqVSqVQqLyVEzjk/6ENUKpVKpVKpVCqVf5X796/Pv75798XfEv3o13/Pz/0k8zJhrCUER9s2ZBIxZYbTRE4JRKLvN0zTzDgMWGt4+JFHSCFjm4ZxGjkebtjt9jS2KWLj6JmXhWEY2W43XF5cEEMgrMXsxZVIncY2XF1dcXnnLjEGpnGh3/RorZjmmYcfeph5noASEXM8HEvx2BpiDNjGEkOgbTt88BwONyUKSCmMtbjFEUJCK83NzTXTNGFtg/ce5xbarsNoS0xFWmyNYRhPdF1PY1usNVze2Zfp/4+KI3LOsbilyJ5TLBFBwBd+4Rfx4Q99mJvDgf3FBTFFTqcjXddxOp0YhpGXvexzgdK0cM4DCecW+n5D07TM87Q2GDwpZaZxYrfflQ0F7+jaHgQIKVnmGWMMfd9xfX29RhFl7OpUkFLQNA3zNLPMjt1+x+lURrSsKWJmIfK6aQDDMBRZc9tijGFeZnKMWGMxRpftgLZFiLKF0jQNxliurq7YbveMwwkpNRcXxVNxOh7XDRRzFjyH4On6jsPheI57ahqL0prD4YaHH3mY4CNCCLabLcfjYY0VikghmKeZaRrp+g0v/9yXn4vz9+7dK9duGvp+wzwOa2yVZ7fds7iFcRgQUrLb71mWBa1L08v7gFSClDLjMK1xRMXl0fcbPvzhDwFibeaULYvbf3Jbo/Hes91dsCwTwXukLGLszWaDlJL9fsfN9RWH44Gv/5bv+tR/yCuVSqVSqXzKeTH+Tn84HAB43/ve94L/7Ne8puTnfNpHG1UqlUqlUqlUKpVPPT4FErA4R0qRcBrRRjNOE0obgvdsNj1SquItCBFrLVf3rpFKc6FKEdWskUjaGIapFHC10Wz6DiEki3NlEj6VonnbNIQUMEZzeXl5Lpz3fY/RRTwc1libIi8umfxKKUJwSAldd1ssl2itmZcFKTVSRrq+AwTDcSCERFQlc19rwzRN7Pf7IvQVAqUkbdcSYyDnhJwlTWOxRiPWXe8YAlJIfHBIIXDeFUmyMcxzwBpLXj0RrBsLRmuiixijaZqmxBrZprgfEATK5PptTJO19iyDbtuGZWGdai9NlJQixth1IwRCDPRtj/eeEOzqjYhr0d3jnaPvNyilOdwcyAjMZAGJW2aUKpsKt8Jlaxu6vsPo8v05JciZlBJKyXULJDEvjt12SwgBpTTH44G27ZBSIJVGSY0QkhAWur4vxfu12u+cK5sMORNDwDYteb2PJeqpND1Yt2RSV6KFrLXM0wmhNV3bkXNiv9uRYiLlSPQRiSDESFaZZV4QUhaRdIbDsfwj3IdwjokqXgTBZrvBB1/ep9PEPM+0TYOUGh8Cx+MBY8qGTd/3DMOId+U9Ty7bItM00XYdbWuZclrdHcVfMc8ztjHMztF2/Yv9Ea9UKpVKpVJ5Tj4Doo0qlUqlUqlUKpXKp5pxHsmiyHSXZWFxDiU142lCK8mm75FCobVht9uy31/QdT3OB4ZhxHlHJpdJ+mXGBc84jbjgsNaWmJw19z7nzLyU3HljzdqgKBPhZo2kySSUVqQUi9hYa2JMDMMIlOZE13UUb0OJ30k5scwLbl5IKRFXATAZUi4y6ZQSl5d32Gw2uDVmyDYWrQ0COB0PJeffO/q+4+JiT9s1aK2Iwa8NB82m36yF9ZLnP01le8Aay3a3Z/GeLCgT+KpE3+TVjaC1Zrff4f2CbUrMTdNYtNEYY9f7MxGCR6kyxb7dbLi4uKBpmvXaAlIqQLAsC8fj8exRiDGVaJ0s8Os13r9/D3IugmihWBZHinEVG8OyzGszRmOMpu9a7lxeorUmx0T0jsbaEnO0eiRSjMxz+T4oQummaZFSneOClFZ459hui3tASHmeqBNSsiwz290OVueE8wsIyrMLnmEcSiMhRZqmRWuDXQv32+2GzWZL0zRM08j11X3G4YRWihQzNzc3HA4HnA90a+F+nidSzkxz2Ta4lSWHELm5OTBPM+M4srgFpQQIzjFHRf7dr96D4uu43U5pmoZ5XnDOs8wlAsxaWzZBVqfGsixc39wQYizNh0qlUqlUKpWXELWRUKlUKpVKpVKpVJ4Xoy3LPDOMAyH4UvA9HktcTtvRde15Sj7nTIoBtyxIKdhsOlJKBB/KdLmxeFfikdq2pW0btFGreyGvnoXSRABQWuN82TIA2PQbpJJnD4NdC9gxRKRQa4xOyagvE+ylcSCF5Pr6ihDDWnyG02ngeDwyjWMpmgMCQUwRKQWIjFw3ATIQU/EhiLVBEWMkxXJt3gW6tqcxFqN18TWo1ZUgBEoqYoyo1f3gnD9vEbhlIQRPCGWC/fa8Kcbio0getziWxeFc2XZo24YQwhp95HDeYYxB6yLxDSnig8eYUrCXUiKlQgB+dQiUhoNEKYmQkqZp6PuOEDwxhnJfY3mmOVPE1BQx9rIsTNOID+58DhDrBoKgbVvmeSaGxLI4xBpZNM8zeX3Oh5sbvPccbm4YxwFyIudY3kv+tnFhV49FZp7LnwtkuR/zglLlPrnF4eYFJWVp4KiygH8b0RRjBAl+vTajDcZoYkqcTkf6viemRErp3JCxxp43QKRQxJDwLqCVJsVcoo1C2Wzp2nbdiilnadoWKSXzNOLcQoyB/cUOqST37t1jHIfyfssCtzikLhss5fXmF/sjXqlUKpVKpfKc1EZCpVKpVCqVSqVSeV6EKHE1zi0ordBKMYwDbdMwjSPTNKJ0ibUZx4kQPW3X0jSWTd8xDifGYSTGxHa7o+967t55mIvdBRcXF/SbDRlIKXFzc4M1BqM1zrsiQHaeeZ7putK02G56nF9Y3EKIoRS7SWuWfZnid24BQMrSiMg5E2Ip3gcfUFIjhQZKtM1tYXyaxvM0vm1atDHr9Ufapi0ROqu4N4RITAkfImLNNwqhTP4fj4dzA8L7siFgjYWUCYtDAkbrc1FdK03btGilmaaZtmnXM03rBH65Tq00fb8p4ueU8CGsUTzl/klViu9kCL5IkK01qyjYIJXEO48Ucm0ONOz2F6SYMMbS9T1CiPP2QwasNUgpMEYzDAPee4ZxZJomnCvNimVZzpsLNzc3pWGTOUcHLbMrcT/es9lsiOvGwjSNXF3dZ5pHnF/Y7jZ4X5oT1jZcX10VqbSUgFi3GRqOxxPWGBZXthRSzlxf3zCO4ypVzsSYzhFSOeXiJIiRFAKbvqdtW1KIHI8HvHdopUuzy1r6visNqXUDJeeMkBKjzbmhIoQsWwldi7HmWSF3KibvW0+EEIKcE7vdjjt3HzpvhUhVGk5hFYKXYKf0on++K5VKpVKpVJ6P6kioVCqVSqVSqVQqz8s8TbBGExldprhvi8wpl4K4RpBiZByLOLnEETVrUfq2uJppmwYfSwa91oYYEzkVIW2Z7Hdr9rwkpgQZpFQlcmaa6bqGtusR8sS264ghEWJASEkmEULAuaU0FGQpKOeci1+gaYihTLz7EGjbFiMMUpZIHigT7DEG9vsLrDFQjoZUco1fymsRPiGlpOt7YozYpvgfrDZodInYAaQQ5HXS/bZZkoHGGHyM5zx+rTXGWk6nE1rrdYNArmdXaJMwq4y4bBQU0W8exjWiqWxg5Jzx3tNYi4B1k6NsHdzKo6E0N5qmoWlbhJD44FcpdFpjocB5hyJhu44Ma0xPS0qR29ioZ7cgyiR9iYgqz7I4BjxN0xbHRNOQVvH0cBqQUhZxd85Ixepg6NfrL7FMAEab4hJYtxOUlGuRXpJyOjc5yjZMBOD+vXs4F7DWkFNxX+QMjW0wUuPDQmd6uq5lmgaub665vHO3NJxWMXda36dCCJxzCMpmg9KaftMjEIzDiDGGECIhRKxt0Kt/whiNlBtumw63ngQhBGL9vEilUBLapikRUY1dI7oqlUqlUqlUXjrUjYRKpVKpVCqVSqXyvIRYomt2ux13H3q4FNC7rkhztTpnw8/LXArtSjGOZQMhZ7i8c4fNtifEcHYCLMuCcwvjMDIM41kkfOfO3XV6XJ4nuqUqr3E4HgkhnaN/mqYDAYfjcY0PkszzRNM0aG0wuhSRYwjEmOjaDiEE3vsSTbQ2FVbH73kroUzZl+n02xz7y8sL2rbImYv4uEyTt01DzmndTPA0bYOxlovLS4yxWGPRSiOFIHhPSAEXPCmXBkdO6RyFFLwnxHhunJAhxcQ4TiUmSQqWZWae53Pzo8iNIzmzNl4yOeVzvJN3nr7fEEJkWRxQ7ue8zFjbIIUs3aByZRxubs5egxhKsyKmIojOOZftBFXOdxuXFHw8uwCklGz6LSF4pCyNEyUl+92Ovm8RIq9bGye0lmw2PZtNj1LFa5Ez2MbifWA4ndhsNsWfIOQan1Tirso1eYxtynVIyeXFRYkTWhaGYShi8ODx3iGFYp5mtpsdd+5ero2HhFElDitlaNaYrbZtiSFwPJ1QSnGxvyCsjaayXZDxzq2xWRnvEzEmpCjeCSEEUghsY0k5MU0TJfYpcnN1g1KaEMs9U0ZjmwZy5uLykk3fs91U2XKlUqlUKpWXFnUjoVKpVCqVSqVSqTwvKSYCicVJjNGknOjXKXUpJVdXV1hjSzyO0ozjiFaapm3JKZ+nsKWUXN2/T9d3TNNUfANS0lhL3/dAaSbMcynQdk3LtEbVzPOC1oYQI6fjieAjwfu1iJ5W4XFEqrIlMJxOWNtwPB7p+w6tFc4V+XMIpVjvgy9xNjGenQGbzYacKdeg9RpR02CNIcZIYxuEKEJeKQ05p/V7MiFGpmUmrtFI5WwZBGvDAUCQciKTMVYznEZ22y0Cyc31ge3FjuF0WmN1yqS9toZMxjlfpMfrlLy1DX3f4xZH27WMQzmzWJsFWuvyOqb8Wdt0JQoI6LpSvPfBIwVoYfBhwXuHUmXzpO87YipbIs45QvC0bQtQhM3rZoqQgsPhUKKCUtlUKZsKxX2hdIkUcmszou97huF0jhsiZ5qmQSmFc47tdrNGWhUXw+l0Wl0aFu/9WYyttaa1DfevrhBZoLRmXmYEpalhbTkDCHzwa+TVTNPYVYqc140QyXa7LdsnCYQszabb2CljDSEGQixRUYsrzgdSaU7FdQuGDGGVNLfds7FGXdeScoksEmtDqWlb2q5jHEekLI0QsmCZZrRUL/6HvFKpVCqVSuU5qI2ESqVSqVQqlUql8rzs9jumaeDq/v0i5hVFPJxSxFqNcws5ZURKzCGU4rZbMMZgbcuHPvS7bHcbdtstx9ORtmtWSbBfJ9g3OOfOEmDbNAipPmqSOzBNcymIr0Vk79x5+0BJSYoBH4qU2S0lYz8jmMaJdhXhTtPE6XjC+4gxmmksETJd17EsC9aWArOQArcsbDZbEKW+HGJgHIciiG5aQvB0fYsQcOfOHZZ5IeXM6XREaY1fZcp5zegv8mJNiAElFWsgPiH6ssmRBc55yPksOu66UmxOOTPNMzml9XsCKoS1IG5ou1X0myJWNiV+KEZs0xQRsVvQxjBPE/M0s99f0HWlSWCtXeXDmoNzGKOLsFgWofPNYS5xTCmvImW9PtcGgGE4gVjPFQIhBIwt8Ui30uYQAt6H0jgSGaVkiX4SomxNeE/TNMzzRFh9D7vdjuAjv/M7v3N2FNhY4qRCCKRUnA4A01j8GafTieDLBkZKRVQtKJscUpV4p2Ec8DHQdz1xcWRKg6ttWrzzpBjJxHMTyHlHSgEpYZndusnybOTR4ma0VozjgFa6yMHdglKCe+NIzpntdkvfdeVZ+IUYIvv9vrw/UmJZFtpuz3AcgHzefqhUKpVKpVJ5qVCjjSqVSqVSqVQqlcrzMk0TUpRi63a7Wye1JU3TEEKgaUpB3TR2LeBmcl59ADmy3W1XGbE4T633fcmnl1Lg3HKO0ymS4wapJDGEMtFPmXB3zpFSIuWE0sUfkHMuGwU5l3gd26C0IqXM4eYGqRXjOHF1/4bD4VjihqxBCMF2uwNYo4rKBsHiFrz37Pd72rZFK1Xy+YVASkEMkRQj/abHmlu/QqBpy7Wo1W+QEet5I9vNFq012pRtjaZtcYtjGIbzPYwxoo3Ge3eOXxKqXEdKZetBrEV0rRU5R6y1xY8gRHErKH0utE/TdL5/81Tim+a5NAWEoMQxhfKsyj0QWGtYf0OIJfYpxhINJVXZ+BiGE8uycP/+PZxbcOu2glKqNHjW80/TTAxpjSAKQC5bDBmcc2epcUyxvF4IOB/O33s43LC4ha5reeSRR1BK4Naf3bYtXdfR9z3GGJqmwXvP4XBASFkig5RmcZ6YEvO8oER5X7ngOZ5OjOMEt880FfHz8Xgg5cyyLMj158QQzjFUiBJ/pZRaX0PBKqx+6KGH2O8v0EpzeeeyfP/qeZjmCR9KI8poUz4PUp4bQ2K9/hD9ubFSqVQqlUql8lKiNhIqlUqlUqlUKpXK83I6nfDec3F5SQyBxlqcc0ApSOec1ilzU6bVTUNrW7Qq09kXF/tSaF4nykuRtkydb7YbYozM80RMJXLotkCttTlnzpfIoxnnPZmM1mViP6ciWDbG0rUddi0qa20Yx5EUSyF5GCakLIX22yz/tm3ZbLZ47zDG0LYdMUaCD1hbJMA+hFWkW6TBYd0ssKZBIM9ugiI5DtimQWm9Fv5LsVnrkrvfti1KK5ZlYV6WUtSXJYaouCVKs6V8j0EpzTgOBO9p182LeZ7Xe57XaKgy1T6OA0opckrM04T3/iwrTmtTB0GJPlqlEEJKYoprbFEocT6wRv54Fuew1pByET0LITkcDty/f5/T6cQ8l62TzWaLtRalNEobhmFYp/cN+/3+HP2kTdlmiDGxLI5MZpwmtCnXmmMurgEpmefiz9jttuwv97Rdi5ISqcr7Z7PZrHFY5Zqcd4zTWDZR1qbSsjjGcTo3Y4Qs3oKcM8M04GMp2O+2u+LrWDdUbn0g+93u3GCKKbHfXyCFXBtkmWVxtG2HNQ3GWNquOz/fmBJt29H1fYm8GkeGYVgjnwyn0+n8es4tTNPMvJRGWdu1L+Knu1KpVCqVSuX5qdFGlUqlUvms5rf+0Ct+7x/0X4j4gi9DffUb6J94nIv9gznX83H/La9geHNK9BEAACAASURBVDvAm9n88+/g7oM+0IvJh36KDz727SRA/s1f5hVf/eiDPlGl8lnBbrcjxoBznpTiKkGWJU9fKtyylIx5Sr48ApTRZBJSlcL4brvFzQ7W+Bf5UZPjTSvPhfgQAzEEuq4n50TX9yUv33uMtauguEy3e+8xxp5jiqy16zS5IoQSLeSdAyRKKZqmZQiBeZ7p+55pmtBaMwwnur683m1MkPfFBxBTidqZppndbn+OEAoxYawmBI82Zp3ejzhXGh277Z5N2qKkKmczFhkjbdfh3ELflzilZs3qF0Ku0ufMPM3YxuC9Z14WdIgMpwGtFPvdltNwom07xmkixSKftsYSQkToIiXOuUiNm7Y0TXLKNE3ZsIgplRgka/A+o6Q6y4zN6iEIoWwutG3zURsZxbsQY6TrepZlRkiNW5ZVcK3QQbE4V6KCQlyfGThX7lNOmSKsFozjSIiB7XaLVHKNo8r0XY9SBu/8uhGR0MpwcdHSWMswjOXeNe3aWMlYY7HGsN1sMdZgjS3uBAlCQIiCcBxACLquw3uPWxxLWmhXcXjfbxinEaMNUkqGcSpeBzIxJWQvEaI0c3a7HSGMHA43xbWhNSmV9+PxeCgfnMy6vaPp2h6tFf2mZxpnUopkUe7nOI5rrFdmcQ6lXlozf/Nvv5fDz/xf+Hf8EumfvXf900fhVV+I/Lf/Y5o3/Yfsv2CPfaCn/PTn+JN/gevvfgcA5h98kJd92YM8wxto3v12Hn3Zi3+G5+SXvp/f+pq3PP/Xvey1iC95Nearv5HdV3we/cfRjjzX9b7U/779yb9f3suH/tBX4gH+wk/zb7z5S1/Q873U71+lUvnEeWn97aRSqVQqlQfN+Ovkf/bjhP/+6zk89kZ+9+cPhAd9pkqlUnkJoLRis9kQY8myL1PVmr4r0TICgdKKuIqHhRLYxqCNKVP8a2Og7Vqapi0T+DnjnCtT8zljrC1/norgFgFpbSSoNT4IQCDW2CQQQmGtRUrJNI3M88zNzQ3LUjYamqYIeqUU9H1PShGlFFLKMnG/zGVrQGuCd0gpisC3aUpRX4D3DucdIQb6TV98CM6t7oTMvMzM00QIvoioUynsZ8DatvgSfGBeFqa55OlLVbYhintZlnsooOvaUqhPCeeWsyshAzfX1wTnuNjt16ZBYJkXrq6v8N6vDRe/OgZK80YpRWNt2d7oezabTYmNkoLj4Yj3ASkUIMkJNpvtOfboNm4nrRsft3FTd+7coe9LE0HKZ30UAMZo2rahaxu00WWzwfl18r5k/6eUAMFmuyXGWJ6tW8gpgsh475iXmRgCIfjiycggpaJrW7r21r2QmaaZcZpKAyqEIlhuGsQaK1WaKWW7RAqFMZboI8EFtCqbEc45bm5uCLHEU7FGL6WU8MEzTTPLUrY7jocjMYZVzh3L+1GWLZLbM4RV3qykKnFbUtD3HVJKHnn0UR5+5BFOp+P5GUklSClitOHy8hIpFdO8vNgf8Y9N/ADPfM8beebf+0qWt/zQRzURAJ6G97+H9GPfxfT6V/Hhb/wRrg4P7KSVyu/lQ+8h/9wP4b75y7n3Z9/CR5550Aeq/OsSDr/O09/zI9x/0AepVCp1I6FSqVQqn930P/K//57fp9/8FcLP/zjhqV+H8T2Eb/o67j3503zOqx7QASuVSuUlgpYa51zxAaxC4HlZaKwt7oSuNAvmeWbTb5AioU3558YwDLjFcXl5F0TJox+GoQibo0BQopNs0xQhbcqM04gAGtuSY9lASCGghMRojZCsU/yCw+FQCtJaE0JArrn0UHwLSgoEAiElx+NxFQVbnF9IORG8R63F4CKJdljbrlsNJfu/7zsW53HLsjYmyiS5NYaUElIUYW+/2Zyv53Q60nc9w+lU/AIpIhDIKM+NgBjC+jOLG6HvO4y1a/xPLJ4EIdamiUDrUpxu257FLWTAmCKuLs2AhWmamOeJvt8glUIbwzCUCJ2+77m6fx+p5Fk+bY1FCkGIRYYcY2m2GGMw1tA0Zn32Eu893mvIgmXxtG1p/NjGoo0pz6wp2yopZUyzSpUpDaAYE5CR6wZE2fBIWNusz07S9xuWeaHZtGsEUnEMdF3P4XDk4kKW2CRrAUnfdiUmKge22x03hxuUlKVhpUusVEolLinFtF5biUKSsjR1+n6Dj6FsZFiLcwvDOJ4bJALB3bsPAeDdgta6bIooVe6xUoRYtjbiulHT78v2ym1c1Wk4orTimaefQUiBMYbhNND1bYlA6jqU1sQU2fSbF+eD/VzED/D0t/4ZlqeeLr+/8zjqz/776C//QpQFuCH8/Hvw//BHyFfAu7+H0587kH/qO7jbP8BzVz5rEH/+7XRfcfEx/ssN4Zd+ifCTP0X60NPw/u9n+rpLrt/xLVx+nM2EykuT8am/yr2/9EMwvhn91x/0aSqVSm0kVCqVSuWzmocee+3v/YPHXgv/+bcw/uPv5/7XvYXMe3F/5x0M/8sbeAn8k75SqVQeGCFE5rlIdR956G7J7/eB4XTiYn9RpL2wFrQhxCIknueFnBJal2K2VBLnFk7H4xq5o9ZCeTzLerWxqKUUwCVynUgvmw6ZvBaeW4bTgHOO4/FQsuulZByGMjkvZImPyaVonVPG324/wNpsmEsEEKXp0TYtXdcX2fMaoeS9p+tKkdfa9iySTilydXWfRx55hK5tadqW0/FESvl8v5QSODczjgONbZldkfTGGLi8vMswnDBGc+fOZRH9hsCyzEDZkNDaIKUgpUzTNpASWQic9wgp0NqUjQnnMKY5S3+PxyNpdU0YYxjHgXEcuLAWIUp8kMxlk0NpxeIm7lzexXmH0pZhGChi5PL9m+2OZXHneKNpnD4qSsjilqVsZ+QMuUzoj8NE27ZYa1cJteJ0GlbBcmmSxBDYbDZFzizFurXSsd3ucc5jtMF7x/3794svQxlOpwEQDNNEj2C/v8B7xzSN7Pc7lJTPbqJoXRpdEkLwgHj22ZJRWq2S7YaLO5ccDwcQEFMkA9M8EZxHSgVkttsd3i+0rSWlzHAaiDEiRWkKCCmLiFkq+r5HqeJKyGuzyjnPM08/g5TiLB9Psfzce9NHyoZHjDTWlk2VB8zwcz90biKIN/0ol9/zONvfX4R97A3w3W/m3t/6Osa3vxd+4y0Mb/lS+v/xtVTLQ+VTjfjDX8ZDj32ciMvH3gD/1V/6qPfmX2V8x9dy+cTvzS3dffXb2X31i3DYlyRfysv++Qcf9CGek3j/t2B80KeoVCq31GijSqVSqVQ+Bv0f/0aaP73+5mfew1hX9SuVymc5xpRYmW3fF+mvkLBKcZ0vRVqlNI1t2G73aKnxLqxF1Q137twl5cTNzTUfeeYZEIJ5Xggh4n0gZ4GSihgjOZVYHbFOyQfvaRqL1RolBM0qHVZr3vx+Fdp4F0rRvWnJGZQqTYoSR1OEwm1bBMoxprWIXNwJ1licL3FFtyLiGCPb7YZ+0yOkQq1T/CE4tNZICdM0kSlRON475nliGE6rpLncl7I94HDeF5lxZi0wZ/b7C07DqfycDCEkpmmi7zqMKZ4DKQU5RaRSICTTPCFEiREqzYOWZV7WLH/WsylSKtc5TwvGNnjn+MgzT6+xPIm0OhSULK4LKEJmrddtBFN8E8Mw4H0oMT3idivB03U98zyVhsQqJA4xrIX4vBblE9xKoUVGK4U2mocffhgETOOEFIpldgQfaZsW5xakgJj8OQJKCskwnrBtEVn3fYf3rhTpY+Dy8gJrLdM80TR2jYeKNG1L15XNjLZtSsMiBvp+QwyJnDLGGO7fu8/xdMQ5xzAMSCkhQ9f3GGu4uLhASrHGU03MaySWsZbNpkQ0jePIMs/nZkWKkXmamKYZrc26UaJLVFXO5y0at3i8DwzjTAwR5z0311cP5HP+LE8z/NSPlF++8nvZfKwmwi1qz0Pf9Vaar1h//2M/yM1vvhhnrFSeB7XnoW/+L7l968anfqnWpCuVSuWToDYSKpVKpVL5mOxRr7z99dPk+q+OSqXyWc7l5QVKClIIWGNJa7Z8Sol5Lln5t3n3KUaCD0Qfib7E8xwON6S1gL3ZbFGqFPC1Ljn1pRA7nIvUOSViiCgpSSkAuRS4tSKnBKlsGkgBeW0+SCnZ7y9o2x4hQCrFMAznaJ1bOa8xRaRrTYPWJZqo7Vrarj0XhDNgrMFYW2KQ3MLpdDhP5Ssl2W53hOCIMTCtMTgl6iiScy5F5HHCB08iY4zFNg05i7PHQEpZ3AcxstluQYj1axK2Kee8zflvmoacYZ6X8zUopYrXYC3kpxhpmob9fk/f9+dYn9ttj3meSCkyTyNaKZbF0bQt0+p4cMtSIpdixFpL1/fINaZIIMt2Ry7z8qWxAhlIuWx8IATjOND3HTFGpnHi5uZAjIH9fkfX91zsL7G2FPulkByPJ+Z5QWnN8TSUrRHBOVKqbdtzHNV+vwdyuTZjGKcBpVRpNkhJYxuULpLqcRzp2o6262i6dt1AEGuTpCGtsUnA+v5MQGmmFKF3whjDbren32w5HA547/nIMx/h/r17xBDZbXcYY4rLYRzIOSGVxDYNxlq0NhwPR47HE+TS5Nnt96SUz9s4w2kgZ0EGvPecjkcOxwc9wfBbpKfWX/7xL6R7vjgY9Xns3/Qt62+eIvzy05/Cs1UqnwB3PufZwtfhhvggz1KpVCqf5tRoo0qlUqlUPg75bFl+FPEcWb/DbzzF6e+/A/+P30P+jQ+sf/p5iD/yauQbvpbNf/r4/8/eu8fYcZ5nnr+6386lL2KTtmXaWJoONEsFTkgBNkiAA2rXHrWXmjBRbHFlOZRtWXYgKzJCmIY1Q0PMMJjO0hgPzV1LoWMz8mopOVq1xhq31opFmAs2LEBkJAyZFSKaQEIxMdlN9ulzqftXVfvHV3146+ZFJCWNXQ8goHTOqTpfffU1z/u97/s8D83GwucD9A6O0/v+XsQrk1JnmKUoa9ah/y+/T23DyoW7ABdAdPhxztyzjTwAlm3C/qvtLCoLIzNj78PfDdz/Y96/ZSXB6xN0vvMY6YulgeKS1ajrN+F9eZSBy4w7OnGIzjPPkr40Sf760fLVEbhlOeqajTh/tIGhJZe+hugcZ/bpx4l/fM41lqxGvX0D1mc/ycCyxtUFLNlxph95kOiZQ8AI6uYfMvylFZXEQoUK14hut0OSJuimQRAE5KUevPRBkPI7Q4PDiFSa4zqOQ5okaLo0ChYiRTd0FGQnvamafUNkRVGwbJtur0O9VidJZHe8EIJeFKKikCaSlTDXsa9pOl2/h2VbzMy0GL5pEUVelGa5BZqmk2XSc0BVpHdCmqZS2z4KAQXTNDFNg7yQRYyBwUFMw8AwDADq9Xo/qWyZJmmSlLr6KlCgGzIZniYpeVGyM5KknzD2ajUyIeWdFIXSBBiESPrzqvS713PCNCAVKY5tEWe5NGMu8pKZIOWi0jRF03SiSEogOY5Lt9NFU1VEKcWkKAq27RBFEVmWUqvXZZJcUUrza5MwCMny0hi79JlwPQej9G5wHBdFUSjyAlEUWJZFnhelUTKyyOBIP4m+rJFSkAlZyDBNi8BvyTmJE0xzQF7XdfH9HqqmkuUZumFgFlJmaC6xbzsDcl7Le5nzKUhiWbiikN8/NDQoZa8UaLdnZWFJVcoiiIVpSZZJFgq8Wo0ik2tA0w06nTYooOsGYRigKnI9zPluqKoqWRypZAsUyHWnG3ppiKySZTlhFBJHEUVRMLJ4Ma2ZGaIo6jNhbMfBdT25hiyTNE1lwcMy0VSNbqeN7TiYlgGFLM64noNlm2/Xn/YCsMBFSor8wyliuOzvqP1bt6IyQn7LcorWFDC/5MxbjZu6z9zP7NcngC14v3yIoQXG0Y9zLvW5bIqZ8acIn/zZWQPpwZWoaz+JcfcGBlaNsOATyKaYGR8n+q8/ITtw/rnm5zcyeMtVxi03CNcjPgVITk7S2rGHdP+EjFHLGM3+8kaGLxXjZR1aE3sJ/++XyP5uUq4ldznK765+y/HtW0LGWamwRpMLv/LsuhrFOrCbkcvErefiUvH2uegdHKf31ARibg7n4vw/2ERjdDnuO+bbcIiTH7qTFPr7gouQdWjvfxb/iWfPrvdlo2h3baLxudXUXt3Jm3ePcSXzl5ycpPXdcdKJvXIe3OUoa34f83N3X/Q3d/a5zGEM/0Nj+Jcaa4UKFW443g2/bxUqVKhQocK7D8Ehkr8tjz87Sn2+jVZwhFN/fD/JgePzvHmc4vBxssMTdL6zmvD7P2TJKuuiT4nOEc588V6Sgxd27h2nOLCH9MAeWrs3ES6wMZkP0Rt7r2hTA9B9bjOzm/ee/+LJSfLdk3SfXE34ne+xaO08G+LsONNbNxM9PTnPVafg9Sny1yfxd/8F0Y6nGfm9pfMGHZ3nH6Hz1T0Xa0GfnCR/cpLwyb8gvppCQNbh9PaqiFChwo1AGEaYhommaURRhK7pOI4LqjT+TdMUBfqyLqZuEkchpmai6XppOCthWqbUyM+yUgvfxPM88kyUHe9S1ihNUvxuj8HmYGnUm5HlOZZlSe+FQsH3AzTdQNVUHNchjmM81yNNUwzDZHBoGAqFo2+8QRxHZFmGoiClbTJBmibUajVElmKVXfIDA4OkqUxaZ0IgKPDcGkIIgjDAD3x0TcMwTVRNJ8sElmXj97rkhVFKC6kIkSNEiqoqBEFAo9lEpIJaTRYqFEUtfQp0gk5XmgzHMXleSL380ty4VtMxDKMsIkiPhSjKcBwPy7Y5c3pGdsAbBlEUoWlan9mh6QpZLrAthySR50uvgdNkWc7g4GCZIC/ZD7k0PpZeCAEoMmGe54VkRqQpeSk9NWeOLAs7UrJIejNIr4AkTcprqeXYLZI4RlFVkjgmCkNcp9a/z1ZrFtOU4+h0OhilebbrugRBICWeigJd0xFCrh+AoJQiiiLp3aDrOvV6A03XJVPFMHBdl85sS7JdCKjV6hSFXK9hFEm5LO2sKXMmMlzHpT07K6WrUjluXdewTAfTsum0O/S6XYqiwCgLTZ7nkRcFRWmOnWUZQ8PDBOWasSwL27aJY2lK3ul0UORiIE5iBmuDGIbel+t657AcfQOkTwKH/4LeY7di3L/i0gnPJRt43y83LPz+dYibrgeC1x6n9dkyTjoXrUPkzx0ifm4bU3f9kOb2ddQvuN/ojb3M3LOZ7ELlqfLc6LnHOPnpb9HcdvG5bxuu4zwXB3YytW3sfGZuGaMFT+4kfvQJhu5ZfnGcFRzi5Ke/QPr6BfFtcJTiwFEZ345tJBjfwcgVxrdvFdErP0OWIkfQ/2A118sH/Iri7eAop7Z8luSFC5/F2Tj/zF8+gP/drVcc57+tWOg5HpsgG5ug9cxDRA9eyYVCxAuPMPWVC2L+4CjFi2PEL/6AqQe/x00Pr6xi9goV3uWopI0qVKhQoUKFcyDiDp2De/nVp7+AOAG4G7C+OJ9h4BRTD99bbtJGUD69A2f8Fwy/8jrDr7xK46ndmOtLI+dgknTzHloXcqnjI5z+w0+URYQRlPXbseeu8dJPsR8elZ87tofo8zuZia9g/CfGOXPX5isqIrDvUdqb94K7Gv3RH9E48DrDB36O++gDkoERTCI+/xlOv3bhF8fMfOfBs0WENVuxn/o5g6+8zvArr9Mc/yHW/eXYOU62eSeteaSeu889SHuuiDA4ivEfyzG88iqNPTvQbxkBpsh33MuZ565EIiFmZsdnCJ+oiggVKtwIWJaUlVFVlTiJSURCTo6hmeRCSgtpqirNbRXI80xK+hQFfhBQFAqmbZd+Aindbg+zTKqqqkqWy4Sx7PQWCCHQDVmASEVCGIeEZRd+URQ4joOuawghsG2bmZkZ4jjB7wUoqoqCShRGtFuzTE9NoevSq8GyTLxaDd3QaTQaWKUhsOx6L2RHuOugGzpBEBCEIYEfkpZJc9mln0smgWGiKopkC6Qpui4lc3w/IElSVE1BVRXq9TpDQ4PSvNjUSRJBt+sTJzGB75MkkinheR627ZTySyZZJhkDsighUChIkhjP89A0XSbz0xTD1MlzgRAplm1hWgampZPlAlVVoJDsDk3XUFBIhaDRaGAYBr7vE0Vx6UFhoqoaNc8jy3LiOOnL74RBiEhF39shjmPiOMIqPQ2MUu7KdmzqjYZkH9jScFgaC0tGRa/nS+NjRcGybGky3euiaBqaKqWT9PLeNF36bBiGQRzHcixlQSlJ4r7vhWEa5xUCTNMiiiPiKCJNBH4voNPukCQpigKOI8fsuA6qqqJqGkFYSlOV15rzyqg3mti2Ldk3moaqaoRRTLfTochzmfAvP6tqcj0KkWGYJrbjlDJQBYYu70HTVKIgIIpC4kRKVCWp9NdwHReRpmQiozPbfmf/4LEYuHurLHIwRb7jE5z56L38y7fHOXNsiuiq9WGuQ9x0HRC9tpOZu8rkr7sabctuai/NxS+7MdYsBaB45l7a3zlCdM65czFWVnaUq/fvwrvo3CmKp++lvePQeee+fbie8zxB8vUximAp6sNz8/QLav9pK+ogwHGyb36KmRculOGaYurhMvnsrkZ/9If9OT4vvm3tJf7848zeIK2hqHOcmSe3cfqLO+UL67ZTW3N9ilNXFG9nx5l6+FNniwhrtmA9NU+c//rjMs5/t8moZsc59dk7yyKCXEvuT1+V6/2pXXK9H9tJ+NWdV3CxncRf2UNxXrx/7lqaotj1BVoHzu45nPXfYviV16lvndtTPIRT7jWGv1KxESpUeKdQMRIqVKhQocJvNN780PsWfnPNVtz/7QGGF138ljg8TrxPJreV+7/HTVvO7aBpwKpRmqtu58xNdxL84AiceJbkjQfglrPX6DwzRnoMYAR1+39h0aeXnqX0Dq7AfXA33SUPMvv1cTg2RvTiJli/cIeiODHOqdEHr6yIAHDsEIW7Aev5XYx84OzY3Xu2kqy5len1D5IHh0j/w7N0ntlI/5tbLxHtKqnN63Yx8N0N53fdDa6jces6uh+8n9lHJoC9pC9vhTvOGXs8SW/ruDxetgX3bx5iuP92A9ZspPm7H+bkhjtJj02Rf3uc1voHGFywuy9mZuwP8XdXRYQKFW4UZBIdFKSWe70pNfiDrl/6DUjZFpAyEqZlYtsOBQVBELC40ehL0szOzmIYJgpSaieOIjRVK6WBUpIkRlFUNM0CCpI0oSgAVYVCFixs20EppWnyvMDv+aSJIElSBgcHSVPR17SP45hGo4HneX2vAcu2yDJB3alJA9xAI45lYlfTVOr1On7PJ45iDNMk8H0KpKyPZdtYli0ZC1mG53l0u13qjQZpkmLbNkmS9JP+qqqh6Q55WSCJ44iiUIjCEJGmRFGMaZoYpoHj2KU0lFfOg5SNyosC09BxSgPptJSQMk0TVVXodHq4rtvv6E/TFNu2sEwTkWUYpoWhG33tf9d1yYuC2VYLTdNICrAMKb2k6zq+72NZNmEQ9AsoqqqS5xm27SCEKO8xLYsesqCTCUGv1yVNpKl0ksQMDw/R6bTRdJ0oDFEU6dkQhTEosWSUlPJWc4bEpmVKbwddk5JMui5ZH34PFECBNBMoqoph6JyenqbRaJTFHKPPEmi32ohSIknVFBqNJlme4fs+nudhWnPyRUlZBBAYptn3R8iLlAIIw4CbFo2QZ5Jx0Wm3sSwTRVWwbRvbdggCmQmM40jKYxVgzxl/67pc63HMksWLOTNzmiLLGBoc5F9O/goFBddz6XTaeLUaQRi+/X/kF0C/5QGa3zlOe66LuLWPbNc+gl0QMAK33I5+52rMdbfjfbCBfYkO/OsRN107jtP+D2PyXi6Kf4DBURp/tYKpL/9b4n1TFLv20P2jHdhl0vzMw2WMxUqMp/7m/E7+wVEae25n9ok/pbttnGL3F2h99GXes/bGsCoWwvWf5wvvtYG7/gHqa1dx+g9ljJZt+S5n1m1heO4jJyZJyzFo3/4h71l37jyV8e2iMkY89hjRqw/Aqrd2v/nXf4c3v365Ty1FfXgXzS+vpPbWvuY8XGm83XnqkXOexY/PfxblPEQf3ysLEsfG8MdW4j46X/PSO4Pu+J+RvAbz7lNWbaDxV7dzZsdnCHYfurILzhPvu+sfoP6vGpz8xGYKphB/e5BojZwD3WqgW5D1KSQO6mDjujFKKlSo8Nbwrisk/Jv1n3qnh1ChQoUKFW4g/p/nf/ROD+HK8fcHSV9eRzCPdmk0PYt662ryY0uxvrgQDddi+BOflBs1jlD457yVHSHcXboYfuRr1M8Nzs9BfcOfEDx1hDRbDsEpEhrzfk6c2MfU56+iiFBC2/7n52+iS5gf2EBt87N0tu2D1/YQvr6RRrnJTE62KW5djXKijfGVDQtS9+trR+kwQQ4UfgRnSxH4L44jAoAR9H//wDmbinPgrmRgyyamx46iLIvJp4F5dVdjWo99oSoiVKhwgxFFYd+YGGSCFGSne1FI2Ru35mJZFkqukIgU0zYxTYskSWUXOrIgMWfMrCqS3WBZMhkuvQuk3E+r1ULTFNlprkspGyEyDN1A1zSyPKfXC0BRUMio1epkIsO2NLrdDnrpKzBnxDvXrW5ZFnGS4JbeAEkifRQajUY/QR+UxsmWbdNsNEhFSlEUfQPioiigKNB1gyRJcBwHVVMJg6DfxR9FYekhkKKqGXmeyQR4AYYhPQpc18Ewpd+B4zpSRklk/evKuVLRdZ04jnEcl9bMDCANgaWEkoYQOYZhkqaCel0WAZIkxTKNvg9CkqZyDBRSWihN5TxpUjZJejVYhFFAEATU63I+hRDkeYZl2TLBbw6RlvJGQoi+CbIQgiiOybIUwzBwPZcojLFsm17Xl2snkx4LRV6ANmcqLT0JMiHQdR3HkcUC09Il6yXP+8WOuaJSKgRJHNNoNFGANEmlzJSq4fs9NE0WpbqdDqqqYJgGiqrg1TziSDIqXFf6O2SZNMY2DGmoPWcCPccUmJ6awjANQLI/5HOwMU0Du2SzXRV3AQAAIABJREFU+L0AkaakSUKBlF7yfR+jNH2uN+qoiopIBZom/Sgs06TX6+HYmfTlMKVvg2GYxFFMvV5/u//E50X9ju1YB0aZ2foI6b6j57wzBa/vRby+FzEGgbsc9Z6vLeivdM1x03WAOPxCmRgFZcvX5o1/0JYytPlPOPn/TcCHLIqTMQxaiIPPnT136y5umlcOyGLgnq8R/3ic5LUpxBMTdNdu4O18ktd7nhe6V72xkoFvPMD05x+HYCfxvi+fbRg5+WZZcl2Btmj+Qkr9jo10d5wiv3kxRB3OjRGvP46TH5wkfGM59jX6V1xxvJ0dIhibi/N3UN88/7OwP7yR2uYJGW8/uYfOl1djX4VHw43DEYJdpT/B2q005tunaA2GH/4m6Qt3kp643PUWjvf1ZbdjroV4P/DfjhPz7immVKhQ4WK86woJFSpUqFChwtsJd88FhY3WcdKDk6Tj49CaIP3qBDOTPyS7QCe3tm4LtXVX8AWDi+byRufjHw/3g2717tsX3j5py1n8zM8v+RXF9CTTn7+X7BhXVUSABzA/vvDGrfnx36e3bR85R0hfOQ63SLq/ectG3je+8fKXHxxBhXIzeS5iwoOlL4N7H9bHFu7Ws9dt5/2XnOc2s09so7djH1URoUKFGwvLdhAiRWRScigVKWouO9XnNPlFllG3LJIEVFUhiWXCW8r5xESlR0Gt3iQMpOFxUeTkuZSxmUvkKyjkWY6iqAwODdHuSOkMQ9fRNV2aPhsGBVBzPVRNRUEhSeKyQ96g1+1JBkImyEQGKPh+j+HhmzANgyzLCIIA2zaIopBms0kYhiiqVjIGCkSvh2Pb2LZNt9MhiiPqjQZ5lpMhmQ1CpIRRiKbKH4k8l0l9y3JkR3ue93X3JRR0Q0U3DDRdxy3ZDEVBP9lvWhaWatHpdBgaGgJksj0KA+YKAY7jlKyITBZ1CvryPJqmE0c9rLmufk1Fy1SyLGNwaIhezycMA+IowqjVsWybKIykfJKikKRCygsZsuAgiyEauq7L+ymKvvyU53lEUdQvJmQiw3Yc0tKPIQljUs3AVA3SVCbu8wKiKEbTNDzXo9vrSYkqR5o9x3GIgo6iqFImq8gJQ+n9kBdFyVSQrIM0TXFdlwGzSVTKLs1JQc0xRnRdFiFMSybpez2fkZFFZ8dT3lOj0UQ3DDzXw/e7BH5AvVEjy/J+0UlRFXq9rmQcKBAEPqIsMEVRSJ4XeF6NKIoYHhqWxuR5gcgT8iJDQyeJY/Iip8hz0jhB01TCMCjPS+QaT5KL/gbfKZhLVrPkL39OEhzHf2mSeP8E6Yv7pHnuHIKj5LvvX9Bf6ZrjpusA/9WXyqNRzNuXLvg5/cObuPnApvNe6x38ydlz183v+wSAthT7ztUkr03C/pcIpzdQn4fZeqNwfed5FPPjC9+rveaT6DyOALKXDxPdUSaAb35/Gf8dIdn8CFM7ttD4VxcwVhrreO8rVzLQS0O5bzfO2ua87+X/dASxfy9i31E4MEZ04GdMfWcXI3dc4vldAlcVb79xkLT8+1D/cDXNS7B1mqtH6bKPggnSl6fg9+Y3KX9bcezsPkW76/aFi2HWSuy7V5DuOHKZC46i//ZC8f4I+ofLQsLhaW6Q0lWFChWuE6pCQoUKFSpU+I3G8JrVF7yyGtZvhC1/wqmHP0Wyb4rimXvprHqV+l2XD+xF3CFpnSL65VHS/ZOIFybm3aRFJ472X9c+eC0bhp8RfmaM4lj5v3EDdegKT117K9alGPdLlqIhCwHFsTeJWHrpBH0WE3ROEf/9L0lfP0D6zAvzFBEATpH9t/LwtvdjXIMZYb77T+kem6NUT8HgtXWaVahQYWFoqkzWZ2pGsyFljZI0wbCklI7lWERRBBTYtl36CwTSTFjTyIscVVGxXCkB49g2cRKRpqnU2Y8lMyHLcnTdYGBggCRJCMOYXtdHVWQi3rTy0tQ3R5Hi9KUhr42my272JJFyR5qmYlsOQSa71E3TotfrYlk2aZqWXf8FhqFJ3f8kkR3ktRqaptHt9uh0uwwMDJDnOa7rIVJRmgeL0vuBstNeSjhpqlp2q1tEcSyT65lA1VRURUHXTQxdJ7cMRCb63fGGrqFpGopjU+Q5ju1QlEWIJIn7ifEojFg8soQwCvF7XTTdIAwjCqAooNvpkaaCLMuxTZs4jvF7PnmO7JbXpSm263rouo5IBZkQ1Go1gsAHRXpQKLqUXjJLmR/TNFFUFZEkxJEsCHm1OrOzrb5p9JxfQRqnBIHPwMAAQkg2gKZqzPZmy+5/A0PXCcIAFKjX63R7XbJUEOcFIsnQaxatXhtFUXBcl6KISkaJja7p6LpOmibSzwDIc8kEME0LVVWxbSkRJQsAKa7rEfoBti3Nn7M8I8sl46I5MEiv2yVJEvIiR9c1bMcui1wFQmRYtoVVmlCnuiZZNmmGrptEYa800x7AKGWa6rUalmng9zJQFWo1l5rnMjs7SyIEiiLXjGlp5GmOZVplEaL0VVBuRCr92mC6SzHXL5VxEhCdPErwykHiF/YiXix/i+f8lS6U/lkAVxo3XTti0mOltxO3ol9V1/cUyd/NJUo/hOp1CObxfpqDvmQFMAmMk//TLngbCwkL4a3N82XmSXs/2loQ+4FjU6Qg48Qlo1j3jBA+OQXH9hBv2MO0uxz143egr/0kztrluA3rusRrym+tYnjNAnH0mtVwzwPSFPmuzeTBIbKv/BkzB3YzctVd/1cXb/f+4XD/WF00QNC60EfiHDQWowECyP/hTeCdLyQEbxwp18cKtA9emi1S+8g6ulyukLAY7Z32j69QocJ1wbtur/3fleRFhQoVKlT49YW7nMVj2/mX2+4nA/Jd48ze9QADF3wsOXmI2ed/QjpxkPzwFWqEAun0m+XRKOoVsQcWwiG5qXFHIJiCEzsJ/tP/hPfIQnT2c/DhpZeh278fdS2wHzhxzgaxhOgcZ/b5vSR/e4js7ybP70y8JKYp5vZXlx3DZXBMyhnhTkEA+SN/xszq3Yxc05xWqFBhIfh+j2a9CRqkaUKRFziuA0ppNmwYRHGE67ilzr9Lz+/iui4aGiIVWLaDbdkymWwYzMycxrZthJAyREmZzLcsG1KF2dZs33fAMEyESCkoqNcbdDtdut0OqgKWodELfDrdNrpuYVkWtu0Qxym27ZAkCVEUYduWlGcqCoRI0TUpT5OmqTT7tUzCMOjLC8VxKBP8qioT9d0etm33TYdNyyJNUtkFn6bYNRdNk93/IpUd+3Ec4/td6vVGaQZskOUZClIaSlVVNE0jDCVLQ9M0Op02SSL1+R3blia/YYyqGbiOW3bjC7qdNmEYYztu3+DYdU00Te/r9otQoOlG3zS5AFRFJvftmk0mMizTJBUxRU7pj2CVngg5Xq1WmgCLUk5JRdflL4LjuIgsQynvQaQCxZTeF1meoagKrutKJopXo9frlqySlHq9hmFYJElMrVaDoiATGVmW0el0MU2rZHQUeDUP3/dxbAdddcmEIE1iUKSnQ6/Xw7IsPM/DME3iKJJrxjTpdbvSJLsoUDWNPI+IowzXc+j1eqRpgmlZ5fxLjwNVtRkYaHLyV6ekGbamYdtSfsowDNJYrktZWJKMGl1VqXkenW5HFouKHK/mlYUdyRxpNBp0u13CMMI0pfl4miZkuSxKoBR92ah3O+wly7HXL4f1G0laR5gd+wbxM4eAQ6T/8QJ/pRJvNW66drTJ5+RX1r4f42pP77dJ7yS8bSdX6mCRT99o2Z75cV3m+bLz1Dwbw778Jmn/dYubtv4XpsVmoqfL4k1wlPy5oyTP7SQB2ks2YDx8H7UNK6ldQ0PJlcD+8EYGth9i5qt7gQni547Al1Zc5VWuLt4uxFnTYPHFWzhzpV9zsk0A77gPQOZPlUdLUQYv/Vldd274eCpUqPDugXr5j1SoUKFChQq/oRhchT7Huj5xkOTkuW/GtHbfz6k1dxKPPX7BJm0pyq0b0bfswn30fGr8jRnnRqyJn2KvLzuYfvAoswfjS59zRYhggct0X9jGyTUfI/zmTrID5xYRRuCWUbT7dmD/H1vfhkBjBOXB7zH89FYUACaIt43TrXjRFSpcd6iKSs2rkZVSQWmSomqalNJRNTJRSCmdLOdXJ0+SpCmarlOrNXAcjzRJ0DSt7LaWXgmaqiHSFApQFJVOp0Ov26Pb7ZIkMUVWlMl/h26vh+/7tFotAj9kttVCZII8y4mimCiOac92yESByFLiOCKKQjqdFnEcy0KBplGr1aW5sqbRbDawHYcokv/YWZaFpmqyiAEYhsHgwCCe52FbFoEfYtuyU91xHLIsK/8TGKaBZdvkhUJrZpYwjGXXe5aTJAm27aCqCoqi0O11ybOsP6aCAk3TcF1PzmWWSf1+kZEmCb1eD13X+8lo3+8xOztbMjFq8jxNK+9Lek3EUUjP72E7LrVaXSbps6xM9kutf0VRqHk14ihCVdXSaFqjKKSslKLI8arlcVaOWVGkwfDca4Yu5XqESFFVKZgi5Xqk1E8URaRJgu041Gr1vs9GlmXE8ZykEiRxXBpUu9KXoJTNMgzJnPBKFkXX75JmglSIspjUBWQCPo4j4igiL6RZsmSImDiOC8jxCiEIAl8aO2sanleTifuiIIlj6VVRSjopqgooWJbdL/z0ul1qNWnSneU5tVoNQ9fp+T5CpDiOQ6fbxfd9dEPHMA183+fMmTPopR/FnCxWksSMLFmMqmoEQSANyHUd05jPEendC3NwBSPbd2GtLV94bZJo+txPvIviprcR0iPq7cQ7NM8XZr61pSza/iMW/eLnOI8+gLrsAimpk+OkX7+T1kc3M3VZff1rh/fRdWdj0leO0n0rF7lh8fY56LQraZ8KFSq8q/GuYyRUqFChQoUK7x6MoC+DeN/F73Sf+1N6Y6UJ2eAoxpaNWLetwlrUwD13M3XwzXkb9TVvjrY8ITvk3rKx2ijW+A7Zgb/1W/zLS/eSBYdIH3mcmR8/xNClVAUu2/U0Tf5yefg/LGWu3yh6bSftrzwuKc/uarSvbMJetwp7URPzXKr6yXH+ed7rWig3AyeAN47TZeVbZyXc9z1uenglNitJNv+E7o5DsG8bnedXU383aMxWqPBrhQJ9rmte08gLUDUNVYU4LpMpikLPD4iTBNuyyPOsTOZqpInsZvc8j9l2m14q0BQNTTWkF8DwEI7romk6WSa17ZNYlFJHGhTQbrdxHIc4Tuh2upIRUHatdzoddN3EtmWnfZJGhFFIHEvNeVVVeM973keeS2+EgoJaTXb2CyH6zIA8z3Bdj3a7DciOe13XiIKQNBXouobIBIZhlgwJ0b9GmqZAQZzEiEzQbA6QJHGfcVAUBUkSMzA4RKc9K02nhcAypaG0oagyke54RFFIlsmEe1EUpEJgOzZxFJUeByGmZaEoGq7r4vs+qioZHb7fw7JsHNclCHxqjTppKlkdKBCGoSyi2C5CZHi1mmQrhPI7VU0njiMsyyqLGjFZluG6LlEUEQQ+hmGg6zpFniPKYoptO2i6ihAptVodvxeQJCkJ0g8hiWPiOCYvJBsj13WKTOAHPs2BAXRDRzc0dN2gyJEeF0IWmmq1GkUBnbBHGEboNcmM8DwPgIGBAdrtdl9iSjJeTPLS1LvdnsX13H7BJE1Ter0uAwODKIoiDaeBbreDQoGqKKiqhmEYOLZLEseoSJ+OKMulFFYck6QpQ4ODHH/zuPwuVSVNE+aKFoZlEMUJWZb3Db81VSVNZEFD1VRUFWm2nRcMDg4xPT2FV6u93X/g52CK6UceJD74JkW8ifrPL2ZkzgttKc4do8T7J7hQ1uda46Zrh40yRwzYf273/FXio7sY+D/fXgPlq8F1nefLztM5LI/b5mcv2IuWY9+zFe7Ziog7BG8cIHxmH+nEXooW0NpL/PDKedkr1xWLFvflOt8a3mq8PYr18//+mLJn9ynH5XO6xD5FiCvl51SoUOHXARUjoUKFChUqVFgQU4hj871+hODb4/Lw5odw9+9myV3rGPzABZs0zg+uC/9s15L7wbOdWdk/TnEpzHz7Y7y5/lOc+ONxLlZYvRV9bnMyuI76tg3y+NgYwXePcMk+uFePckkrxxPH+11R6m+9vywQdOj+9VipmzqKNfEj3nv/KEPLRi7Wuz1HlaEIzh3JUtTfKQ9feZP0Uq1X0xP88213cmLD/Zw8cPHdq7/1/j6lfOC+P8dYBjBFvnUbUycv+niFChWuAV69TlZk5EWGbVmYhtnvto+iGEWV0jG6bmDoBrZlQQFxGNItZWqyLCeJYuIwwjQMkjhioNmgVvMQWU4cSakaaRIMaZpSq9WIY/mvVaPRII5jMpERxzFRFHFm5gxFAaYpO+TnzI913cB1HGpejXqjASi0WjMEYUCWZ6AgpYOKQkrWlN3xumGWhYEUXddIhSAVGVlRoKpgOzamZWEYOooCYSB1923LpNlslN3vNrpeFl0UBdf1qNebZdK/RhRKloWmaWWhxCTwQ5Ik7Wvy1+p1HMcBFOr1OmmSYhomKgqKqjKyeAlBEBKGIVEUUG/UcRwLFNnR7jjyX0fTspg6eYooioiiiExkeDWXggLf7xJF0kcgCAJURcXQdZqNJiiS55UkSTk3Me32LFmZLM+LAkVVSNMY6b5Av6Bimlb5zBTCMKDdbvcZFSALBLZjS/+HNKVeb6BpOlEUk4ocTdeJkwghUoIwRAhBt9fj5NSv0BSVwcEBLMvCNCx03UBVNabOnKEXBCRpiu8HRFFMGPooihxdlmXSRAIpR6UbOoZhoWsGp09P027PYpomgwMDWJaDrhnkWY7rujiuzcDQIFmRkWYCRZWsDyFk4Wim1cL1PGqNBl2/R5pKZoZlWYRRTJokJTNBLyWx8r4k2PBNw7Rn2zi2Q93zOD09jYJSmpG/UxhBW3SU4thxOPES8byx0ALo/6afK9147XHT+TiMWPA3vkM273sNjN+ak7O51PlyvCdv+9ec2PAp/vmZ48AI+q1lYvXlw8TXuQn9+uF6z/MpsktI+xMfJdtfHn/4bMPJQtCtBo1bR1n86A5ufvkXmAuyV24Apk9dY6f/1cXb9Q/dWh5NkB171y6YBXF2n3KE7B8vtQjAf+PtlCirUKHCO42qkFChQoUKFSoshNZBxBwb4eZVmHPdOJ0psrkOrHVrqC/Y0h/TfvGp/v/l0+2zb314FUZ5Xv7C5MIU6+wI6XPH4fVJCqt5WSphff3X+rICxa5vMPvaJTYvJ54lugQlu73v2bJzax36bWc7k/JXy8NV67Av0WHV2f9sv/Or+NW5O8QG9upReRj8hOTVhcfgv7yPvHWI4vBxlOHL9KpZKxh49KHyuuPEWyfeGnW9QoUK80LTVLqdNlmRS/PgvhSOgabpgEKeSWPgZqOJ3+sRBD55UZAkCUUhpYKiKJLSOlGEqqnYjoOqasy2WnS7PaIwotNpo2my41wIURYNQtkBnsTkeUYYSpkhXZtLUCtYlim77osCVVX7EjIKMnmd5xndXpc4llI7nudhGCaO4+C6HpZt4zpuadYr02JhGEmzXcvGdhys8vqeV2NwcAjTNKVPQpogMslKcFxXGiNHIZnIEEJKGAVBQJZJWaSikCXZPC/6CfgzZ84QJwm+75OmQsr6lJ4EruOiAI7rEsUxqqbieTUUVaE5MIBh6BRFThJHiCwjSVJQIM/zkikhpZsMwyg9KaTXRCpSHNchimMMwySOYzqdNnmWEcUxcZKUzAfZoa/rBrpukAlB4Ae4roehG5iGSRRFpfl0TpHLe3IcB9u2+zJOrufhOG7pNyAZK3mek8QxgS89IgxDp1arlUwIIU2zHVvKDBUFCgrdTodCUUjSFMOyUDUpCRWFkXwmpin9KSIp4TRXeJpbV3mWY+hScqgojZopCmkuXRSlpBHohkGv16MoIAgi4jimVq9TqzVQNR29ZG9IdoFkhximiet55HkumQ2aNNIGcB0HRVEwTZNFIyOYhonnSXNvkQmCIMT3g/Jv6p2Du+ru8miSZOwKJQOz4wR/U3bDX++46Ty0KfyFLnEY8dL8b9VWfbI8miA9sHAThzg8Sdo6SnF4EsWTXIyz8/E4yYuXTqzOPnYnb675FCc2PMipqynCXCuu+zzvId2/8L36L46XPSMj6KtX9GPUzovb+OcNn+LN23Yys9C60Zbi3jHaH8+N1vPxX953lo1w2/JrZpRcNt6+ZSV6Of/imZdYaLkCiNcf58Rvl4WrJ49e48iuEz68GrOM8bNnXrrkPiX6/uRC71aoUOHXEFUhoUKFChUqVJgP2XGmtjzS39co999xltbfaJ79Ad13gO4C3PDO89sIn1hgo6qtxNlcGjDs30bnmePMZ6vYHX+M5ATACPofrL68+Zq2lKFv7Cj9Ag6RbtnD7IKbsyOSkj3P+KPDj9PdVlZR1t9H7QNz74ygLCsPD+4jWkDXNnjtcbpj82hClaiPbio3WAuPgeAQ3V175fFHNuHcsuDl+rA/+jDOPWXRY98jdF+49Ga/QoUKV47WTItavUESJ1I7X1UQQpTmyNJMWNd1mvU6uRAMDQ0z0BwgCkMc20bXtLIQkPQNeh3PpVAUur1eP0Hd7fYI/Ihup0MQ+DSbzZIdoJed9g6eV6Ner0kZmUQaMyuKlFqyHRfP80iSpPRaSDBNU0rXlJ4AnufiulLWKAwDfD8gCHyEyAjDgCzLSrNhDRRphqvr0rzY7/lomk6aCsIwgEImwVMhyLNMzg1Qq9WxHYc8z1AUVXb8axppmjI720JRFDqdDkLI66SpkDJKmpQMyoSQMji6xuzsrDTgTRMMXafIC7rdLpquYZoyfRfFEZquEUVRyRbJyEsGwNDQEJ7noel6mUyXBQHLsjBMk9bsLHmeITJBGIaEUSgLPOW9FEVBo9nsJ7u9Wg0hMrJSumquKOJ6Hrqu9RP33W6XLBPSbLuUdtJUjThOmG21SyNlKROU5zn1egO99N2YYysoikKcpuRFgW1J0+m4lEhSVQU/8On1ujIh73oMDgzilEUX0zRLHweBEClCpERRRByH/cKCZNHoBGEgja0dp+RXSFKGECmuJ6WmDMMoJYgyTp+elsWiOJKFA9dD1zRQFFlQEgKRCYq8II6i0kC6g6qpUhYpitENjW6vRxiFpUxTDcd18DwPy3xnPRLsNfdhrZv7PX2Q2Yf3MHOJLn7ROcrUIw+SvAYwgvrwhusbNwHOB+e6vCdJnzl0Mesy63Dm22OIBa6v/87vYX5EHufbts2vzZ8dZ+Y7j8lj9yGsdbKJwf7YJzHL+Cd75BucemP+Jojo4E56Ow7ByUkKbTXOsnk/dmNwneb5XGSPfGPeeRInxpl9pIzRln0J52NntX30LCY/PAmtHxCOzx/fkh0nfGGeotMNQPJP54yVdZh3XK3R8jy4XLxtrcb545Xy+IVHmH3i6Pws4eAQpx/eRhEcpThsoa9Zfu1jux7QVuA+WBZ6FtynxMzs+Ea5T3k7cDkmUYUKFd4OVB4JFSpUqFDhNxpnDlzYRdNG7J8kfW6P1AQFWLYF965zTeJWYHx2hPSJKTixk+BzkD34+7j/42JUZolfPUT8xF+QHjgO7ggE82/Wmp/eQvjkPtJjU+Rf/7ecfPVrOJ+7HWfIJp85jP/9/0zydDm+dduprbmU4cFZ6Ms2Utu8V/oFHNtGb/dqal9aMf+P/rEx/LWHSbb+Ce6apejxKYLnHyca21t6IGzA2rIOr3/CCPa6dcT79wETxJ/fzKkHN+GsWYpORHrsINGTe0ienwRGwJ1iXhFedzW1bRuY3Tx+8RiYJT7wAsG2beQtgJUY/+73r1A71+Kmh7/Fv4zfSxZMkW0ZY/qj21k0eEUnV6hQ4RJQCtA0HduxZdI8D6k3mvh+l1rNQ9U0et0Opm4g0gzXcciLgoHGADMzMzIRb1n0fJ8syxGZwLJM3jx+At0w8Hs+lmVj6Ca+H6AoEQMDAwgh8H2fRrOJaZpYlkUcx2iajuvVECLHsmWnfVgmg13HwVYcRCoQZdd7mqYYhonrOv0EsTTnldeK44jmwABxFGOWSVxNU9FyDcd18XsBeV4QxyGu65YSRALX8zBMk8D3pTSSbhDHMY7rYhUQRVE/mW2ZJmkqiy95nmGaVinXFBGGMXEU9zvxFUVKLs0ZHmdZhmmapIks5Oi6TpKkeJ7L7GyLRqPJTHem342fptIMm6KgKKWL5goqjUZDyjsVlDI6AXEcMTx8E6ZplUbAMplvWRaGrvd9MDRVpchzoGCgOSClrhybOImxLIskibFtmzCMaDQa0lNCCBRFkcWBJIFA3k+306Fer2NZVil9lJKImJ7fLeWzDNIsJ4wjGs0BRJrSaDSIIrP0kJCZO13X0VQVzbLRVJXZVosszwh8XxabohTLtjAtC9t2aLdb2LbdZ0OggFqOT1VVMpGh2tJQWjP0cl0VmI551mA7z7AdB6/mlUUdyaLo+T1c15MsjLJ4Jr03JEuj15O9vW7pgRCEPq5tMzvbYmhoSBZVipxO950uhI8wtPVbTP3TvWTHgBcewX/hP+OvGsW4fRX6LSOyyHTyKOLll0hf3Hf29/6O7TTWn+tTdH3iJv131mHePEZyAordX+B052u4X/wkdiMi/ftJwu/JayjLVlIcm0duRVtK899t4fRdYxTBOPHoFL/a8ie4t9+KYUWkf/8SwdhfIF6fAkZQt93H8Fzopa2guX0Lp++W5yajh/jn+7+GfdfqMm47SvjCY0TfLpPjVxW7zI/88CRnrsireQR7zXK86zTPfdy8Ak5cME+cInxpL+HY4xRBeZ9jmxjQzp7mfnwj3WV7SM6Jb+27V+PePACc+6zk2M8rOl0lin84yJkDzfnfbB0n3T9B+tzZxhblwS00PzD/x68Wl4u3Bz77TaLxO2Wcv+1fM71vC9YX7pDPIz5F9Mo+wn6se+1ju/r1cmnUN/x7gqcmSF67eJ8iThwg+NZYRqzXAAAgAElEQVSfybV0g2Esen95dJD0xSP01i9F1azzfdkqVKjwtqH6u6tQoUKFCr/RCDZ96tIfuOUhnO9faKJmMbz5e6SvfIH09Sk4uJN4004u6k275SGc3Z8ku/sTJCcgP/YmgpGzP77WCpaM/5RTn7uX5OAUxdObCZ6eJ+9+xw7qY6NXRcMeuO/PicY/QXoMih1jnPmff8jii7riNmFuPk6yY4L0qxNcRGxftgn7L7ez6IIuscbd24le/jTxC8fh2F6Sr+692GthcCPmEw+h/uXHiJ5nXlPl+u/tAqtJ+yt7KFoLjMFdjf6d73HTR66siCK/W2rXzm4eh2AP0bdHiR5d3fdSqFChwluDZhgUhYJtOwRhSL1ex/c7GIZBlucEYYiqqERxQqPRJBWCXhAQBSGWYyNSQZbK5H1eFGR5xvT0mb5sTpoKLAt03cA0pRTM6dPTWJZNHMf4PZ9Qi9BLmZihoWHa7Vl0XcMyZYJ3oDkAKMRJTBLH2LYjZX2UgrzIyHOBaRpAgWVbqIqKpspEsWUZUICmaViWRbfbkebR3R5+r4eua+SZgmU6CCEldDRdLc91SFOBomjYtkNBDgUyga7KBHWWZTQaDaanp7Asqy9dI6WachrNBnEkTYk1XUOInCAI5P1ZNt1ulwIwyvNURSNNA6IwAEWRZsCKxsDAIEnJoCjynDiOyDLZOV/zaniuy9SpKWp1D5EKFFXHsqRhdSpSFEXOQRgEFEWBYRiomopuGKRJSpwkUMhCQJoKgjBALyV+/F6v9MqAMAxQFNl9PzIygqIonDp1si8RRVFgWqaU/FEU0lT6VdS8Gp1OmyzPMU2bTk9m2QLfx/cDdMPAMk0cx8WyrPJZdcmzXJom6wZ5IX0QgiDE9Txs15HzoyoIkaCqKpBhWlKOSVVUhoaGSUVC1++imzrNgSYKSI+DOMX16lAUUlLLcYnjhCiKcFyH97z3PczOztJut0qfDJvZVgvHcaRfiGMR+CHNxgCaqlMYCrZj9WWzMiF9Mc7MtNAUFVXVsK13/ldLv3kdI3/zc2bGHiF+ehKYgoN7SA/uWcCEdynqw7tofnklNe3c169T3KStoLljC6c/N0YRyLjJf3rzebIxymd/xMDHD9H6zPy67fZHHuKmcYsz92wjDyYR35yk882L70N79AmGfm/k/HNXPcRN4w3OfO4R8tZx8t0PEuyeJ25z12E+8b8zfDWxyzzItn/qCo2nt6D8cjne9ZrnOSz7ErVH38D//M7558ldh/nk91h86wX3qa1g+K9+yNTn7yU7Jp9T+DRc7Poxgrr5hwxfMM9Xg+IH9xP84Eo+OYJy3y4GvrLiusaDl4y33ZUyzv/j+0kOHIcDY8QHxi5+HuU8DN5/bWO7+vVyGWhLGf7+jzl9j1xP8+5TVm3F/sRBou0TC13lmmH/9ho093GyYIp82ydobeNdb3peocKvM6pCQoUKFSpUqHAeRuCW5ai/O4qxfpTG74xga/N8zF3Jkud+ysz4U4R//Sz566Wm6eBK1LWfxLh7AwOrRjCJObNuhOSJKXhhks7DK88vSrgrWPzky3R/8Sy9/2sccWBSRujucpQ16zD+1y8xuGaEqxY4KP0Cpj+zE9hHsmUv7ac30jzvXhZjfGk79bUTdL7zGOmLh8r7vx3jjzZS23BhIqCEtpSRb/+U9oZn8Z94luxAuVmfG/Ndm6ivXYqrQWfVOqLn98H+CcKTG6hfUJSo37Ed65WNtP96L8kL+8iPlZ1Ny0bR7tiA+7lRBt5CO199/dcInx8n3g88+SCtdS/znrXXtqGvUOE3HSITaIom5YMsC13TUE2TbqdDryuTtF7Tk13uGkRhLOV5ipw4Ks2FdSkJVGQZpqmjKCpJHJEkCYZh0u12S3+BApEJdN0kzwsMwyQMo9K7wCTPNXzfRwhBo9EECnq9Hu997xKKAtqdWXp+FxUNz/M4fXqaoaGhMkmu9o2EO50OnU6bRrOBqmnkufQvMAwTTdNl93wh2QSmaaAqGnmekRcFeRZj5BqLFy+h2+1hmmZfB980rb4Eku/3KPK8PJYd8kUBWSb6sj6W7RBH0v/BqlvouU4UR4CGoZukJSvD82p0e10sy6bn+/g9nyVL3kMQ9kApu94LsEwL13NKA2fpT+G5XslWsAhPT2OYhrxep1vKCtXpdNooCvR6XRRFoQCaXrM0wLZonZnBsm2yTJTG1oJup8PAwCB5nqPrsijTSgX1egORZdILQ9Xodtt9eao4ijAtk3q9DiikSYLjOtJjI47RDYPFixfTas2SJCnNpvwhaDYbFHlOu90mCHw0TUNRVJnQtx163S6e54Eijb+lZ4GHElKyQZJS8ikvpa96CJEyNDjM1NRJGo0mQSALIFmWYRkmuqZJo3AhPSvyPKfT6ZDlOYqq4Hkevt+T7BXVLI2rfXTDIMsydF1DUzXq9TpRENBu+xgl46XdnkVTNQok28cwDOIwYnCozpnTN9p99sqgN5Yzsv1HRF8+Qnf/T0j/9hD530+eZW26y1GWrUK7axR3dB3NhRiA1yluslc9xJIDd9D6/h6SZybIT04BS1E+vhHzc3fLaxw8RGveQZTXuPUBFr+ygfYzjxE9te/sWJasRr19A/aXNzK8gNSOfesm3vfyKDPj40T/9SWyvyvjNpai3Loa/Z6NeOtXUn+nQo7rFZ+W0Ndu4aaXbmN27DHSuRh12SjaXRvxPr2O5gIxmn7zOt478Wp/ns5bM8tWo67biHPPKI2bb2BX+dzaHF2NdccN+q7LxdvuChbv+QW9g+P0nppAvHyQ4mTJBHm75uEaoDdWsuS5/cxO7MH//s/ID5cx/7KNGA8+QGN0Odn4wVK2yYL59g3XisF1DD2zi9af/wAxt+d4+Q2SjBvzfRUq/BrgIx/5yA27tlLMCVpWqFChQoUKFX4jMDP2PvzdAFvwfvkQQ+/0gCpUqLAgZmZm+8dDQ29V/OH6fP//+7MfUWQ5IOWALNumVqsRhWXHexRSb9SIo7hvpBtFEZ7n0e36dDod8jxHUVRa7VmGhobQNan/b1k2nU67ZCNYKEqB47icPn1GJtpLvwLf7+F5Ls3mAGma0Om0qdcb1Os1Ot0uH/zgB2jPtolL3fo0TXEcjygKgALf93EcB03X0HUdBaXU8PeIYylBZBgGoNDrdTEMg14vxHFsPM8jDGLpDVF2zzuuRV7kKCgkiexQ13W9lFkKUTUNQ5cd/RQFaSo7/m3bpihk0j9JUlRVxbJskiTBsmzSVOCXBYN6vU4UhVJbP4dOt4Nl2TQbDVotmZnzah5nTp8uk+4DOI6NYeqcnj6N63pEUUSz2UQtiw1Tp6eo12uYhkkcJ2ia1i8eWLbFqZOnsGwT13X7fhZFAVp5vqppZYe/KufJlIUly7JAUfoSR6qi0em0+xJVpmkSBAF5nlOr1fpG0IYhn3sqEvlMcoGmG5iWyekzp4mjGM/1AAXXdQgCvyzKaNLHAgXf70EuTbblnCrcdNNNaJoqvTHqNQzTII1T/MAnCMq1oOloqk6SxBimgaJAnmdoqo5I0r7pcp4XeLUaQRj8/+y9W6ht+Z7f9flfx3Ve1tq76tz6tJAmRDGoMTYk8Qb9ENBIUAyCRCQ+iHkKiIGuJyUJaAzaD3loH3wQTEKaYEMkgqShj8Ron4emkxaPhPPQ0DbnnKq997rNy7j+bz78x551TDpdncRUld3/DxS19l5rzjnGmGOy9/5dvh/apsUHjzGGp6cHLpczbdNyd39P8B4hJM757KMQkuPdgYeHR4zSdH1P1/c8PD2gpNqk3DOvX71mnmdijBitGceRf/+P/yef90e+UCgU/oE4/ff/Duc//b9T/l1RKPzGfB5/pz+f//HHIhbZcqFQKBQKhUKhUPhMgs/i2L7fcXd/z7qJk0kJJfO0+LqsLMvK9Xrler2iVBbrCqHouh5ra5TWhBA4nU68e/eQM+zdStd1xBh5fn4ihMA4TltReMVWFUpJ+r7PsTvTyDiOeB/w3nO9DlTW8vL8kife14VlyRsMyzwDibCJkGNMOaJnXgjBo43eJMQT8zxtz5cn221V0TRZ5Hy5nFnWhRACUkqklDw/P+XoH6m2KfmRaRqZpgmts4S43+3wznE+n6jrGu+y9LeuGyBP9ff9jq7L5/b27VvevPkEEBwOh03qPLEsU87lr3JT4+Ul/4M0pYR3Obe/63qMyY2My/l68zi8evUKElnYHDx91xOCJ23NDbVN3a/rwjBc2e/3tG1L1/XEFLkO17yRojUxBty65ufajp2UOJ9POO9o2xYpZRYnG41SisvlwjDke6JtW+wWRVU3zU20/PLyTAweH3KT5uXlxOnlhRg93/j6NzYZccvplLcU9vvjbQNECIFbsxNCiOw2qKqKl5cX5jmLma2xLPO8baGc2e93NE2DlBJrLbvdPhfxrSVFmKaZYZp4eHzEhcA0T1wuZ5qmIaYIwLos+Tr1PVpr+rbDrY7hOjBu0VB1U/Pw8MAyzzw+PaKt4XK90Hc7lNL4EOh3u7wp4T1t02KMzfFPhUKh8IXwS3zy43+Y7/1bf5JP/sZv5NI4s/7i5nP7V7+J+VyOrVAofJF8GbenCoVCoVAoFAqFwpcOSdXWCKUR3lFXNdfzmbppiDExjheMUSzzjDEVKcHj4yNCSHb9gfMpx8FM84x3ASlygdzaXIgPIcf8tF1P3x9yVM1wpd/17HYdb99kX4KtDEYb2rZlWRfqqkHKHI8jpOLjTz7GWkvbdpxOL7RtRwyCpm5pmobzOXsd2q5FbdPmbVMjXr3GObf5CK48Pb1grMUaQ4gBpTVVpZFKYrTBO0fTfkCKWfbb9z1aG7zPz5FSYpon3DpjjOH169fM84TSOR5qmkbmOU/1e+9ZlxyjZIzheDyitcFYTYiB3X6H947L+UrTtEBif9jx7u07Ykz0u347H8U8Txhjtq2AmUTK0/Ba0+96tMjiaSUM4oc2DKy1xNQwLzMurPgoEFIiyNfuer1SGYvconjey5OnaSQlaJqGvusZhiHLmIXAGkvf9yzLxDT7LM4eR9qm5nw54UNO2n8vMJ6mLGxOJCTxFhH0gx98HxA0TU1dNwzXK8ZoHp4m+rbjcr5wf39HDNlN4bxHCLDW0DQ11+uVjz/+GGNMbn503dZgOGGtZZknqqomBo/WinVrbFVNxbTMt4aTNoqnp4csYZYa5x1N20IS7HY7rtfrzSNxvL/nfDoRSRyOR3zI8ufvf+97CKk4Hg9M08S8rNRVRdM0hHXlOpypbI1b/h77UKFQKHxOfBP5z/wS6W/8Eu4//528/Ev/0f9LqP2e8X/7b5j/5/y1+InfW5wFhcJvA8pGQqFQKBQKhUKhUPhM/BbZsq4rMSXGeeJyHdBaMw4DQgjmOUceSSmYl4VpWVlWx+l04td+7df45M0b3rx5Q0oJIQRKaZxz7Pf7TVuQGwIvLzmyR0CO5FGar3/jR7amRQCyEFht2wxuzVsQyzwTfGAaRy6XM9aYm0j5eH+kbZvNE6BpmoZlmUkpcbmcmaYJ5/Jrv9868C4XkN264p0nbhsBIQSuw0BKkRhz3n7bdqSUY5+yy6GGlFiWFUhYaxEyy4elkIQQN+myYtm8AOM40ve77INQknEcWZeF490dbduCEIQYWJY8Wa+13uKCcuTTbr/LjohTVtfXdbM1XRoQcD5fmJeZtusIMSCVYrffE0LgfeKtNVlkvCyOx4dHvA85bsg51mVldSvXy4WqqvLzhEDTNHRdT0qJdcny6GVZGcaBqqq4u39N13UYY6jrmnlZOByOrMuKcw7nHNP7BkhdM45ZIL3re5ZpxmhN17QYbQjesz8cSQliiExjFn8rJdntd8QUt8ZKT9M0WVKdEvM85QbAtiHx/PyCkpplXkEIxnHMMU7OcTweqOuKtmno2w7vPUpJlmXGrSvWWJx3XM6X26ZDSonT6YTUmn63Z9g2clLKomtrLfv9AaXzvdc0Lc45rLHUVc26xYV1Xcc4jtR18foUCoUvig/p/sgfy1/+yp/m8m/+Sd78te9wfj4zPp85/5/f4u1/+R/y+Mf+fP6ZH/tJ2j/yo1/c4RYKhc+NspFQKBQKhUKhUCgUPhOlJCHkqXJrNFVVUTdNLugrxfV6pWnqLPOdJp6fnxFSkFNgZpB5+r2ua+q6QgiJ2YS0w3DdJtxzk+D+1WvWNUcn+ZPbIpMWvvnNf4Lr4Om67jYRH7d4I6M1ta14/UHeLPDekYRASJGn3ceRmCIpRXa7I+u6oLVlnEaMzhE8VVWxuusmBbZM88wyL7eIotPLM8uy8PT0xN3d3SbTzRP+UorcVBlH6rqhqipev37Fxz/4hN1+xzRNpJRuP2+tYZ4XtDaQYBonAJYlRy7N84yWkpgC67IwTdm/cDmf2e1zDJKUguenZ7q+R0rJ6fSCNpq6qhmGAQQ5xmhrGggRuZzPGK3RSkNKzPNM8D5vAqTsAqg3KbNIQIJxGLi/v2eaJuqmJcX8OG3y+R4OR4y1LMvMssz5HH1AK83DwwP9rkcpjRSSj3/wA+qmpm1bQgjYqs7FeZtFxU9Pj/S7HSklUorc37/C2izifnj3lrbP2xnjOPDq7sj1cqV6/9rzTNe3xAgvz08IAbv9Hmty4MY0T1hbsSwLfd9nH4YQvDy/0LXt5rUQWVhdWaZpwXvP8f6OdclRW7v9nmVdiCHS9R0vz89opXn37oHKVszzQtNIlNZ5U8Y56rrm+9//Hof9EWMMp9MJY7J4XCnD6XKmqWoEsK4rgkTb1l/I57xQKBQAun/tP2X9k7/G9b/6Fvydv8z6H/9lft09qX/qJ2n/0p/4dWXdhULhtx5lI6FQKBQKhUKhUCh8JsZYvHNonUXC67KyzgtKaVKCl5dnlnXl4d07np9fqOsaYywv5xeeX57RWuO8x29F8nXNk+td17MsK1obXr/+gK7rmKcpT7Bbg0CilOb+/jXn8xkpJMuyEFMixIiQgrZtEUIilABgHK4AxBA4HI68nE588sknfPz9H3A4HLlcToTgCSHQNh1mkw4vy4qSCuccibQ5ChxCCMZhwJjsPfjmN795cyisbiWmyPl8YVnWm0jZuWWLQ6q2TYOeqqppuxatVY4uMpa6znFCl0uOXHJuRaocETUvuVj/8vLE8/MzUkgOxyPGWJo25/tXdcXd3RHnsp9guF5Z1jU3aXxgHEfO5xPTNOJcjhJKWwOhqmrmaUIIwbIstE3Hbndgmmdiitt1hbqubhFMw/WKNobr9cpwzZsoIQRSjAzDiDGWtu25v78npcg4TgQfbs2Cuq6xxuRGByI7NpSClGXY67rinMfWNUZbvPPM84RW2f0wzzPDMKC1YZnnLOJWAmsrqrpCa7WJp/PrzdPE6nLjIcW8faK0Yn/Yk0ikGFnX5XZtjLVM08gwDEzTlN9Dazkcj/R9j/eeyyXLDFPMmzWvX39IUzfYyrKsS/ZJqBwL5dyKD57K5g2O+/t7QvAsy4IQiefnJ6ZtAwMh8D5Q1w3O+c//Q14oFAo3Ku7++F/g1V//C9g/+u8ifuyHNg7ufi/iD/4k1c/8bT74q3+CV/sv7igLhcLnS9lIKBQKhULhtxn3P/l97n/yiz6KQqHw/zeM1cyz53I+Ya3h+eUFbXJsTkyJ490rxmkihizKvb9/hZaSV3f3NF3Pr/7qr9L1HdM0M44Td8cj+8OeZckOgWG43hwI43DBxz1CJLquZXUrfdfz8vKMUoYQIzEGtFL0XctwHUEKhnFgWWaElFyvZ37H7/gxnHP86Dd/hNPpTIqJt2/fUNkKpd5PVSViiuz3+1sD4YMPPsjF8suVrm2ZlwmlJAgQMjcybFVjjeX08sxud4CUWFeH0XaLMcoNCR8cfb/j7dt3aJ2L4VkkrVmWXAh/dfeKcRoJMWGMQSlF13Y8Pz8RQ0Ipw36/3yJ0FM/PjwSfsJWl7/P5JyAlgd+K+kmIm8h4XVZA3OKFpJKE6Hl8eqTv+81VYVFGcblc8d5T25p1nTkcjkghmeeJtm3xPvD48Mjh7kAKga9+9WuM48jLywvGGoy1zPPEuq4orfjgKx9Q1w3Pz0988vYTPvjgQ0QSWGtYbI6BOp/PSCVp6gbnLTEE5mEkRp+L9y4wjgO2svj50+iooA1uXTmfTjRNwzQ52ibLj+dx5N3DW17dv2YcrsQEVV2z2+1Y15VxHBmuF6TUtG3LPM98+JWvgIDrZeDDD79CiLnpYoxCSsk4jKzryn53zJs5Vc3z02MWhoeV/d0eU1t2ux3n0wnvPXfHV1wuF6qqpu87zuczX//G1zDK4lbHj3zjnnmeOb3kbRItFdfhyjiKL/TzXigUCgDtj/0E7Z/6iS/6MAqFwpeEspFQKBQKhUKhUCgUPhMpJQKwVUWMkaZpaZqWx8cnhnHi4fGJp8dnnPM3Ye40jUzzvE211yzLSt/3HA4HIOUp8S2bv98ia+o6T+0bo+n6nrppsMaitaLregDujndIIbc8+Sm7C5o8jV7XNbvdnuPxyMvLM9fLBciRPdfhitaGpu22iXBBDNlzsA2E49Z1izmqb9Lj/f6AtZZpnJjGMTsMyLn6u92ed+/eMs8zbdvSdT3GVqQUCd5zd3eHEILj8S6LjaW85fTP80yKaZNMd3jnso/Ax80dkCXMMW6RUlV+XikVd3f3N1n0+Xzh5fmF4XoleI+QIk/r1walBG3b3fL6j3d3OX6nbVmWGalUjlwyBlLKkVVVjdaaD15/CCkX00PIUmatDV3XEUMkJfjBDz7eJNOevutJMW2vlb0QKeX7oGmaPJXfdjefhnOOZVmYppG267KgubJbs2bm7u4VMUWMtdzfvyIhmOeZpmnw3tO1LVVd0/c7drs9IHjz5g0AIUZevXqN1pphGLNPwti8edF1aK2Z5uymOJ/P7PYHvve97+Hcyn5/YBxHtFJopZjnOXsbIG96RM/9q/tt6yFvnLRdf5N1n09nhJSQBNM05Xgla3l8fOR0erm5QZTShBCoqoqu69gfDtzd3dM0TY5dKhQKhUKhUPgSURoJhUKhUCgUCoVC4TOp65zZ7r3fBMKCx4dHQhSAJLcDBG/fvmWeV5qmzQLbus7F4nHk7u7Irutomor9cU9VV7x6/YqqttjKsj/scS57A8Ztu8CtK+u68vbtG56eHgGYtuijECLWWKq6wntHCIEQApA43t1T1TVJwPlyJgRPiom7u/ttytwwLzNKK5q6yXFJMRJCIMbIcL1yPl1I5Kn+l5cXqrrCWEvXdSitgMQ0TbdNg+v1ijGGy/lE8FnCXNU167owTRPHuzuMrTDGopTCu8DpfOb55YlxHLh7dY8QgsPxwCeffEzT1MQUubt/hQ8e7zyIBAJ8cEgpmcYs8j0ej0B2AqzLsgmQO7q+p20bhMjZ/945vFuZxgEpFeM4IqXkerlkh0VVscwz3nl8WNFaczpdCCGyzDmmp65rtMpeif0++wz6foeUinkekVLw1a9+larK3oOHh3c4t5JS4no5M04TxuhbRFLdNKzrStrur3Ecqeqap6fHrREUWd3K6eUFISXTNDHPMwgI3nM6nQghZGm1tjw8PLB6l0XN1nJ3dwcp4dyKMZrhesY5x+FwpKlr+t0OKQVd33G9Duy2X3vvmeeRy/XK27dvs3haKJotnkkA0zQihEAKybo4Ti8vPLx7R2WqLOW+XljXFSklJPjKV75G8IG2bTkej+z3e+ZlwgfH5XJCSMFud6DvS1ZIoVAoFAqFLxelkVAoFAqFQqFQKBQ+k3EYUFqzLNmLME0Ty7Lyq7/6f3M6nXh8fMTaCq0N67pwPp/QxuC8wxjLbr9DEInBIyQ0TU3TVFhrsNaglMQYvU3tC2L0VDZvIqQUaZoGIdkm1xOXTbLrQ9jkyGqTH+eivvd+i9mZ2e8OKKUQktvP5Fz+LLdNKT/fw8MDWhtijFhbsT/sWdeV63XAVhUkaNuWpm0IIaC0xlpL1/UIIRDAMF43ibRnXdebg0ApxeV84XI+AbA/HNjvDwTvkUpiK5vjcIJnHK90fcvx7khV17x7945EjlUyxlJXNZAw1hJj3l6Y55kYI/M0sywLw3C9yYJz7FE2J2tt8jVE4NYVrRRd37Pb9Vs8U3Y+2MoCgutwZV0XlmUGYJnn7f2J9LssLG7aHCe0LDOvXr2mbTtiDIhtg6BtciRSiAHnHForXk4nlnVBKkm/29P3OwC6ts3xSzK/P1IozHbfjWOWJcsttunl+RkfcvzRe0+DsQYpJVppEgklFdZamrZFbE6JLHPObgQEVJUhpkDTNEB2NcQYmcaRqqoJPmC0oWna3JxpW+ZpZBxHum27YVkWXl6eSTGx2+15+/bd5gJxCLJ7QRvDw8MDQsqbbBzga1/9GkoKDvs9j4+PLMvC4Xj4XD/fhUKhUCgUCp9FcSQUCoVCoVAoFAqFz+Ry/TTnPcaIUprVOe6OxzyR3nZ0fYuUihg9y7yQUqRuK6yV3B13NE2L1oaqqpjnBa0F1RaVlHP6K5qm4Xq9cH//CgBrNXf3R5Z54fXr1ziXi+NKKZ5fsrsgRMG6OEIMWyNjRYbsKKhMhXcrfdey6zucc1hbQ1Ic90fmZcY5R7873LL353khhMjhcEAIsNaw2++Zp4kQAt7lCCbvPU3bcnp5YRwnuq5FCrFtCyiapiPEhNaW6/VKjJ62bbFWI4XgcNzjfYPWOV7n4d0DX//6N1jdkjcWvKOyeXsh+IhAsCyOZVnztkL0VHXF5XzZrnvEVhVuXTZZb24eNE3NNNV0XcubN59gjKHrdsQQQAiUVPgYt+tnb3FL87Sglaauq60oPmchtTL4rUFkbcU4XKnqmhACl+tATIHDfs+yLqzzQlVVCCnROvstvJ/RJsuStTacTyequsFawzTNuHUhVpbT+YTRJrsfvM8RRv2OdZlvjSK3rgghuFwuKKW4uztyvpyJIbLf4rLyZkHe3CAlpMrbGVVV41ZH3xPhsrwAACAASURBVPfMy4LWiqqqIAmU6nh4fMBWdW7CpMTDu7ccDgeUaTidz1SVJcbA8fiaaZ62CKTsh/ja177OPA58+MEHVLVlXbPwuetagve8e3hL13UArKtkt99vGzG5kdR01Rf3YS8UCoVCoVD4dSiNhEKhUCgUCoVCofCZhJg4nU7EmNBKs64LdhMDA9R1xTKvCAGH44F1yZP+Xd8iBFuBNrLb9TjnsVZzuVwwxuYpdZWLuO9z5p+fn7FW0zQVRuvcfFgWrpczx+MdUioulzNG55z5lBKv7l/hQ2C32/H48I5lWdh1Ow6HI6fTCVLieDjmvHshkFKyLisheC7Dhd1uz7o65nlCG70V/3No09PjI4fDAbMVo1OKeO+RUt1y8q2tcG6hrhucc0DMMUQ+T+E3zQ7v180RMCKEwlZ2y98XtG0L5CJ+XdfEmBiny+170zghgBgjy7KwLgtVVbPfH7her7m4Hzx13aBNvmZa5+0RvTUmmqbhcjkTU6TvepZlwWidfQ1E5nnFOYcQAq014zjgnMMYTdrOG0Abg1RqczLIHI80XBEyv06KEe8cxuape6UVhvy1UAq/rmSdcPZTeO/wa3YWHA5HjNEIBHVd520V29ApxTgM2VcxXXj9wQesy8LHH/8AIQR9v9ves/yc8fYeSdq2ZV0XLpcLWufrXtkaEAzDQNu0LOvCcL3SNh3jNGK02bYf4O27dzRNw+pWYohoY6iTyJsTJIbrFakk4ziw3x+IMdD3PVorpmnE2iY312KibTt2ux3ee5z3LNPI/at7KltxPN4BCSGKbLlQKBQKhcKXi9JIKBQKhUKhUCgUCp/JZZMWa2X4+M3H+BBIKd6aCu8LqlVlqSqD0Ya2bRmGM03T0DQtp/OJaRrpd3uulwuvX79mGC6kBN0WbWO0IdqIEIK6rhBCEHzgOg1oo2m7NsuBtaLrWpzzKAG2Mjw8PmR/gVJcr1eO+yOVrUgpsS4z67qCEFlqLLIsubKWZUl89cOvEGLicr3S73YIIXBuxbs8zZ5SoGkqQkgoZej7DqUMLy/PWYRsLcuSo2yu14G+77fjuGCtpa5zjJOU2QNwPp+pqvqWxS+EyFLnqkJIQUyf+heEEEzjyOocUkiUVKSYkFIhhCTGyP6wA7I8WghB13aE4Hl+fiaEwH53JKWAtVWW+7YdIYRNbLzw6vVr5nnkfLrQdR1uXen6Hr3Jp2NMVHWWaEsJUqqbk0IbTdO2mzDbY7Qmhrh5AO5Y3cK8rLdrpJVBmrxF0JkG29RYaxmH3CgJ3t+2TmKMWQy9LgzjQLVFZzVNw/l8RklJ1+9w64pzK8uyctzvWd1K13dczuetQQNK5cfu9wfqxqK0Zhwm2qbDeZc3BBI5qqnr8cGzLAsAd3d3+XohuFyvPD+daLcYJuc9UgqUNPl+DXkbZBgHQqy2xs8ZIXI0l5KKru/4/ve+hxACoytSTIzjSN/teH5+xvnl8/+QFwqFQqFQKPwGFEdCoVAoFAqFQqFQ+ExW55nmBecdh8MdTZ0jeS6X823iO6VE13V5aryqWJY5uwOEAAFSSrquQ5CQSiIESCXx3gEQYyABWmuapkEqxdu3b6k3IW4MgbpublsQWme3wrq6nIPfNLRty7LM3N/fs3rHMA48PTwgRI4tWpYFISXO5S0E5xwxBqIPrOuK0poU43Y8kRgDAP1uj1Rqi/XJhX/vPVVVIbeJ/OxC0DRNh5CSeZmo6mprIlgQ2XNwd3ePVhoSTFN2GxhjqOq80WCt3Rop9SYfHogpYfSnr/3e7TCOA3mCHVKMt+K79x4QNHVL1/ZcLmemaSKl7H8IMeatjG3y/Xw65fNQ8tOIpzGLhGNMrOuyTf13CCnoui57Ha5nVuduDYUYIynG2zUZpwEQNzdFVdVoo1nWFWsNy+xQUtK2DcNw3RoVEqXUzSFgrc2PVwq247U2xyvN85zjirb3dFlmxnHEh8DTyzPW2rwhkRLO+VsDyfsACGIMnM8X5nlCScXd8Q4SLOuyNYsku92eV69eb1smkGK+R/vdjrbteH5+whjLPE0cjoe8XRE82mgulys+5Peiqhsu5zOXy5nz6cT9/autYeWZ57xdIpWiqqvc9CoUCoVCoVD4ElE2EgqFQqFQKBQKhcJnMo8LIQSe3j3x+tWrTXCsqeua4D22sqSUC+/aWLqu5fn5iQ8+/ArOr8zLStf1W9F0pu876rrOPgOyXBkkuVYsqesK7wN13bIsK8syU1U167Jgq4p1XbJMV+k86d22hHChaRpC8EilkEohpMzT9FWF845hyBFESkn6TRBst00DKSW1tTkyyFZ459gd9jw/PaO1QivDtObMf1tZzucT85ybJXXT4FaHEBKpBE3b8PwyY4xGSklKKcckJbherxhbYYxhHEf0Fi0E7+XPWQotlcKairvjkYeHR67XEWstxmigRoitrr79PwTPsuQC9LIsNG1L0zSMQ44nkrLaon4Ey5IbGO83NtquzZJlY5hD9jHsdntiijw+PuC8z+LhEJDSI6Sgriru7+44n89cVN6OOOz3pBS4XK6cTvkYrE3EEHl898huvyclTwyetuuJMTIME1IZdrt9jpS6XPN7uEmMvfc456kqyzSOHA57Ti9ZWi2lwlQmC5pVbkBMy0xMieBydJDdXA7eR7x3XMeRqqlZnUeSmyb7w4HTKb+f5L4Xzi0IIXl6fNwaEY5pFnifxcyX8wnvA3fHO+qmRiqZY492PVppzts2xPtIqHmatq/z9kHT5IbE6Xqiri3rsmaJeGVJpC/kc14oFAqFQqHw96NsJBQKhUKhUCgUCoXPJMaIW1eapuHt2zes67pJkmeMtZv81rAsC1/5yle2SB7Ju4d3aKUxm09hmkbsNsX//nmXdcGavFFQ1zXWmm1TIJKSQGsDCJYlZ9yvS56Ov16vPD0/IaVkWdbbxDgibwcYu+X4h4BUkmVdaNssXPYhZFmv88zzeitYz9OEEODcmqOEpMqRPPOMMXY7Zo8xmqrKv07bebwXJNd1s4mL9W07wFqLgE1avKJUdjtUVY0xlv1+R9vmqKZpmkkJiNC1HdO0bNeTTdZcbQ0bgzaGGALr6knkWJ2UchG6bRq898QYb8eS/Qw5QkhJRUqJEALDMHC9XFEqz5o555BKkhIopWnblqenRwDqraGzLgukRN/3tE2D0QqtFUoppJR5+0AZvHMoqW7vu/eepmlvEuNpGjmfz7y8PBNDZF3XfNwhUFfN5ivQxBC2TZB8baWUOL/inUNrfYttyv/V1E1LQuCcI6UcKdXvdtzd3W9RXGzfS5vIOkuurbXs9jkqahwH6rrCWM3x7sDxeNiaVh5rK87nM8753BCTeVNEG8M0TRireffwlhBzBJQQ3Jpvh8OBaRoB6PtdPv6qQsBNCl0oFAqFQqHwZaJsJBQKhUKhUCgUCoXPxDmHkJKmaYkhMM8LsOTJbx+oa4P3OXP/cjlvRdzErt8xLzMxBIbVUVUV4zjQ1BXTNOX8/v0BozVCKpYtQmdZcvFcaZ2bFSZvCFhbfRpTtC5UNgtv3xfwldJcryfiFk+USNx/cA9JYJaaumoRQhJi4PnpGSk1MebpdbZInxA8ITiCD0zDtEUJBZxzKCXRWhNCzMdR1ZxOJ4w2LPNMjAHnFrRWpBCYnUO2gpQSy7LkHPy+x3tP27VIITifz5zPL1hrsdYipSKmhA+Ry/XM9TpQ1zW7fU9KkXGaGMaBRKJtW9qu5+kxN1SMMZsLgs0NkYvj5/OJruuIsSKEQExQ2bzZUTcNdVXn9yNGzucTh8ORYRxZlxkpBNpYrpcrbl2Zw7SdZy7Cv99GWZcs257niabpCCFxf3/P09MjMSaEFHjvtsioRAwB5x2RtDkKdizzijEGrTUJsJVlHifatmWe59sWh/cOow1N03B3d+R8vjIOA23X0cqWcZq4DFe0UhwOdzw8PmybFx3X4XJrWK1u5f7+Fcuy3GKq+l2fZc0xx0AJKSAk9vv91izyjNPI/X6/bZDkTYdpnBBS4n1gmkdevbrf7heTmy2b3NpayzAMyC2Gal0WvFu3LYUmS8J3uy/0814oFAqFQqHwd1M2EgqFQqFQKBQKhcJnMk8TpIRbF0CgdZ5Jym6A/DNKKZSSxBQ5n04oKTcJrWQYczFcSkW9FWzXdWWaJiC7AyBxvVyykFdrUgJrzBZt427y4aZpkFIhRZ5+TynRth0hxCzgVYqu65AixxqFEBnGEe88MUWUzo+Z52UTNxvGaSL4gFKaaZpQSmKtYZzGrVhe5Sn4rYkxjRPr6rhcr0AuOvtNshu8xztPZfNkfIwJ7z/dFLher/R9nwW72/nnY+6p6hohBFrlifsQI0rpPP1PynFH1mKsJcTI6hzn05msPBBUlaVpapRSOO9o2hbnHH2fJ+ynacxuCanyZobP0/LLuhBjRApBCDmiKm9QLNtGSD7G/D6MOOcJIb8vKSbGYSSE7Jkw1sImq35+eSaEiLEmr24kMMZucmSXGzJIlNQ0bYPSCrOdX1PX6G0bYl3X2z2ndW40LOtK2DZL3rsspnFEAH3XY7QhhMDp5TkX7NeVdf1082RZFva73BywlaWqKiD7IK7XC88vzwghWdd5O9eV6/Z+W2O4bPfqPE845+j6Hmst8zzTtR1KZSdEvs6eFCNaKYSAumnQSuVrKwTWVvmeVTJf+/cfqkKhUCgUCoUvCaWRUCgUCoVCoVAoFD4TpTW7bVJba4HWgt2+o64NXd/Qdd3WKJCEEGnbhuPdkcslR7/sd4ecEz9P7Hb9VrxeOd7dMU0T67pyPp+JMRfz13XBWEtd5+JulvnmgnZKIIRCKY2t6ptjIMf3BKy1nE4nQkgM15FpXHFrLnKP40hKAaUEcotAymLjhqqq0EqhNnGy1halBMYYYgxM84TzK8/PL0zTwul0zh6HTfLcNg1CSMZhYplXvM+T9+/jePp+d3M4KKVou47gPXXT0rYdb968wXuP1pphvOJC9h24ddk2LQZSzGLlvu0hJoggpUCILCBGQIwJaw3DcGGahjxRT3YoNE2D2WKksu8gNxe8dyTyz93d36F0joSqrKXfpuObpkFrvW0iRNbVZRH0Fpn03h1htGFdZvrdLm9zuBwdtbiF8+XE5XzGWEO/2/HBBx/kxtLWgMqPzzFGOfrJ3CKj3m91aKVom47KVgCczmdiStRtTVXlmK3Hh3cYrajrCqUUWknapuF6vWCUpq4q1nnBrQ7vHKfTCec8WluCT8QIwQeeX54YpxllLOvqUErf5NPOLVvzTDMO05ZGlLI8evOBGGPY7/ZczleGccyi5fMJ7912z582cXNPt+tuDZPgw+f6+S4UCoVCoVD4LEojoVAoFAqFQqFQKHwmWimaumJ/2LHbdbRdw7rO+eu2w3ufi/F1jRRyk8Umuq6naZqtCG22RkMu9u922QtQ1TXzFgv03pOgtcFaS1XXAFlAGxPeJ6Zp5uXlGecc67Iwz3OWB4d42yh471SAlLcXpKLrdz+0NZGjeabx/SbCVhCeJtquA+B0eqaqK7RWGGtuGwXjODBch9u0vDHZX5Bg23pI2zaFxfvAsqy3JobWmr7PkmGtNH2fi+3vY4LGYWBZF3zwuOBBwPHuLouRqxzn5L1DSIGUMm8RyFwwl1KijSalPPm+2+2yb2DzTeScfknd1FtDwdy2LKSUOY6JXEAnZeOwjzGLlm21bTlkN4BUiqqy21ZBLvp77znsD9Tbxsg8T6zOEVMkbFP275tGeUrfkWKk63vcuiJEjo2al5mUElIKQgi8vDxvjSSNILsOzudzbiysjut1AJEbQ0rlRocQYpNcR5TK56eUYrgOpBQx2+bAMI5chyvzNBFT5Hq9ME4jwziCyFFRUiqmcdwaNFXeGpGCuqnp+g6tNd47gvfM08zheEQptTUcVhJZfh18dniE4CFxa4woJRnH4RbdhIBxmj/nT3ihUCgUCoXCb0xpJBQKhUKhUCgUCoXPpOt7xmkAEk3b0jQtbduileJ6vfD4+IRzK12bi/BuXVEyRwz1fb9Ji6ttA0CyzDMkeHx4xK1Z7Nv1PVIp5mXO0T8pApEQHELAq1d3WGNJMUfuSKlYt3gbpTSry8Xo8/nMPM+QIsfjgbfv3uBDjpapa4vWivu7+y1GJlJVlg8+/BCpJOOQC7rOZTGvFIIYI5fzmdPLM8sys9/vqZv6Fk/kvc/Ni5Ro2pq+79BG34rnuSiuOJ9eGIccsTSNI09Pj6SU45ycczdPwbj5D6TMYuTrcGWap1wY36KOchE6F+QfHt6BiPjggIQPeWOgaZocs+Q91hoOhwPzPDEOI9M0bdn+7yffBU+Pj6zLchNhT9OMD4F3b98wjuNNWh1iwBpLVdXs94fcGPCORMqbAbWlbipSSrcGU974qNnv9zRNk/0Iq2MYBtyaC+xa5YK9kjmyqmnb7TlyAySGCEIyzzNSSpouN6eWeSGEiNzioCBRVRXLMhN8FmO/b15kT0QkhkDbtpvQG949vOPl9JKF1VtzZp5nrK2xtiKl3GC5XM5cLmfarsvCaqWIKdB2HbaqMMbcrrlbV9zqmLatjRgTVV1jrSWmtAmjBeN0RSqVxc1+JcTIvCyf8ye8UCgUCoVC4TemNBIKhUKhUCgUCoXCZ6KVpKpydNH7Qn3XdfS73Q9FGoU8bU1CKcX1es0ehHliniekkrhtOl5KddsYUEpBgsPhiBCCeZqRSkFKXK9XQvBIJZFaYSvDPE90bZcL9EJijaVtW7q2pbIWuUl9pVLUdY0AYsgF8+fnR67DldVlqW/TNFsxOTHPE0IKYgj52BIIIXHOs9vvEQKU0pvvIMucrbVbxM94K/4nEssy47zbxM0BSAgpsZXNr5Ei3nvevHlDjHFzPUS0VoQYNs+CQyC4Xi95wl4phJQ4t3I6nRBC0Pd99gUseaPjer3k7Qqt8D4gN4eElBKzHev7Ynve/NCb4DlHOBlryJ6A9bY54r3P8UzbdTHGoI0hbMLl9xsn6+qY5okQ0yaMjgzjQEwRtusbY8S5dYunyk0W57IoOxfS8/uWgBjiTTystbo5HIzJ2yF6iyh6vykSQ2B1uanjvcuRRloDiev1kpsSweO8R0i5bVVUzMtC2/VbM0LdtkMOhyNN0wLQNC110yKlwhjLNE7My0yIYdu+gXEYsNYihGAcBmIMWwMBuq6l73vmaSLFhFJi83BYDocDSmtiSnR9Twif+jQKhUKhUCgUviyURkKhUCgUftvz9uf/PB/9mZ/lV3JNiMsv/DQf/Zm/yHemL/a4CoVC4cuEMZq6rrc8fLkJcB11nWNyuq5lGK4Mw4Ax1VYgzjLlcRgxxiKF5O7uFdO0ME7zNilvSSkipGCZ59xEkHkzYBiueJdz6YUQrOvK5XxGCEGIYSvGaoyxeBdw3qGN5NWrV+x3u1wEdx5EIsf/J5Z5wTvP2zdvcW5BG3VzN7RNw93dEak0pBxTlGNysly3rluU1viQp9yd32S/W2F7mmZCTJDypLog+xeM0YTg6Xc9Wit2uwMpwbKsxJBuU+zWVhwOR6w2W0Z+fryWElLE2gqlNZfrFWMs+8OBus5T/jHkwnOOJcrbCufzhRTTD0UeJUxlmZYZ5/1WFDdYWzEOE8YYvHPYyjJOIzHFW4PBWss0TTcHhpK5gdN13c1bsK7ZG/H09MLpfM5ND5+jj8ZxBNiaElnQPS8z4zRwPp+Y55FpzNsJSini9hgpFPv9HiFyo6qua+LWlHh5fsGtC3LzXFyuV67XK3Xd0LYdXdcTQuJ6Hdjv9xhjUFrnZkcIuHUlBM/qVu5evcJWlnWdsVuMldZbZFVKWywUnE8nnh+fsKbKgui6wblPmzPTNN0aPl3X874fYIzFe5cbMCHl92uLYur6HqUUfd/fGjPH4/6L+Jj/ffnu//Cn+Oijj/joT/0s341f9NH8vXznL33ERx/9FN969xk/+O5b/NRHH/HRX/rOp7/3f/1FPvroI37q59/+w734r/ecn8XlV/jWX/02v5lX/E2f2z8q78/jv/7WDx2X5+lv/Qw/93d+k8/hn/jlv/JzfPeHf+8f9foWCoVC4UtDaSQUCoVC4bc3777Fz/z8M7/7D//r/Nj2p+Lu9/0RfqL9Dj/7176L/2KPrlAoFL40dF2LEGKTKlfUdU3d1KSUNwqsNXRdtxVf022iWoj3ot+8EVDXNQgwxuQiu7XEFFFSMY5jLvYqtT0m4r3bJrvz430IaJ2L9MbY21T8MOT4mPP5nLcCUqTrG4QEa2vWdWWeZ3a7A8u8IqWmadtNhOyYphEhBEpK1iXLgU1lAYGtKkKM2YHgfZ4qT4l1WW9yaLVN/s/TnCNsqhqlJPPmaxBS5g0DkQvOSkmUknR9jsip6oqY4nb9RJZGG0vT1ISt0eLWlbppgLydEEPg5eWFYRiQSmFtTV03IMTNW6CUpmkalmXBe3/bkIjBb02h/P7Oc446cs7lLZOmpqoqKps9CO/9DlobgnebRNnljQyXPRVt2wBsHgTHssUkBR8IMbLb7RmGK1KKLKEGgvdorZBCZPdAVjPgvcubH8A8zyglbx4GUqTtutv3hchNqBgi0zQiVd6+eH/vOZf/NF/digAO+xzxZK3FWEvYoqCUlLfmlnPZa9E07c1hMc/LtlHhCDHgnWcYBgRicxwsOOc2WXJuUMzLfDuHdV2ziHpdWNeV6/W6fU5EvgeqirZtb1s7Xxrid/jFvzXRNA1Mv8gv/HL529E/Gt/lZ/6L/5af+5Uv/8TK0//y0/y5v/LLvP1N3Y5PfOun/xw/87fe4v5xH1ihUCgUvhD0F30AhUKhUCh8kXz7Z3+OH3z9D/Ef/LPNp78pP+QP/hs/zrf/u5/hf/w9/xn/9u/84o6vUCgUvizsdjumaaLrOqZpIsZAVVVYazmdXlBKo3UWGqcYGYYrQgisrQghsCwz67pgbZ0jaeoa77dis8iT6/M002zF6PeRO8NwpaqqXNRt+y1fPzcYjNVcLxeapsXa3FQIAZwLNG1LDJF1XYkhRxNlCTQIKUjkLQuByFEyMU+T393fZRmvyVsBdV1ld8E8YYzNEU1ScTq9ANmwLJXc4o4SIUS0tkglWJcVpTVSKtzqc3F5dVs2vqSumzz9P1xzUyLlkJyqrlFbY6NpO+p6yDn/bsWHXOhWWwTPNI2EmNDG4H1A6/cugVyezkLk7IeIIaC12bYs5CZKzpsJMWZfgrWW8+mE2hwBOZon4oNnvz/gfaBpWrz3LMuMkrkJoLVit98zLysvL2eU2rZGhLxFUUGi3SKp1nXdon0qYkxbXJJlniZCjNl9sHkCgs/RVj54xpeRfpvgF0KglUa3muswUNcV3jmkkExb4+N9LJL3Hm0t/ocK/dM0oo2m6/ocjdW0jOOA95794cA8Tdu9HpFS5tis/R4fPMP1gtLZvZDjnuwtwupyOefzFAAD67Kw3+9xzuHcyrYeg9riwOZ5Yp4WPvjwA7TRW1PnyxNt5H/5F/lOhN/1B34/l5//Ft/9P/42/p//8d86xYR/+t/jz/7Zz/MFHf4foE/0u//on+VzPbwfwsd/kKaRp3QQCoVC4bc2ZSOhUCgUCr+t+blfzf8w3v3d3/hdv59/4W7iF//63+TyRRxYoVAofMlICVKKLMu85c6L7ffT9r1EjDnOyDlH23ZUVYNU6pbT/37a3hjDvMw0TYNSimmeAYHctgHeP6/Whqqu0dqgpGK4XrepfpBSIjaBs95il1KKeTp8mFmWdZv+F9RNRVVZhATIxxFDFh6v68q65kz8bpty73cdVVXh3PsYnm2qPsQcm9N1VDbHNwmZ5cPZgSBo23ZzMuSmQtO0uUkxTtRNSwiJdfWklM9XCMm6rptfQTHPC6fzGW0sy7IwjRMpQUzZx7AsC8551nVBaYUQ8iZAXte8afH+vH1wtyl+YwzrutK1LSlGEum2TeK93xoTK97nSft1XRnHiXVZc2xPygLtGDzeuyykXleGYUBpnRsZwbMs600uLRBb9FVLVVUE52maNt8TUpK2c2K7d+ateXK9XpimHIWUtwHWrfkhbpsf7xslfhMbpxgx2uC9RyqF0poQ4hZJJDHGYqzJ0uvzCaXV7ZqEEFjmGSEF+/2BEALTMOSNiZB9GN455mVG6bwtU9c1u12OXKqqavtM5M2b4Trcmhdye3+1NiC4xUn5bWNBiOxfSCmyurylIKW8Ca+/eC58+xe+C/wo/+Tv+/38nh8Bvvttvn36oo+r8P85r+75EOCb38j/LxQKhULh7+K3zBBBoVAoFAr/MEzNj/MH/rlf74/Dr/Ov/Itf52/+T9/mf/3Bv8wf+vrnfmiFQqHwpeL5+QVjFG1rsLbOETh1z7Lk4vU4TtR1fYv7EaKj2rL2u67LxVEhN9mvYF1mpGgYxysIyTzN7Pd7vA8orVEyT7SnCEoZEomnx0fqukEbQ4qJGCLGGlIKCGVRSt9Eucl92uR4/cHrHG/jHW5dkUoRQkBKwTTleJG6rpH6fSNDZHcDMA4jMUScC4zThbu7uywlbgzKZPGyAERdb9JiffMlpJiompp5nuj3Pd6vt00HJRXTNPFyPrHMM0YbbKVZlhUl9f/D3tvHWHbe932f5+W83jszu7PiSlkLa7dbY2VoBa8IMTDV0kUliG5MwWwsQWVRGq0KBCiIVECVRmahoHGACJCdmkDlQCkiFE5gGiYS2YgKM61pmG4lW1RNltxUS0gLh460oBf2kpzdufeet+e1fzxnLl9XlGRGS4fPB1hoZ+bOPefcc4c7+r18P3NkkGWz6QkhEgMgSHFSgLcubUNIQaE0QkqGYcA7x2K5TK6BuZg+TSN1nbwMMQSmKZ1HWZQUWmGt2zY1+r5P4mRrqau0TRLmJkVRpm0GKSTTNM2voURJnaKMTIqYGseJsixTRJBzaCloqmo+BtvHLBYLrHUorTk8vM5yuSTGQJw3LNLrKbc+AyklIXisNSx3XzSDfgAAIABJREFUFkyjIYQkZD7aKNnd3WUYxiSnlnL796qq6DYd1lqqOhX+YwiEGAnes9lsGIeR48ePEUIkxEBd1CghCUJCUaQNFgHTNPG2E7fgvKNpU2xUCGHeoikIIbJareYmWHqPbDZrnHNUdc3169coihIiaF1gJsNiuUQrRT9NKepJqpv3w/5SDi/w1LPAO9/DuZ0duPU0Dz97mcf+8Ap3/PR38cvRc4/ywC8/Ah+6j49Ov80//oPLONlw6ifu5b4Pn0ED7oULPPzPH+HxywdpUr/c5/Std3LPh8+z/8pf0YbLfOW3/gWPfuMKgwO9d5rbfvoefvgvco1PP8j9v3aRkx/6JJ/84EtK6K881uIU7/2Ze7nj+X/CA797lXM/91nufffLn8q9cIEv/caXeOrZAYemeee7+MCHP8IdP9K87FjptXmEB+5/BG65k0/+rQ/csHh/8dfv58Gvn+TOv/VJPnDL/Mmw5pmvfomHf/+bXOnS1oDeOcW7/uO7uPv9Z9g56kPNxzv3c5/lbvkwv/a/P8blaw6kZv/0bdz5n9/N+ePzY+UpTp6AU7fcAlzl0V9+gEdmL8PFX7uf++E1rzldS7rPyYJwkQfvvx84x72fvZdzL3nY+plH+eIXH+XSjc7hiFdd3/xa/rW7uePMq8Z/MplMJvMD4s0y5pDJZDKZzM3hPzjL2Rv8a7jzo+9inwOe+NozP9hzymQymTchL0qF2ToMrLUYa1NxtqqQMhVv27bFe8s0jVRVRVGWlEVB8J71ek3fz/n0hcaHNO1traVdLJBKEoPfTsojBNM0Mc2RQpCOfxTFM40jMQaIEaVSEV8qORd4U/HZGEvwyaXw0kn0o8nvI+GzMYZpnFLzIEbc3JToum67uWDMRIxsPQ0heHShZ5+Dn50JaiuQts4SiSn7f3Yw+Dkqx1o7OwJKzGSJUWwjewDMPN1/VLRfr1Y0dYWSIkUKyRQNdLTtoZUmhFSIl0qipJojhNIGSVkWs8BYIIVM0/akCJ203ZAaKMYY6qqimDc3jqKYvPOp4TEX+BfLHUIIlGXBptsgpNhuDaQmh9pej5lfh81mQ/CecRy3Qm4h0uskRLofTdvMRfvkekj+Com1LjWa5vfG0f1rmuSGCDHMXojkjwBomoayqkAIhnnD4ihmKsSIFILj+8fpu27e9kgbMVVZIYRASIEuitkN0lCU5XaDw1mDNSZtF5h0HWmDJW1iWGPwwVPMomshBEPfb10jy+Vy+/4TAoqynK/Rzffs5nPlDx/jCnD61vPsADvvez9nJRw8/tj3JF0enniIz//BNU792HnOvbNh/9QPo4Hh6Qf5zD94iMe+taI5fY7zt57n7PEVl7/2EL/0iw9x8aUageEiD/7Pn+fhr1/BnjjL+VvPc6a+wmO/8Us89PQbe90vO9biNOduPc+Z5VUe/41f4h999Qa7qn/yJX7xlx/iqfUtvOvW85w73TA8e5GH/9df4eHL82P2znD+1tPsAzSnOHvrec6f+yGa137GG50cF3/jAb7w2xe5Wp7i3K3nOX/rWfanK1z87S/wwBdf7fgaLjzIA//0MZ5bnOH8rec4vQMH33qMhz73IBfN0aNOcuff/iyf+E/2gYYfOnees6fSme3/yPn0eu/d4JTqH+LcrWdJD9/n9K3nOX/rmXSdM+uvfYFf/MIjPFOeSff5xHwO/+BXefyl9zlc5dF/+Bm+8NsXuWL302v07lPoP7vIw1/4RT73+1nanMlkMjeLN8dvJ5lMJpPJ3CROnfoO03RvP8OZ5lEev/RNLnOG0z+408pkMpk3HTu7S4L31HWLcyusMcToKcokXC7LkuWyBUiS4XGa/QAyReKEuI1yKcuCpmnRWrG/v4+1jnEY8T5Jl1OE0oSzlhCh7zu01hSFJsyS281mk2TJUqC1TgX+EKnrmmEYUia+TlP369Wauq4IAYSIGDOlifyqRBclxTw1HkOcGxQOHxxlVeDmMPN0/IJxnICIEBEXHFXdJJHzZHAu0LbJcbBcLpmMQSoIIRXXm7pmHFPB+cgNUeiSsqwYpUrbBYVCCAghpkn8ubA8jiPOWoZ2xBqbth2qEqVrzCTmgnQx+ygmyqpkHEcEKT4ohNTYmIaJY8eO470FkaTNk5nS69avOH58HzFvDpjJzE2NyOHhIc5Z3v6Ov4KZJtpFS1GUTONAiBGtNOMwUFUVMYJEYq1hsVgkV4W1HBy8QPBh+35J4uIUu1TVNbrQ8/2P9H1H07QMw4tuihjTNfd9jy4UbbNM1zg7Gpq2YRgG2nbJMPSURcFqdX0bodTUDZvNGu/ShoVzbm56hbkJkPwZzM2VEAJmMui5qVHVFdcODtjbO8ZqdX17f8oqNXMizOLxkqZt2XQpiqusqm0EUzrmkuXODpv1eityPoqg2mw21HXFOEw348f8FTzDY48fgDzL+983T4GX53jvWbj0jcf56oW7OXvrd1dSWF+DO+77NHe99Jep4XEe+vWLDM1p7vpv7+OOt7/4pYMnfpVf+eIFfvO3zvGu//IcGsfF3/pNLnZw6kOf5BMv2Ry4+nuf44HfvfIGXO+LXHp4PtYHP8F9Hzq1LZwc/NGv8iu/dem1v6lbs/PBT/DzL3n81d99gAd+7ypPPPEMd50+A++8nXs+tsODTz7IwfIcd33sxpsIN+SFx3j06wOc/Qif/vhtLzYhPnqZh//BP+aJZ57im+4s515ya575+jOc+7lPc++7jx49cOHXfomHnr7Il59Yc+79r5zy3+HsT93Dcf0Al64MnLrjHu55rU2E7cPPcufHjqN/+RJXhlP85MfuedkmAsCwdpz7Lz7NvT9+dKyjc7jE40+tuW0+h8v/8p/wyBXYf9/H+e8+evbF6xsu8/AXPs9XfudBHj33ku2MTCaTyfzAyBsJmUwmk3lLs39y/zt89TjHjwOH3+ZPsyghk8m8xSmKAimTVFjPRXilUgRP0zSzpNambHjvt4Laoii2mwJlWdG2KSN/mubImbJCK5UK9VrhXNpOCMEDAu88WqUivtY6+Q1iACFw1qJUmuw3xjDN3oCyKtJEvBAoJVMkj7MsFu1cbHcsFi37+yfQWifprtZYZ7fH8M7RNDUxpElyN3/sfSr2TmZCSMk4jozDmDwO86aGdx4h5exiFiilkVLMMUGBeeEApVTa5BCCGCJqzsU/iuWRMhWZlUqT90opxj4JjtW8faBV2oYIPhBCKoBv45aEoJjvz1GxWs2vtQ+zUDp1VwgxUFV1+l6RNhyOtglCeHH03BqDMVNqDkxj2sLwAWstRNhsNrNkWm6bGsaYJNOe5cnWuu3mg3WWYRwxxuKsYxyHJMgOYW4IpSissqzSe3Ce+J8mQz8M220NpTXOWoqiSL4DxLxFYrDWsV5v0nX7QD17N46Exn3X0TZpC8Ka9B4+duwYRZm8D8MwsF6vWa1WW6n2OE5Mk0muCJu2PrRSNE1DMTd0iqJI2zhlinWKQFXVVFVN1yWpc1mWKK3pu55rBwfJpYBI75+bzaULaSPg7Hs5Vx59UnP+J1Lx+tJXH/vuPVJ77+Y9r5jIWD/1OJcCnPrgz72siQCw/767uOMWGL7+OE8ZIHyTC08PsHcH/9kHX156P/nBj3LHK6Nx/iKYC3z1yflYL2kKAOz/1Y/ygXfe4Pte4/Enz5/nJGwj1N4QAmnj4OAa1166eiBPc9fP/33+7v94z8uaCAD8yJ3c/e6X7j00nL/1DADjG3lu34mzP809P/7ShsVrncMzPP7/HkBzG3f/7NmXb2o0p7nrg+eAqzz2/1wmk8lkMj948kZCJpPJZN7SnPqOY2D7nDwBXBkZRni1kTmTyWTeOvhZdntw8Dx103DkEairmmHo5/z6kKJzZtmtmQx1VWOdA1JOfVmWXLt2DWtT0d7Nz5u2DZJwVsBc9E3RO0fRQCHEFGMEaKUwdmJZLfDezYXxNLlezU2OGGHYbhDIlL8fA4vFImXTz/FG02RmKXJgnEyK8lGpiC+kIPiAd5a9Y7v0fZILRyG2DYZhGFgulrRtkuZ2XYeeGy/WplglKSRSkrYuVHp+YywyBpx1WDuxo3eYzJgaLeOAlBKt1XzObdpiUArm5kaSMw+s1ysWiwUAZVnRdR3WuhTPs21geLQq2NvbYxynJBJ2DuscUoA1lrKs2GzWqFGwt3d8KzmWMkX1FEXJep7oP4oWUir5EcxktkLqSKTru9lRkLZDogCpNeM0zsdKmwVCCqq6AR/oZ8dDURY0db0VfMc5tgoBzqbYn2EYKcoKIZOvoSxLumGgKAtWhyuapk0No+UO02RYXT+krmsWi8W8BeCoqhpdFBS62DaoVtcPWe7MEVsxpOaCtWzWa5RU1HXNOI2UZYXzLomifUAqQVk1KC3ZbDa0bUtT14BIcVtzTJOUgmkaCHMjJ8SItTY1RvqBW95+kn6O0rq5OC587XEG4Nz7zr+8cPCj5zjXPM7jz34PHql3/tCrNju//W9SMXi8+DAPvcZCwYEDuMzlb8Ntu1e4EoDTP/waG6KneNePNnzlj76b6/ou+PYzXL7hsXY4e3afh589ePX3Hd/nhv2MF65yAHyn8ZXvmlvOcf7UIzxy5VE+9z99mZ1TZzj3Y+/lvbee4/Tx1y7xNCdP3vRfY5u9/RsWoK6+cA04Cc99m28PQPOnfPWLD/HUKx84HNAA62f/lDWnb/o1ZTKZzFuN3EjIZDKZTCaTyWQyr0vbthhriLFEEJmmcZbCCrxztG1DWZZ471mt1ywXO/MUvCN4P0/VCzabnmmaUCrJhqdxZHd3D+sMzlkEEWtdEt7OjYOjqW07DGhdzI0GhZAlSqctAGNG0KCLYo6JCQggxECYn2OaRmIEhEADm02XpsaLYhYOqzSR3qamRlm1TMZixgmpJGbeolBS4Z2nqWoKrWmamqapkUowDhbvUj4/IjkUzGSQQtA09ZylL1nutClCyTukFFs/QJzlv8B2E0Br/RLZcNg2El7652i6PoRAXVcoJYGIknqWX4Oav19KQYyKEOK2kVOWJT745HUwjtXhGufs7HtQCJHcDsMwsLe7l6KDqmoWOjvKMkmlpVLUVcUwpkiioxijfhiQQrDpepSQ20ZEUZaEOdIqhID3DuXl9t7XdbNtyCT/hcJ5l/7XOZRUWJs2GKSSCARFWSBEeo/Udc00TiyWC0JITaSjTYW9vT36roeFoGkaur7Hz3FL07xpUpYlWhfo2atRVhVt03J4eIj3nuVigY/J/VCWFdevXcfPTZt07en7jt7zR9sWZVlSzZFHg7XpPKcJQfJXGHeTo43MUzz1jfTXI9Huqzngia9e4q6Pnn3955M3Lj0cfOsCB9+60VcHBgM8nwrxN2Jn7w0sKZuBAdh/2w3K/je6lp2dGxe2La/yFnz/nOQD932K/X/xIF+6cIX1s5d47NlLPPa7QHmS2z7yX/ORH3/5ub+hr8/3yXc8B2tf/vFwhUtPfoe4qi7do5t/VZlMJvPWIjcSMplMJpPJZDKZzOtibJo6L4oCIQVt21AUBc5avLM0zS5CSIwZqcp6G/dirU3iXyVRWjOOI0VRslgucNagtMKYaS7gpqn4ECJlWRO8JwSH1C9KlpXWSCGp55ihGCHIiJSpsLyoFhSlpt8MOO+wdkQXJcF7Ypwz7UMgzrJmIltJsXepcD0OE86nwpYUgqpKuS7TZGZJdIEZDKYocN6ys7PEGsM0eSDFOQlBEhQDltQoCAEiEesmYGcWIwd0WeHjyGQmvHNz1r4mhBGtNcvlkr7vgYj3gWkYqOsU+pEaEYpyjkhy3iW5L6mpoJTCWpuux0ZC9MSQvBIImFYTTdMkz8SY3BFjPzEMK+q6TLFJpOl4KSVSKax3DOOIjynyKvhAVVUIkWKLlC7Y2ysYx1Q017pAihQ1FAEfPF3X0bYtSko26/VW6Cwls+ei38qWlzu7lPP3B1JjKMa4lTUbY7aujBgji3bxYmNhdh/s7u3OromJaZxeJmzuNh1CSLpuQ93UICRd3wNQzJsHTd3Q9z3WGPS87VAUJXvHjrFer+eNk9RsEUhWq7QlIpViHEe8dyyXx4gx4pyjrut07K7behWKomCa0v04agzdLNZ/9BiXgObUWc6+4zVUwNNVLj19heHJr3LhZ85yvnz1Q747dl7tTngt/vwk+3DDZkKKxvnelMU3pGxogIPnD4DvZt3iJqD3Of/RT3D+o47hyre5+I2LXPz/HufSn1/l8d/4FWj/Lh/50Zt9kn8Bzn6Ev//x23LBKpPJZN5k5P8uZzKZTOYtzZWrwA1lbQdcfQHgODt7P7BTymQymTclQ58mymcPbXICSMnQvxjjI2dJbyrSeuq6TlPtMsmGY0gRPQcH19B6jxhfnNyPMc7T2imGSAqJrjTGxDnaRtG2C1arNVor2rYlFdZn7wBJPOC9QwfFNE0pFClGyqJA6wLnLEUhUrHXpU0B3RZp2t47ECLJdoVACDVHHtVUVdq0iEfOhnlDoO87rHOURcr7V0qhlKSuG4L36dpn50JVVXifJv4liq7rMdYy9D07OyptLpiU92+dI0YBCIrZ1+CdY7mzZOhTlniKk1oQickfMfsq7LzV4XzK3y/LEuctziuOYnaGYWCxWMzOBDlH/Rj0HAcVYkQpiS6KFE3kk++irmtC9PTDgC4KYgysN2uaqtlmwPuQrlsIvY2O6rtNajq5FLdkTLo3Ifhtwdw5h1KKum7nYrvHe0fdNCgp8TFuo40EEkTa3LDWsrO7m6KJfIrWSve5oBBlkjmXJUPfzxsnhhADWmj6vk+NA5jl4XHruTBzxBWQhMllSd93W8dF07RYa7HGMg4DZVlBjGhdEEJI10bcvi5FUW63X5yzOJe2bo42I2KMKK2QQmKtmyXXN4srfPkPrwD7vO+jH79BdNGar/zDz/Dws5f48h+tOf8ffe+z4SffcRK+fpWnL17hrtOvPMgVHv7Fz/GYO8td932c2285xSkJB//6EpfCOc6+TCGx5tvfWvOGNRJ++DSneZxLl7/NZc69It5ozaVvXH1jjvN9cvC1X+Uf/e4znPprv8DH36dpTp3htlNnuO2Dd7P+g8/xmd++wrcvX4Uf/Z41zjefEyc5KeHqH1/korntVQ0q9+Sv8nd+6zL7f/VePvUzZ27OOWYymcxbmDeBwSmTyWQymZvHwdXvtCj/HFf/DNg7ydu/70m7TCaT+XcDrTVCQoieoiwoyxJIxc+jPzEEmqbZCn3lS+TB1hjMNFEWGqUE0zQCMI7jLGxuGfphztT3CJUmySeTnAlSSMqywhiT4pNWKVrGeYdAEKKnrivKMhWshUxNj6JIkl7vPUJICl0QQ8C6VIR2LhWWF8sFWqfomaJIsTQ+RCYzslgsUsEdEFKgpKCq6uQDCBEzWeqqoa5bpFQpnqdQWOvouz4VlUPyMxS6oFAFxti0XWAM3WaDALpugw+ecZySa0Km89lsNqwOV+lGCFgudyjLFBuktebYseM455Jf4qgZEpntEoGiLGkXC4yZmKZxu72hlKasqm1szzQaBHKOBhIM40QErLNpY8Q5fIgIqRBKEUmbKkHE7eOMNXRdx2q1JsTU6HH2RYl1iAGlNXVd40OY70sqmldVTYiRvh/ouo5xmlLU0/y4cUgSZSUlVVHN74mSv3Lq1HbLIMaQvBYhMo4j0zSBSD6KzWaD96kR5FwKmokxsrOzs42DShsUOsmbvWcYh6PeGULI5EQIgbZpCD6w2WzYbLp5G8MCqXG1u7dLjIFx6PE+NdWOnjtGcM5jnaVpWpTWtO2CQhdUVTlHXL0ouP6Bc+Upnr4GHH83773hQP4Ot78/RRpd+cMv8x1CaG7IyffdzmkJB3/wRR658vLgn6u/90W+cg3ciXdx7jggz3H7+xoYHud3/uVlXqoHPnjiizz67PdxAjeifC+3vaeBw6/wL373yssiidb/6ktvwLEKtATMwPh9fPf+6ZMUnePS//0oL3/ZHNcO0jMeP/6G2BjQc4yTHb6bYCYNBYBNcVTfD0f3OVziS//8AuuX/hgMF3no4Uvg4MyP5SZCJpPJ3AzyRkImk8lk3tJc+dYzOG4gf7v8r3kmQHP2Xa8h28tkMpm3FklArCmKEiEE/djhrGVnbxczmVkELDmao44xMk0mTYAHiZQK5jia48f36fsBoRV1U6evzWXvNCWf4ngEcVt8PZrWT3n+1dYXkDL+JYtFixAS5zwhRApdYDFUVUmMbDP2lZJJ4hssSqXpb4gUxS7jOBFDRBQCpdUsxy23xxJCJSnyYgelAsM0bGN2qqoCwSyc7lKcj5JEGzDWIoeBMBehnfNIKTHWpu2FGOdGQ8T7CSEkQkT6vicGP0uXNV3XE7ynLJJM2jpLWZeA2MYXtc0iFb4FjMOYYqKqkuBfdE5UZXpNirJIWxU2CaMFAu8D1likVmzWK5p2sX39jLEUZcFyuWToe8R8n42xVGWF854QI1pp+r7bxvcUZZkK90JgrKVQGqXS9H0ISdxcVVWayJeC9Wo9NywEkzHbor/WmqIotu+vGANSKdbrNdYamKXcO8slQz9hjEVLlbZn5uaBUhrn7CzwFrOfAoSUMO+1HG1HQIpzIqbP7ezuEOcGRaELIhGlNTs7O0il0nt+HAk6UNUlSkqmEGZpdGSaJowxjONIu5Dgkhw7xoiUAl0UOO/RhWa9fkVm/A+QS199ggPg1H/4k98x2Eefv41zX7zExWtP8Ngf3/W9R+ns3c7PffSbPPDPLvHo536Bx3/kXZzZ1wx/epFLf+5An+LOv377Ngf/zIfv5fZnvsBjf/B5PvP107zrzD52fmyzaKD7/q73Na6Mcz/7Ec79yYNc/L3P8QtPnuZd/97RsQqaBX/BY93CyXcAV77CQ//bmtPvfC93/dTZ7z7v/9RPcfetT/CrTz7K537hcU6fPcN+5Tj4N9/k8jUHp+7krvNvTKln/x0ngStc+j8+z4N/cpIz77+H2995w0fzQ+8ArlziX/7jB3nm5Bl+8mO3f8/hUGc+/HHuePbzfOXrD/GZS49y9twpmumAZy5dZu1g59aP8NN/mWObMplM5i8xeSMhk8lkMm9t/vgiF28wNXX1jy+xZp/3/USeespkMhkhQc7xQtNkGIaRuk5Z7mVVEUJgHMd5CjxJiaWSGGvmgniYY2ySHBiRpvv390+gi7S9cOz4Mfb2doFIDMlnoJUGBGGeiJdSMo7jNmteKklVV2ljQgiuXz+cj5+y9lNcTkUMEe88SultYV4ICMFTliXDOKZJ96pEzpsLWmsKXXLt+vVtZE1dVegyyXdjkh7gnGUaJ6YpbUv0Xc84Djhn0YWeRc+G1eGarhvmwjIYY1G6ANLEvHWecTJbefBqtQIEZVFSNw19P2BMmnpfb9ZEUoF6HPtU6J/MdmNDCDE7AUaMsfRdT6FLmnqRNjOKghAi1jmGcWIcJ7ROGf1HsmHnPeM0ASJtcDg3ewnsHIdkGYf5npsJYy3WOcZpZDIW7z3ESNnUTM6mhoqUyeEQImaa5g0OP8dhGcZpouv7lwm3U/PFoefmzpFP4Ojzz129mq7FWkAk94JOUU5KKZy1FLqYGwSSpmlYLpdIJdP5GsNqvU6i7vl9enSNycuhcMEjlSLEyOHhIVKrbQOirGqUSu+/CGmbYn79irKkqtPPxzCkjRspJWZKUVhFkaKrJmMYhoG+67aS7ZtCuMjjTw7AaW778dcpbctz3HZrAwxc/FeXvq/D7dz6cT79t+/h9h/Zxz17kQtPXuDSCwWn3nMXf+PnP8EH3v6SB5dnuPu//xT3/MRpdofLXHzyAs9sTnLuw/fx8fe/wdrd5hz3/g/3cdd7TlGs52ONp7jjv/okd//7ADsc/74Puc/tP3MHpxeagz++wIWvXeR7C0vSnP3Yp7jvw+c41QxcfvoCF568yBVzknMfupdP3fcBTr5RlZ6zd/KR9+yjhytcfPICT11ef+eHf+gjnDuuGZ69yIUnn+Lb3/nhr015mrv+5qf5Gx8+x6nqgEtPXuDC05cZdk5z+8c+xc9/7NwbFWKVyWQyme8REW+2xSmTyWQymZvI37v/fk5/7O/z8VtfObmVsnm/sriLT//NO777KbFMJpN5Azk4uL79+/7+sZt6/P/rdx5iHAcWi2XaJiDStg2RJNw108RkplmUXM7C4SSdjSFlvh/f32e93uB8ysZXUrJYLuds+ST/NZPl+eefp6oqikJTVfVWimutxVqH9462TRn/VV1unQXGWPp+RErBsWPHcN5hpom9vWMMw8BmvWaxXNIP3TZT3wefIpNGQ13XNE3NtWvXKcpyjpdJU+9pWt/PU/EVIUZeeOE5lNYU89elkmmi3zqkTI9v2hR3NPQD1w9XVNWLRfCDawdUVc00juiyoOs7Fu0Ca9LUvvOOqixom5au7/A+UlVp0r0feqo6CamrqmIcBrQuWCwWtIuGg4MXWC536Lt+6yE4ki8bY2kXLcEHhjFFSSml8c6nLRJrQCW5NCK5GrquS5P3UszNgIKh7zHGUNU1dV1vRdpHLoHlYpmutywZhiFFMSmFEpKh69J2SVVhrCFGkFpijGUYBqyxLHd2KArNO265ZducSo2hGhAYm95vIQa0KtBKEmPk2PE9+n6i70e0VmiluX79enq/VBVVVaGVohu6WQKe3AVHkUJyjjgqi3JuYCTHxWq1QivNanXIiRNvS5snRRJJp40Nw6Jd0PUdWiuUUiwXO8kBMjcShBAUZYk1LwqstVapuWAMXdezXC4JIfDf3PepH/jPfOb1ufBr9/PQ06e4829/gg+cuNlnk8lkMpm/DPwgfqdPAyj/dskbCZlMJpN5S3Pnj8Cl3//yqybB3NOP8sS1htt+KjcRMplMBkBINbsDAsvlgrKqEDIJeZm3D4qioK5rYgxzdEyqQ4/DRNsuUFIxjlOK3JlFuavVOomRY8SaFJFk5o/LstxGEYGgaVqKomC5TAVMks+mAAAgAElEQVTtqqqSW2Cz2Ypx1exW8D5FyggpiUTqukZIQQye4AMHB9e3cuh+HOZ4GUlV1el6pKAsi/Rczm/P0ftAPwyM00Td1JRFSVlWOJ/icKxLkTQhBKZpou8HptEg1YsbEM5ZQvBopfDObSfppZAIIVFKgoCyKLfS5iPJry5KxslQNy3TOHEUpX9UZAeoqnLbVKiqCiHkHLWk6Puertsw9Glrwvv0eggEwzCmjYYQiAhCDBhjmaYR7x3WGvp+eHG6fpzwPiBmQXAIcZZuK6RUjNNIhHkrIjky9nb35m0VRbtYUhQFu3t7dH3HNFnCfM988CCSGDtEj9JHQurkjBjHYb6/IsUVeUcUoIskyd5s1oTomcyLnoXlcplcC+OI955CF5RFiRCwWLQpXkkp+qHHeY+dY5WstWidvBG60Bzf3+e5568yGYO16d4Ya+nmOKe6aei6HuIsGZ+jr1IDhG3k0zRNOO+omxohUlOhLEukktRNnrm+eTzDb/69v8Pf++WHeeYVyyHuyiN8+RvA8TO8KzcRMplMJvMWIzsSMplMJvOW5va/fieP/y9f4ZGnf5J73330z+JVvvx/XoT33JszWDOZTGam7zvapsYYw3KnwpiJcZrwztO0DWYyVFU1R7eIlKEvBMxFVK01wziidUHTNMQYUl78MKCkYJom0sMjShfbvP6+X2GtoyxLTrztbQghMNZgJouSHjFPyL9UaGtMmqrXRYogOor6WSwWFIXGhcCm61NcknUgJe2iRWtF8A4l5bZ5oLWcI40aJjMSmQvXztE2Lc4lkXLf9+zu7SHHEa30XCxWdP3AZtNvs/2nadpOt1d1k+KRRLr+oyK3FAIfPYXWsxg5NR2OBNHWOZRWqdgcIkTmKfaIc5bVaoXSMjUMxnE7BR+mgJCSEJLXoCxLQnQM04j1HmRqHkQg+MA0mTmGKVAU5TbuB8AYg3MWQRJnW2Mpq5LV6hAhJG3bEmOkaVrW69UcF2QYhh5rDMeOHcMYm/wHSr547UrODSQ1+zaSk6Ca5dIhxFncnBwFUqm5ORPShku7mCXN4OYif13V7B8/RiDivU7bA9ZQ1dW2yTBN0/Ye9V1P0y5w0W6voeu6VOSXavYqyK2Ue5zF4WWZmmvFLJbWRYGQEhmPGiwyXc8wzM2j1KTyzic5dQg0TYtWybuQuVmc4bbbdnn8y1/hC7/wNKd/9DT7FbiDZ/jmt9Y4uc/tP/tT33P2fyaTyWQyf9nJjYRMJpPJvLV5+we454MXeeC3f4fLP3YXpyWsv/pFHunPce/P5gzWTCaTOcLakUEkmazSR8VoQwgQNimmpm4k02So6wpjUtRL27YcO7YHEcZ+IIZAWVboeYPBGAsxslmvWS4XhBAodMk0TSittiLgSGQaB5Y7O4zPDzjnGIxBFypl4s+T38vlgr5P2wTBB8ZhxOpUJC7LMsXoEFnuLFPjIkS0liitGMaecehxzjIMIwjJzk7Lzs4eUkq6oSM6j5QerSTTmCbu1ZzzfzSdL5XGh4guSoQYcd5up+khzqJgsMbMYmTxkgaIQyuFVopCa4gQQnJLSKkYx4FxHFBKIoWctxjS1yYzICVMUxIRF7rEO5dig1SKKUobDzq9rv2ArkoQAusdZVESbYrp0ajklQgh3bO22k7MHxXBY4xIleKrnLUcU8cx1mxjgpRK5zYMw1a0vVmvadsFAOOYCupFqJBSoctUyC/LktXhIU44ikKzWm0oy4K6qufnTEX5uqnnuCDJOE4IYGdnh65PGybOOHzwRO+RpWYakxBcRZ2+7l06V6Xoup6dnR3qusb7iJKa4B3r9RrvQtqAqWvKssBau3UsdOsNRVnMDQ6FMRMATdsSjl67omAYhtkFoen7fpZDwzAYQvDbRpL3Ydscy9w8Tv/0J/nUOx7mod+/wJWnL3AZQDeces+dfOA//UnOncillEwmk8m89cj/+mUymUzmLc/JD36Cz37wxY933n8fn33/zTufTCaTeTNSVUlcbGXK2HfWbaezU0Mh4EOYC6ApIkjrAqUUPkaGOS5GK8Xq+nX2T5zA+8ByZ4cYAkUBIc5xSFJQlRVCpJgeZw1lUTKOI2VVbY+bRMbFNtbn4OAFFoslTdMgEIzWAWDN7FhwDmMdYfYzpNicSAzpY6UU0zTOmwqGsqzRqoCYopK2f9xE05QAeB/nwq9Kgl3n6fsVdV3P1xxwziNlZDJTimDySejbDyNijlcSQiKE4qjR0Pc9hS4YhjV13RCCp25qQvApjih4pmlESYUxkX7ogMiJEyeS2yBGvLe0bUM/DKxWh7Rti3UpSsdZm6KHnJ2FzRNSSLx32+dHAJH0PVEQfHjxXs+RSGaaC+dzFM/R1sDR40AwjiNaa5TS84ZDkkXbObKpmqXYVVmlz83bKm27wIeQxNikJkgIKTbrqOgeYtrIKIoSKTXDMOGcoyhKnPW0dcM4DdTt8dT00ekcBOCcBwRFkTYgxnHcuhEEoLVib28Pay2H6zV7UjJOE1KkRsE0Ji/Izu4Oh9cPUwyVtazWa44dO0bX9WilZl9G4PDwkKZpqOuKYehnD0jBNJm50ZU2ffqu57q+9gP9+c68Es3+rXdz36133+wTyWQymUzmTUNuJGQymUwmk8lkMpnXpW0XBO+JdWQYBkKIxGip64aiLNms1wzDQFkWOOfY29tjGNLmQAieruvQuuDYsT1eeP6Aa9evYYx5UZ4rUmFfKY3WEe9dihoKgXa5QEm9nWhXupgnx9OkuHOpqOycp+t6dnd38D4Vwqu64vD6IUiYrEVpTd8PSKAqS6qqwnuPmyf3nfP4EBFCsdls2D++zziO2wikYF2S50bQWjNNA1VTpyl/49C6YBxTMTs1JUAKyWq9piiKOZaoIMwOAoXEOY9zE3VVoYuCcegJ88S88x7jDN4HyqqkKDTMhXQbLKVOUmhrpySeVpoxTjjnGcZDyrlIbm3ashBCoLRCCkHYbBi7jkIXjONAUaYYqBgDfT8kYbaUTONE2/o0Wd8PaetAK6w1xBgpyrTVsN6sgPTa9F03i4Q1IUSUVmipiESMTW4BKQXRQ/CesirROjVynIDjx/fRRZr+jyEi5vgjrTUxpKn95w+eRylFWZTUdYPWCjH7GYRM3o5jx47R9x1CSqqqoixrrE5OCuss/ThgjNluAIzjODfHJpQStO0C5xzOOzZdR1WW2+iro6gnKdXW1+F9ilKq64a0RZKe1/m5qWVTpFRZVjjnaduWaTKzz6Lm+eef255HJpPJZDKZzJuJ3EjIZDKZTCaTyWQyr8vQj1vp7rWD61R12hgoyyoVlssSKSVN0zCO4zzdP6GUQkqdRLVaMwwjTduy2WwQQtJtOpTS84ZBBSRRsXceUScRblmU8+cj02Qoo5jjgSKbTTdP6TuapsU6i7U2bS+UFVIphJaEGDF2QpgkY9ZKs1juJPFzSJsCQgjKsqLv+3lqfJi9DorJTviYXAsplkkzjYYYAtHH7RS894G6bhiGHmOSpNdYs/U0HImV+65P+futwlmbJuy1JsRIiJG2bRnHkaIscT7l6McYZz+DxxiLkjLJhoUixgJrfXpdpaIfJmLwxJg2ApQuMNamiKlxJPrAZr1hshO7u3tA+ryzLsmOnSeEiBCCCKzXKwqt8SEw9D1N2xDmbYH0/ugBQSRSFAU+eMoq3c9F2xIJ1HWNmSactdRVhTEGrZPceNG2ANRVBQKkKnCzuDoKiERCTMcL0af32TTOzR+L1gLQ26aQnOXg1tltQ8I6R4gj0UciERc8dVURQ2Sapjm2Kd2roijo+hEhFLootnFMi8UieT9mYXLbthAiZVGy3NlhdXiYti+kZHd3l/VqNfs5liwXS55//vm5qZbcDlKmn5N2sUjxTXWNEGKOs8pkMplMJpN585CDFzOZTCaTyWQymczr0m0GvIsURUXyA0tiDGw2K8ZhoNCa3d1dyrJECMFms8GaCWsmjDHbIvrBwQHOOrwPVGVNWSbhbV3XeGeRQtA2DV3XI4Rkd3cP7/12sttMjmlKxd4QA8PQbyOFjDFopZN3ARjGkXGWDS8XLVKmeJ62XbBoF8QQCT4QQmC5XKaivJLs7O6ws7vkxNv2qeoKpfV2c+JIyCulwhhDWc4eghBYrQ4ZxxHv07kcORP6bsCaI3FvuraDawfESJJEz5FFzqe4IgT4EFIDIaRNixBTEyW97pHD1Ro/R0GtV2ukVFjjuPpcKlQPw4R1nr4fWG86iqKkHwbWXUfX9UmUHcEYh3Oeqq7TFLxgLnBrrPHbho2ZDCFEvEsbGdZa1CyCnqYJ61wSJ0dS8yGmQvh2A0KqtKGgFFpptNI46yirKjVEIkQfEIj0HIAxlnEckErhQmCcprTJIARmMrR1S9s0lEXJYrFkmka6boNzDu8ddVVjjMVax3q92YqVffD045AcGuM4N2gk05QimOq6RkhJaoykBlbaeNBM05RE2vN9mIaRcd682azX87HTtsJR7JP3afMgNQfSOUipUuPLWtpFi5kmuq6jKApCCClaKpPJZDKZTOZNRN5IyGQymUwmk8lkMq/LURTNZCaWyyXtosE5Q98PlGVJCIFpHDHWoHXBZrMBMW8CGINAoHSKunE+TZSXVYkuCvp+g/dhW8R1zrN3bI+iKNFab5sTIViqumQaR0RVUVUVVZVcBEfNi8VyiXeW4AMuBJqmRUuFUppFu2R1/TrBWVRZ4l1ASImSisPrh0xmous2tIsWKZIsWErBNI20iyZF4AiBmOOUpJRzgX9isVhy/fA6ztkUDTT0eB9ZP/c8xlq6vgMhZgm1ZbFYYmyKdmqamqqu8c5RNw3TOFLUSQIcQ0BJmWS8IWDnzQfrHOMwUBUFh6sV0/y6ayW5frjCO4/zyQcBgtV6zTgMRECKFEtk55gmYx3lfG5EgbVunuoXLBdLxmGap/512jQoCsqi2G6cNHVNLCPWpM2KaRho2lQkt8aglERpjTXpviipkvhYSjbrNWWVmknOOcqyZBgGjB1m94VmMobF/Lp456mqFMFknaWsKtzsSrDOE0LaCLHWYn2KEYLU+Nk2buqGSEybA07OjzeYWX5dlCXXr11DSIkxhnEcqao6uSxI77MQIuUcVSWVJLjU1KrrBiFIcUpCUtc1169fI8RADCQnRoRpmmiaBu89TZvOd7PZbH0KWbacyWQymUzmzUb+7SSTyWQymUwmk8m8Ll23SVE2SrFYLhAiCW6bpqUoCuqm5tq1a3gfaNsWM4uFY0iF7MViSdsuqKqKxSIJZ6uqTEX0qkYpSVkm+WxRFuzt7eKcZb1eUxSpmZC+p6Kqk5S2rmsKrWnbBVLK2VOQJuelknNmvWexTEVt71IRnBix1qAKnR43T9BLKanqOvkSgBgDXZ8m2b33s5A5uRxiiBRFSVmUdN2GyaRCfyTJiZXSGGuYjGXTbXDOs+k61psNh6tDJjsxTiNd3xFJGxlSa5x3jNOYCs8xJiH0/Mc6wwsHL6RmQlkyWcsL165hnGcYJ/zcNHDeM04j602XPu8D168dYqxlGkesS0XrzWZF27Zs1iuuX7tGDDCOBuc8QkAkzD4Dg1RqGy2URMceBWgkIkTqomR3uUQJgZ0MpdaYcWCzWW8n9I+aGsM4IqSgmeOBlFSUZUlRVAzDiLEW5+y8GfHivWmbNkmcfWCaDP0w4JxHKcVzzz/HerOmbhp2d3dZLBYUZUm7WAKC5XKJ94FpSs2i1JAoqapy6/WIgJ7lx0ImsbObY44Ekd2dHcqyoOu6uZHh2NndI4SAEAIQ8+ZBAGCz2fDcc1cRQrJerem6DUOffBvrzYZxnFBK88LzLxB88j5oXeB98mu8ObnKo798P/ff/yAX/20f6rlHeeD++7n/1/+tH+lVXPz1+7n//gd49Lk39nnXzzzKl7529S/2JO6AC//sES69Maf0En6A9zaTyWQyfynJGwmZTCaTyWQymUzmddnf38eYicVigXV2m6dfViXjOCGESNP9SrFar1gslunjGBFSzILikCJxlELrgmHoiRGkEDgXiDHFAYUQ8N7NBWtHXVdMxjBNE9M4URQFxhiMmVKe/xxfk2JhPG972y103RqlNCEyexRi2gRoG6QQrNcbqjpsHQBSaYZuQ1EWdP2UXAxlxepwRdM0SJ+m5Z3zME/PW2tw3lFVDcamc7CuSxE48xbGNI1IJEVZ4oOHIFg0S2IMNG1DXdVMo4UYkr9gGAk+MPQDTdMS502P5XIH5yx2tBhr07ZGUWLsNEdNKbrNQPRgzETXdwih2axXW3eElDI9184O1nqsSdFHKRZqQEkNSJxz1HVBVZesD1eEENGkOCFIkUXeWqSf2FtWDENHJAmJhR/RUTAMIz5GxnGiquvUVJol0YGIjxElxVYEPU0TMYJ1NjkRAnjrUnFdadarNcf2juHDxLrrqKqKECL9MKBU2jYYhwHvXRI0x0jbtLO7gTlOKDWrktQ5RW6FEIhxoO97lNbbTROlFH3fp8ZX21JovY1GWi535r/7+TlLvPeUoqDrNkDaaiit2zapUjMqoHVyP9RVjbWOEMK87SAYhwHVvrg5kfl3jG88xGf+6QVOfujcX+BJDnj087/EI1fOce/H3rAzy2QymUzmuyI3EjKZTCaTyWQymczrIpXaToabyTCNZjud7pxltTIURbl1Erz97W8nxsgwDOzvn8B7zzB0SCmxxhFDpKwKlNJ0m56mXeBDkuZ67+m6jr29PWIsCCE9T4ywOlyhdYFUksPDFc65bTG6qiqcswghkEJjzESIkXW3oakbiHH2CaTFbDu7FtpFy2azZpomkIL1Zo0AWh+w1iGYGM3IiRP79F2HLvRWBOy8JxLZrDcoXSQx8WZDjKDmTP394yfYWx7bRuQsl0t8TE0SiFs5dYyBuqjxdRIz7yx3UyOhSI2apmiQQaGYkDo1Y5TUNEXaCjGTTTFEPiBEgXMe72HT9UihCMESo2QcLNYEpskxPXdAnKXKIU44m3wMkiUEtuJiO1k629M0DTEGCIZdPXFClazZEOyQRNfdmoCmj1Aud/GzONuHgOp7Cl3gnWOcJiaTZNV2GpM/oSyxzlJUFc6lWKboAs46FDD2A4vdXcwwpO0PISjrGuscxkworTk8PEQJMYuTLcPQU1X1dmvgyHUxDAPHjh3j4OAFpinFQiHg2rUDmqbh+vXrW3F4oTVmMkki7UN6n3nHOA48//zz3PK2E8QwYbxLmxxz06AoNCHAMAwsd3YJIdBtNnNjAUJwlGVLXZc4Z+eNiXGOY8qyZW75AJ/87Adu9lm8cQT3BjyJA/sGPM1rcpIP/K3P8u/QK57JZDKZN5jcSMhkMplMJpPJZDKvi/cpTqfrOhbLRcr0954YPXVdYayBKJimaTstbqaJ3d1dnLeYySCEoixK+qFnsTyGlGmLAUGKGtIS6+zsWdAYY3DOpa2DEOe8fYUQaUr9aEJ+f3+frttQliVKKYZhYLXZoKRCK0VV1BCTNFcplYr2IW4bI9euXQMiQslZghyTYFkrylKjtSKMkb7rU2Fdpf8b5YOnKEqE0vjVirLSsxDYoZUieE8Mnroo2WmX1EVFu1hSVg3j2DP6nhADpa5meW9Ai4goBFVZsbOzm2KOXCpOCwRtvaTUDVKl105Kyd5ijxAjXd8zTgNxLkI777bXKYREFyVVVWOmiWFI8TwxhO3XIwHnHUpqju0dR0hJP2zmzZAAMaC0IkbP2+qJ296x4m1tpDf7HI4NSvY0ssDIht96yjFMI0WhgYgUyfNQlmXazvCeCLRVRZi3JUIIOOfQRcE4b55IKdCqwBmTIoi8ZbmzwziOLJdLiqJI2x1VRV1VyROh9bxpkLZbxnFI2yoxEH1q/kipWK3WdF2PlAqlJEKkbYzVak3btlSzCPwoXura4SFKSoqqZJwmnHMsl0s2mzWFLhjHAa31LK7uiQGcDyilcNbhnKUoitmNELDWMI4Dy2VL122w1lDXFUWhkVLcrB/1TCaTyWQymdckNxIymUwmk8lkMpnM69I0Dd45rl+/RlkVNE3LOE5MUyoC11WD1pqiKGmbBiEkRVGitObqn/8ZRVFSFAWbbsNyucB7xzAY9vaO45xjs9lw8uRJum6DMRNSKrxPheVpmqjqCqX1/8/e28dadp33ec9aa3/v83HvuXfukEN6KHkiDyWNVYoWrdCI3JiyZFg0INtSBaaR66hp2kBo9IeCGG6lwnJqIYlQC6kbqEZUQEFCw0wjGVVh2jFV0ajklIIp27Q1ijlQxiSHM5cz9+Pcc84++3uvtfrH2nM5pD6GJGDRTvZDDDBzzr778xzg8n3X+3sYjUd4XkDXdm6l92hE27oCrStUh0RRxLOXrzAajQkD1zgwRrNer9nYmKI8jyiMWGfZ81MWbYuwTr7cVNWxWDiOYxc/EwRuykB5ThjsKfIip+s0VkiiJHF+hLalaRpUHPUND0UURPjKQyJcIyUvqOvSxdcIi7CiX6Huiv6Bp0jjlK41FHlF22gQEqzuGwPCiXuBMAzxPNecQYhjKfD1wjy4WB+lJFGU0raapqoJgwhrDcKKfhsLCrCGMIiZTmdkeUbgxxipwXfOCPczhu1U88ZbSk5EOUfVjGUTsRF0bMQluTH89hOWZWWZbs3QXYfWHaPxFKUUKLBYgiDEaE06GjvJcl3jByHWWDzPPbcwDI8bSJtbMxarFUIIfM/HGsMoTWn6yZiiKLDW0vaOhaLI+3tqMCZyn800RQCkCUdHRyyXS8IoIokTwOD7TvYscJMxUkqqyk1MlGXJeDwmz3PyPMf3vN5/sGQ0GhGGzq8hhcTzFYcHc5JkhFTqWAguhCSMPKoqJwgC5vM5k8nYTcPA8QRPmqavwrf8RRw9wef/9SM8fmlOZ8A7eY4f+6kf/rabd4dP8PC/eX57ghmn734nD/zEXcxeUHnomP/hwzz0hce5dORW6XvpDqe+/74Xbrv/KJ/85UfY+/7384//Zh8H9PUH+fl/dZ5zf+PnOHv+f+fzX8voghlnf+K/4QM/OAMgu/hlPv/bj/Lk5ZIO8NJT3Pkj9/PuHzrD+MWWyPISX/6N/4tH/3SXsgNvepp73vUAd7yc+5Rd5Mv/98PH+0B6jE/dyQ//+Lt525kx4JwLD37Nbb73hU/y81+AnXd8mA+/fecF+/jShV2yxr3kjU9x539+w3lfvx9ujzz48z8PnOP9//j9nDs+lZdx7d/EHo/+8id5ZP+GffbH5B0f5kOvv8hDv/FIv2+P+PY7ue8n3sPbXhO/nLs1MDAwMPCXmKGRMDAwMDAwMDAwMDDwErBYDBvTKRuzGcvFEmtd4TUIfLrWIKXC8zySNKYoSox1+f5SKZq6IY5TTuzsoLsWz/MAQdFHFvl+cBxPJIQgDEPquqEqXewPfSyNRND1smE/CDDWUhQlApev37YdbdsRhTFCOLEvuMK673t9Nn5N27QcLY5QvWC5aRuiOMLDyX896REGIdlyhVQeFlBSgXQSXSElINDaUDUVXddB70TQWqM7TdWURFGMFPL4HNbrjLppXayRAHE9wcba4zQbIRVFWVK1DW3Too1BYLAIuCFvH0Abw/zogK4XPdM3RnxfYnuXg4vS8ciyjLIsadv2+JBSSqwxToTcGifR9gIOD/YpmwprbX9u7rjGWoQ1tHWD6EqkWRNbhe8vSFWBpxuUjZFEIHBNFaWeFzhbd5Ft2yIQKCUx1tB2130BIVVZMkpHSCXpOk2nNZ6n6LqOJEmcjyAM8ITEauMK+tYSx66g2TQNnueaEHmeE8djdwnGYrTzbywWC5qmQUpJpw1FVR03lfLceS6UcvdGKtVHOtnjKRnn8dBukkYpQBBFAU0j6XRHnET4vnMmRHGMUuo4yimOI6RyDYq4F5OPRqO+CdKRZWuapvlz/j7fhGuP8iv/6yPsGo/xa85xZgbzi0/y8K+eh29RkC6//iCf+FfnKbm+vUd55TwXvvIQn/j6k7z/ww9wrq83733xU3zyC7t46SnO3r1DTMf84pNc+spDfOLSnA9/6D52bnJ6u//2/+B8FnP27jNwZY/bbp/1+/4VPvmFXZAeO2fv4lTq9n3+Nz/Nk0+8kw998D52rp9/eZ4H/5cHOZ+Dd/Isd90WU145z2O//gkeu2nR/YZ9/NMHOV96zE6f4+zMg3yX8984z8OfvsiVn/0ID7zeY3bmLu7KLvHE03PiU2c5e0vM7FT8Le/1Xcf72OX8b36ai3t/h1/46TMQ3ca5u8/y5J9eYLeccfru08y4gxnX7+vLuPaXSbf7CJ/64nn2pqe58+4Z7ZXzXLh8nod/dY/273+Y+068sv0ODAwMDPzlYmgkDAwMDAwMDAwMDAzcFM9z3gHP8xFYRuMRVemK5lJI2rZCa4OQ9Fn0Hta2tG2Lp3zqsiHwA0aTlKP5nCAM8YOQumwQqVvV3XUdcRy7vP+2pSzdqv0wjFBSoqR0ETHa0GlXhM3Xa8bjCdlqhVAKrAAEaT+pYK0mSRIWiyOEkARhCNYVc+dHoI3F90OapkVYQRzHNFWN7rq++ZGQZbmbiFDKFd6tK1ZrrRmPx3TGuRTcyneLNYambUiShL2rV+k6J/+t6oqmbTHXGwZ9e0CKXkZt3JhB03WUdY21uo8pshgrkFIhpIvfuS6JbhrXbLjeFDDG4PnXxcC2L3gbN4nQNGjtzhMkAhcr1WkN/XGkFORF0bsStDtLIdy++ygkMFjdgdYI05H4GdgGJRqEVQgbYbXA8xRFnhPHLiaobVviOKYoCuqqRghJkk5o2xYpOH7undbEfYSVEAY/DNBdR9H7N+I4RgBB4D6LUkmicETVuImGfJ0RRxFB6J6rUh5d21KVJZ5ykyRlWeJ5Pkma0rRuIiaJE4QUpGmKEG5Sww98rLWk6cjd67Y9bmio/n4HYYhSEj8ICYIIKaGsCra2tlguV1jcdyKOItq2ZbFYuGgwYxilI9I0Jowi4jjmyc0bzXoAACAASURBVCcv4PkBi8X8u/4df549Hn3wEXZNzLmf+Tne/8brK85Lzv/aJ3jwa+ULNy8f56FfO08Zn+b+v/tB3nby+bfmX/0M/9tnn+Bzv3GOO//mOTwu8OgXd2Hzbfy3/+B+Th8Xtkse/8zH+fzuk5y/dh/3neQ7Ml+e4D3/0we458bF8Jce5l98YRc27+EDH3oPZ4/fK7n0m5/mU7/3CA/+7rl+CqDj/G98jvM5nHrHh/nQ259vXRwX5F8C8688yvkczr73I3zgLTeczKWH+cQ//yoXv/Yk3evPceqvPsAD4wd54uk54zfezwPHx+t44t9+q3vt7utn/ufPceGrj3Php89wdnyWd75vE++XL7BbnuKH3/fA8STCy7v2l8/86+c59Y4P80s33qcvfJJPfnGPL3/5Ivf99JlXtN+BgYGBgb9cvMJ+9MDAwMDAwMDAwMDAf0pMNzbxlIfVmqqoaOqa0WiMECCkYDweIaVASUlRlvi+RxAEaO1ku+PJFGstVy5fIc9zyqIkW62pmwohBX4Q0raaoiipqop8vcb3fIQQZNkKYwxNU7sCbNfRtg1JGpMkCW3XojyvL+S3SCVom5qqKoiiEGNcofz6v7NszWK5JI5jgiCgrmtXgPc8VsslAkHoR9RlTVW5hkFVVmT5mrKq6LRmuVxRVjVlVbNe526Vv7X4vu+ilHpxrt9n9ltr6bTG4GY7rv+HdaLjUZIS+D5A755wEwYC1xgBF9GTjkbEUYySEqzFGI0UIKVAClBSIHCr873+PJqmPW58WCsAhRAS5SmSJGYUx0RBQOC7RpGUrnEg+kkKazWB77vpCtlPRfRTEgBtZzG2314YsB5161btG2up6vJYPG2tc114vkcUhdR1fTyJYoGyKJyQu22pew9BFIZgLVEUM0pTktjFaEkhjz0H8/kRWbamKAq0sRgk63WOMcYV71crlOeRlzkAURgRhu7ztc4yxuMxZVVS9O87ibfXuxoCrly53MdPuamJonBuhaqqiKMYa6HoGxTLZYY1zu0QRRHTyQSvb4xsn9hmNB7RNg1SCNI0Ic9z9q7tcXg4750Qkslk8t38er+Q/fM8sQ+cfRcP3FjYJubcf/Fuzr6oipD90eNcMHDq7T/zgiYCwOwt9/O2E1B+7XH+qAFoXexRdcQ8v3HLmHs+8Ev80kc+eNMmAgCvO8ebX5Soc/GrX2VOzD0/eWMh3e379Lvu45yEvd9/nEsA5kme+HoJ07fxky8qru+8/b28bfMlnAPQ9QLlo8MjXqBSPn0/P/dLv8BH3nfuJqs3L/LMbox34m28840vuqD4Du7YAkx3U7/yy7r2V0J8D/e/+D7ddRc7uDiugYGBgYH/NBgmEgYGBgYGBgYGBgYGbsooTZHGsl6vaaqG8cYUbdxqfwEoz0cb4wTKwGw2o26avpFQkKYpq+USayFJU4x2UTllWbC1fQKBYH44xxpFPJ2yXC7xvIAoimmaFt8LKMqcpmmJ4wQhFAIwVqOUT2VqmqZhPBlTlgVF6YrIQeD3RV/JxsYU3XXHWfZau+K8EJogCBAWfM9tX0sXqWQBz/Opm/p4db/BkoxGaK1p2pZ1luEHPkKEaN2hPHdueV4QhgFhHGH6WKAbMcYghEAbQxBGJHHKtcOroDVwvYngmgTXt71+b/f299Bti+pX8l+flhAIkG7eYDyess5z2taVOK/HCkkpX/DvjY1NsmxFp1sQzg1gPYFuXAPGGEPbtWxMZxitqXULGAQt4JoMVoZgFdgGi6TtOipToYLweMokimLa1smz27btm0MNQojjfwdhCECe52jdEQSBaxpIJ2tOogm67Xqht2sSuMmGhOVqyXx+xM7OCYwxlFXFaJRSljVad+RFQduLvI2xjIIUKQ0IQVlW7o4LSdfVeJ5HFEUsjuZI6aKL1msnnvb6BldVlZzYPtHHdLm4psPFIUIIppMpQkiiOGadZRwc7HPLrbfStq5B0bZt71UIuXLlCkIIkiQhTUekaYrXN5VeFXZ32QN2Tt/xzQWD4Ax3noYLTz//0jNPufJ0df5hHvoWC/nnHcAlLj0D97zuTu65O+b8H57noY9/lM+fOMWZ138/9971Fu44Fb/kAsXs9hef2x7PPFUCMVe+8hAP/fGLf6JkHgLLZ7iSwelil10DnL6D09+091Pc+bqYL//+zc9j5013ceqLj7D7u7/CR//dmFOvPce5u9/MXa8/zSx4KVdylnf/D7/AuwGakizbZ/fyNa48dYEnLzzJpaOXso+Xee3jl7LPF3Hy1E3jpgYGBgYG/uNnaCQMDAwMDAwMDAwMDNyUMi8wxhDFcS8dliglyIvaxfI0zg8QBMHxiu2qrgB7XAyeTKcIITg42Gc0GqOUE+rWvdw4CDyiKEZ3rjmAdZEwaTpCa8N4PCXP16xWK8bjKYeHc6bTKavVCrD4foAQgq5zhfgkSV0GfqvJ1zmz7Vm/Kt70RXQn/I3jiKOjI5QUvVPAYK0rDNeNK677ns/RcoFSHqrP6w/DkOVigfKUiy6qnH8giiKUVG7iQAiXd+/J48K9EALbTyJcf60sS05s77C1ucPR8vA4h19cL+xbizWauqzYmGywvX2CdbZC9+d73YXgez4SSVEUjEZTJpMpnTY0dXPDsa9fv6EqS8bpmOnGjMXyiK5t3OSEufHpW7qupWs7NmfbHO5rPJUjpZNFH2QeTx1MmYQ1f+XWFdZKjLFIIA5CkihBSfeshYAgCJBSOreA5fh+Vr3PQgjBKE1ZLpcYrRFCEATOnbFe52AtdV3jKdV7INrjhoSSAqNd4yOJE9f4MQbP87FYyroiUSlSCIwV5HlJkqTkeUEQuOJ9GIY0Te1cGEKgdYfvB8fRUbbfn9aaxeII31MoKQmCkCRJ8IPAxXEpSV13ZFlGEITUVY21NYvFEUmSuGmatnXeB2M4Olpw8paTaK3xX8VGwt7B3nd4d8z42xSi508/wfzpb/0elJQNgMfZ936Yv7P1WT73/15gvn+J8/uXOP+lh8Ebc/ZHfoYH3n6am+l7vW+brVCy+6dP8O2DiSrKCjjY4zuFR42nL7HafuI+Pvj3Z3z+1z/PH13O2L3wGLsXHuMRwDt5D+/9W+/hrptNNxw9wef+xWd5/NoLZhrwNneYxXvMX/KC/5d47a+kkTAev6IfGxgYGBj4j4uhkTAwMDAwMDAwMDAwcFMODw4YjcYko5TWGDrTkcYxQkmMNuxevkqUxKTpiKoqWOdrwiBEKkUgFOv1GindKu6mbll2CzZnGy4/P3Ti5PU6Y7oxZT6fUxYFfhD0EwEeURxxeHhAmqYEQUDXOalyWZZEUYQxlsPDOb7vsV6vmUyneEqhteZocYTvBQgkoi/sd/1kwnQ6petaoigkTVNav+2z+QVdZ5woWGs3XWEMoNHGFe49pfqIpZGLRVotewFvR9G4RopuOqpxhZIBvW24lx+7BoK1FgHUdUXbdWzNTtB2LatscdxsuL6d7QydbJFCcGJrC99TPLe7S9u1GO1EyW3vT8CCRZCOUiaTKft7rjj8vPDYCZuN1tR1ycbmFpPxlMPDfXSnMX0Txxh6ubOmqhqm0y12dm4l0CsEup8K8TE2RPspxrhmQFUWeKMpAvqoogaE8yb4foAxlo2NjX5qJKSuq76A37gGilL4QYDWHRsbGyyXCwDq2smNizIj8H2SOHZNhH4qIA4j8txNDqiRoqoKOm3QRh+LsJum5uSJHdZFSVW3KKWoyhKjO9JRilKKMIyYzw+JoqifUugo8txFYTU1unOi5SYMkdawfeJ526ynPKqqIvADsvUagOl0g7ZtOTjYxxhNmqZUVc3OzkmuXLlyPFGyWi6J4+hYiP1qsLO9A3y7ZkLXNwRezJi3ffAj3P/Ny/u/GTnmzNs/wM+9HbqjS1z8+td4/PwTPPl0xoUvfIrPxB/hgz/0SsvWZ3nPP/wA99xsGsDsMINv20yoSrfC/6Xgbd3Fe/77u3hPV7L71Hme/Pp5nvjDC+xde5yH/hmMP/Iezny7xkdzgYf+2UM8kcec+qs/xo/d/UZObcbE4xiPPR795U/yyEtuJLzEax8YGBgYGHiFDI6EgYGBgYGBgYGBgYGXhrDM53Oa2omVl1mGwK3cV56HxRIEHkmSIIWg7dpeJOxy9q21xHHCdDplNB7jeT5+EJBla9ZZThylLBcLl/GfxMRxRF3XaK1ZHi3BwLW9fVardb8SXXNwcMhqtSbPC6bTKSCIoph8nZPnBcvlCs/30dZQlCVYGI1SgsDHUx7z+ZzVakUURjRti7aGVncgwPM9lOcRJ4l7DYHsmxN1VSKkJB2NyPOcLMvw/YAoityf2E0l+IHvJL59E+FGjpsJgDaaPM+xCEajMb7nA6L3O7iivue7hkpRFJRFhUSipMIYMNairSvgr7Ijrjz3NE9f+gaHB1fxZEca+c6ZYAxYF+HT9xsoihLdWcIgxvPdyn1jOrRuMabDOpUDTVtRNw0qiEhGY4RQYDtGwZrXzPa5JZ2jRIm2lka37j6VJesswxgXY9U0Dfl6TRD4Ls6o0zRVRVs3BMoDY+g6t0rfia0tzz232/sJLNl6jbYGz/cJoxAhXXPIdJ2bRGhbiv55lGXBep1TlSVKSpqmdRMv2jBfLKlrdy5lWTKZThB9hNHiaMFqtWI0GjnfhdGEYcBkOsUPfJqmYba1xXQyYTIeccupU8y2tplMpyglkVKQJHE/SREcN6uapuZ7Tp9mNBqT5wV5vmZ/f58wDN3PT6a0bXM87fKqccrF2Oz96QWyF79nLnLpRUH7O7fsABlfP/+t1sLv8vA/+Xk++vHP8NgR8I3P84mPf5RP/Kbbibd5mrN/7X7e/3c/wi994B5i4NJTz7yCk95h5xaAC5w/333z280TfOZ//Ci/+E8+z0WAE6c4JYH/cIEL5sUbZzzz9Ddd+bdgzmOf+Ti/+NHP8HgDeDGnXncP9/3kB/jwP/wI998O5M/wzOF32MU3HueJHOK3PMCHfvJtnD09YzzuI57MHrvf6WePeZnXPjAwMDAw8AoZGgkDAwMDAwMDAwMDAzdlnWesshVFkVNVJXVdk60y2ralqiq2d7ZJ+5x6pSRSSeaHh5RlgZQunkcICIMQY/uV8FWNUoo0HSGFK3Jba4nTBM9zBfvJeHycVz8ajZlON9HGsFqtSJIUEGRZxmKxoCgKsiyjKIo+CkeyXC6xgFQSPwiI4piiKNwqc92xXC44ms+Zzw/Z398jz9d4noc2Bj8IKMuSPM8Zj8YEQUBVlYAl6OObtDaEYeAmEZqGIAhRSvVy4w7TaTzlxMACnFwZevuB43rcULZeUVQ5YRiSpiOEcywjcAXpNI5pqorDgz3W6wwhBFESuWgj7VbIXzvY4w/+4Pf50ye/xr//+p/wlce+xO6Vp7n9thNIYcBKEK74LqVzOdRtQ1EWKOURxylCuAgfY3o1dD+V0OmWvMyQUhBFCVK6+J3Ia9hOrzGLnkaJGm0str9CYyxGG9brjDh+vjmgtaGqKqx179v+T9e05OucIs/xPA/f95Gij0HCSaCldM9SG/ccptMNPKUI+8ik8XjCbLblfA/GUNc189510DQtbdvx3HPPsVqtsECWZa6A37ZO9l07p4Lt74HAxWW5zyeEYcTi6Mgdwwo2Z9sYc120LUlHKXEcE8VuRXtd18eTFGVZEscxJ0/eQhhGgGVzc/NYxqyUR9PUtN2rN5HAiXu49zXA5Uf57FdvXLNfcum3fofHX7RCfuct93Jawvz3Pssjuy8sZO998bN8+Qi6rTs5twnccQcn8o75H3yJJ15Uq8+WK0pgtjl7Rad97gddI+LCww+9aN8l5//N57lgOnjdOc4AyHPc+5YYysf5nd+6xI2XNP/qZ3n08ks54ow7TvqU3QW+/Lu7L5Qtd71MWm4ym/avSTc143wcL6Q8Wr3gHDAZT/z65zj/TU0OD3yA9gWTIS/r2gcGBgYGBl4hQ7TRwMDAwMDAwMDAwMBNmUw30LrFUwrl+7R1TRInNLWT166zjCAMGaUj3Ep6i5SKKOpX//s+XdfRNA3WWmRfPK+riqqqoZcwN23N/PCwj/+BTmu61sXPzLZmrJ97Dk8pvMgJk6VUxHGA5yma1vkMEJIsW/WxSSFFVRFFMfP5HDOZUJU1ynOF6Th2K8c9JdHGFYuVNJjOgAXfD4iTxMmNewmyW6FvSZLESZs7gRQNUS8VNsbgez6+76S8URSDcS4IrCuya+Piha43T6QUYFr2955jc2OTUTpivc6wSrv30FR14SKWOs3+3i5xHGOsJc/XtF1DVVU8++xTSCUxVhGEPmEc8cyzT5PGISe2TrJ/cETbupgmJ4W2YAXL5R6YliRJicOYpqkB9wzoGxrGaLLlnLauOX2HdtMmVqI7D6F8hLjh/ghJ29RMN2a0XUM6nvSiY580TdFGuyaTkAiLiw3yXcRVKmC9Xru4H6VIRynXrl5jNJ4ipKAsCzzPJw4D1tkKkhFN16KkpKoqlOfT6Q4vCKhqt8J/tVwTRRF+EFBXNb7vY437HEohaNsGIRVt2xKGEW3TQpLS1hVCCoQUWOtimrTWWOC53V0m47HzayjF4uiIMAzI1+s+simibV1UU5zEZKsVpqqIo4h1lrmIJN2RpiPiJEZ57vibmxsvaDR99xlz73vezflf/TwXPvsJPvrls5y7zWd+8UkuLX3iFMr8hs2n9/Iz732ST/6fF3j0Vz7G46+5kzMzj/LKeS5c68A7xTt/6l6XsR/cxf3v+BIXfuc8D/2jj/Lo685xKoVy7wIXL5eQnuNdP3LqlZ32697NB374Cp/60o377vrz7mB8F+/58edL6Wd+4v3ce/HTPPZ7n+LjXzvNnWdmtP05x2kM+Xc4Vs+pH303d/3BZ3jid3+Fj/2h24dXz7n0jUvMGzj1jvu563rU0M4Op4Dd/+8hPl2c5o7vv593vu4e7krP88TFz/Hxf/T48c9fvHCJzMyYbZbMj/bY2wdOAMy47RZg9wK/9c8f5OLOGX74ffdy6mVe+8DAwMDAwCtBfexjH/vYq30SAwMDAwMDAwMDAwPfzI0rV+M4elWPf7j3tFuprzXGuiK7sE4mHEYR2uh+ZXdLGEVIIVlnayfWVZIwCGja1oma+xXlTmZc4SlFVdUYrfvCvlsl7ikP3bls++tCY22dOLgoSsbjMVp3eJ5H13UIIdHGuBXrnkdd18cxMU3TEEUxVy5fxhiDlG7iIQhCpJQkcYLFEoYhUijq2gmgjbX9332EcAPdo9GIfL1GKsX88MC5FjY28H2fOI7JcyfpDYMQAdx6y+2kyYTFaonpK/PmWHjsJhICLyDwPYzRKCldUyLw0W2DoKNpSp698gzzo0Oy9RKLJlsvuXrtOY6OjliuFqzXy2NhsO8FbG5O6bQmiCK0tcymI6bjhDgOCX0PKSyBLxEYPF+gpCUMY+d7yFbA9TQmNwngvAqarm3Y8Je8YfuQSFYgQjoSN+4uIO9SfuuPK/BSrKWPZIpRnk9dVXS6O77/vueesSvQdyAEVVXjeR5SuemC9XqNks5VkaYJQkiauibpm0C6f72sKrI8oywqhFLk+ZquM3Sdds8/TiiKoo/Yiql6yXdVVWxtb1HXNb7vUZUVfhD0nyfN5uYmvu/TNC11VTIepzRNQxontE1D27UUeUldV1hrKMsC3/cpiuJYKu37AVm2IgwCoiimLEu00Xi9aFpJF1Pl+z6+7xGGId//5rd+t77q30z6PfzA3a8lXFzl0qWnuXxljzy5nbf+1N/mre2/4/zeDm/60Tex028e3vpm/tqbtyl3r7J7+SkuX7nKYR1y6o0/xgN/+338wA1DBulr38rdJ3KevbrP3qXL7D53lcNqwu33vIuf/S9/nDNpv2HxFI89dpH85Jv40Tf1R9r/E/6fP9kjPXMv935vyguRTF/3Vt762pCja7s8+8wldnf3WNoNTt/zbv67//pHuePGxCg148633s128SyXn73EM5evsuQW3vBjP8NPnrrI438GZ37oXl774sPciNrm3A9+H+H8CrtXL3P58lWu7udw6xu4791/i/e+dfv5GIjkFm5tnuL85avsXbnK1fBO/vq513HuTdvkV3bZ3b/K1d2rXF0qbvmBd/Gz/9X7uNv+CY/92R7e9/x13nyr29P2qSlX//032N27ytXnSm556z18T/gyr/1bkvPUY49xsbjh2X6rZ3Cd7/TewMDAwMAL+G78Tl/X9Z/Lfm9E2Ou/vQ4MDAwMDAwMDAwM/IViPl8c/30223hVj//ob/8aTV0ThIHL0vcUVhukUhhr8HyPZ599ljQdkaQj0sS5A6qqdNta4yYGrMugn21ts1wtCIIA3WmsMVgsvucTRhFFvu6L966InRc5cRSBdOJba0EpyXqdUxQl1jppb9s2aG1cQTvP2dycUVUVo1Hai5cXGG3Y2poxPzxkMhnjex5RGFFUJcZoRsmIsixIkhFFWXJt7xoGiOMEpQRpmrJarui0dvn82hXCXcY+LJdLus5JmwPhcfr2M0wnWxzO9yjLCmMt1rpmRhQEeJ5rfAghsIJesCxo245scUDVFvzhHzyOkB5CuCZDmrhCeNXUbnoCQZIm1FXl3A7KQwiLUoogiAgCDyVlv1re4nkeeZ7Tth1d1yKFy/Y/c+b1bO/cyuH8iLquekeDWx8voI87gjftrPkbb3iKiZ/x3Gqb57KEUJacvW3NfrXB3/uX+8jRLf1q+4QoTTHW0tSVE3AHAWEQEgYBbdNitKbTGul75PmaW289xXqdYbThaLFASTedsLm5gVIK3XUoIYijmCSJWayWx4LiMIpJ0oTd3V3iOEFrjZSKPM9Zr91kgqc82q5F9w2oNE2xWKIoRkrJ4ugIgMl0grWGKIrIsozADxASxqMRXdPSGU0QBJhOE0cRSrkm1PUGSNu2TCYTjDH9VMwh4/GEsizQnSYdpQgp8T2f0WiE7/lUVUG2zvh7/+AXv0vf9IGBgYGBgYE/T74bv9OvVqs/l/3eyBBtNDAwMDAwMDAwMDBwU+q6Jo5jgiCgLCsSlbC9vc1quSJf5+hc03YdddMABVHoYn6WiyO8UUoQRug+c362tUWeZ4RhyGKxYJQ6qS1CECcJdV3j9eJiKUS/Il26qKOm7Ve0S1arJUEQMp1O2N/fZzIZ0XU1m5tTirJCSukij+qaUgo85REFAUJKAt9nMhkT+AGeUv1UQswqWyGEYDrdcA2NsiRJU4qyxFMSP/A52N9H94XhIAhQQqCtPY4+WmcrknTEarlkkiRgNcvlgsl0g6Y9RDctUkrSJGFjMgGcJNhYS9O1rNdrusbFQIWh4CuP/R5ZUbC5uY3uajzfo24VXuARCAs+eMqJoaPIxQNVZcl0Y4OudU2OsixAWDpjEQKazsVArdeZm9BQyjUmyj/mP7vLo6paurbDWtc4CKPexdC41fMYg+3FzZ6S3DaTzLMQ05VoLeg0BL0geTyeULU1YRSTZUs2N7fQWuP5Pr7vzjWJE/YO9pGtIvADmqYmSZykuigrijx3nxEL+TqnbmqktbRpR5zEgCCKY6y1eL7PtWvXmM22qOuGMIywxpBla3TXucmD1MfzvGP3wnx+yGS6QRRF5HlO13VugiAKEcLFOumuo8WJrafjMUIKfBVgrSUM3X0v8pzNzU2shSAI6LqOJEkpipyubTh16jbKqmS976Ysgibg1O2303Ut6yxDSQXCEgTBt/kmDgwMDAwMDAy8OgyNhIGBgYGBgYGBgYGBmzKeTPCUR11XLopFKbLMWT3jOKaq6xd4AZ566s+IQld8ruva5dP7AUa7FdxhFHB0tOB7v/cMRVlgjaVpavJ8TRiEtF1HtloRhiFBGCJFRN00CClAu1X7YRji+wHaGMbjMbPZjCDw8f0QrS2665jPD3vvgUJJyWg0whqX7z+ZbFCVOULAarXEDwJGozEIQVmWLBYLwjgiaHySOCaKI9bZGoFE65aucyvpsRZt7XFU0Wg8puuc26CuGyzQ1BVZvu5lzJrAU6RJjFKSvb0DtO7otJvaaFsnBG6bhqaxtFoThBF+4BHJkDAKqduGUIYoKZlubFBVFVEUYa3GD0KCMHDRTMa4KCnfJ05iqrLCYqnKio3NEVVVIns5tFSKKIm5fOUZtk/cRtV1KCWJ4xTP95gfHgIGA3RNjTAtGIvVJc9cs9w67RC2oSwbDG5SJfB9Dg72UYGPsbaf6nATCdZat6I/ihBSsjnbomkbpHSyZyEEVVU5UbeUTp6sDet8jbVuQkKvMxCCuq0xxnDbbbezu/scxhiWy4yqKunaFs/zKIqSIAzdvqUgUCF1XbnpBs/D81wzBSAdjei61n2ee7k2CIo8Z7qxwXK5wvc9vCBAd537PEUhe3vX0EYjev+GMaaf/GjZ2NigKAo35SGEi+nqWq5cfhaA2WyLbLkkCEOE/Kav4MDAwMDAwMDAq8rQSBgYGBgYGBgYGBgYuClt03CYHTAeT9Bau1XbTcvG1BWxLZbNzU2qqqYqSybjCVm24tRtt7FYzLl69Srj8QSlPJqmcTE+N4SsVpUr8nZt5+S0UURpXTSP1ho/itBFQd02x68ppViv13i+TxiGLJdLsixjMpkChslkzHK5II5joihC4HJpy7IAa6l62a+1uNXvvbvh6HBBFIVEUULVVMRJfBy/U9c1o9GYoAsJwxBrDOv1mjAIsHB8Xl3XuQJ92XL1uauAh7UW5XvEcYwUPkpIDg8PKdc5ndEUVU3Tuetvm8Z5KKRAKR/PUyjPxRMppVDW0nYdk3RE0zT4npMHJ+MRVVkSJwmyz9zPVivGk7ETCgtBMhoxnkxYLBdMNjdZrzOCKKRrW5q2RipJOkppGjf5EScJq9XyumXaibStQViNMJbteM34dp9I5RiraVuDlB5d2wHWNVywVFXFxsYmUgrKoiBOEpbLJVIIhIXJxhSp3OdiNEppG9esaeqa7DszYwAAIABJREFU0XhMnuccHB4ghKCuazY2NvE8hbaGsijRuuPZZy/Rtm56IM9zRukIay1HR0c0TUOcJCRJytH8CKUkOydv4dq1q0wmk+NGUFW5aZbJdErXdbStk3MnSUK2ch4QhUAgiMKQZVXiBwGL1YpWa2TduOmFtkEINzmjlGK1XDgXhDGcvOUWFoslUZwQBQHrtZMvj8YTpBI07Z9/zvHAwMDAwMDAwMthaCQMDAwMDAwMDAwMDNyUyXhMGIRkecbGxpSyqvACj7zMadqGJE1J4wQpc8YnJ1x97irb2zusVqsbImQsZZkjhEAptwJ8uVw48azWGGMoipzJZMJicUgQRiyXC7a3T9DpliRNEJXsnQfOwbC1NcP3fdbrNXXtVuU3TU2RFyRpysmTJ6nrhqIsEEKQ52uSJKEoctI0JQwjFssFm5szsnVGvliifI+6bZnGMVVTUOQVcZxwMJ9jLfj9pEEURRgsQop+/xKsxVMK6/vkWYZQks4YTmzPMNZycLBP13bIFK7kz7FYLtGmw2iDMRZtTC+OFkghCcOkFw0b4iRFeZ7zK1iQWJTnmgW600ilCEOX0z+fz5lMJmBhtrXF0dGcum4IggBhXeOmrWoXN6UNcZJgDFRNRSQUR/MjqrIlTiJWyyXrdYY1BiUFSoIQtpcrGzxrEXKBxGKsou0UCLACat3hh87y2nWaJInpuo7xZMxquaJuXGSWpzyK3hswmU6pqoqiKCnygigKaRonRnb+CNy0hdbgKeq6IUnHZNkKY8AagzaGrdkWndZorRmNx0RRSNd1NLWLh4qiiKIoCIKQ1WpFkqREUcx0Ou2FyQHGGNI0pesarj63ixCS8XhMtlohlGKxXCIQdF2HpxTj8Zhx4qYZwDWWyrLkxIkdDg8PkFLSti1Z5iKldNdSKsXGxoZrIHUt0kiiMHl1vugDAwMDAwMDA9+GoZEwMDAwMDAwMDAwMHBTurbDGsNkPMHzPNq2pa7rXmQrMVoThhFSelhc3FHT1H3mfEZVVXi9SDaOU6Ahit2K9DAM8T2fKAxRwsUPpaOEo/kRvu9ztDgkCALatsMPQqRwhdsoity5dZrxZEJ5rcR0HWEYMtvcIi8L/CBAKfe/PXt719jccLLeJEk5PDxkurGBlIK2bVivXWTOeDymrmvariVJUqqyJssybJ/5b62hqgqCwKdtG/b394jjhNlsCwE0dc1qscCTksB3HoUojtjf2wfrpM0IJ4rOsgxjO1cAtxx7FoQQxGFE4EXcfttreOrZiyglMcYJnpMkxvM8sIY4cpJlAAsgBQjwlE9ZFDReh5SKNEm5Hs+jtWY0GtN0bd/AKUBJkihme2uLoigZjadIKVlnGXVVIwTQF/MlFoECA4gWYSVWSKwRtFr21yCp6pqiLFDKQxvNOs/xPI+yLEmTtI8wkni+f9wcKssSIQRNUx/fk7ZtGY3d1EDbtpRlydbWNm0fW9R1HZ7nH0+EIATKc82JKIqJkwQhQIgaow0I2X+mLbbTBL5Pvs6OC/ph6D5buhdqx7Fzfni+TxiEMJnQde1xc0MIgQWkEFSVa4wFQUCaOsn3fH6I7/vUdY0xmiAIaZoG03V83xvewDpbc3Cwz2g0pus69zwGBgYGBgYGBv4CMTQSBgYGBgYGBgYGBgZuiuf7x3JebQxKKedGqCqUp1BKcXh4iJSKtu2IkwgpoKxK0jRFStU3FmLqumI0HlNXJUkSk+c5YRBSVv3UQJETxzEgCSOfOI45PLzeTGgx1nDixA7Xrl2lrmusNXieT11XpGlKmqYczg/x/YD1esWJEycoi4Lbb78dKcAYQxCEVI2L8Zlt7XB0dESSJJRlhTEGay37+/sEgY/u8/qvF4LX65woil3kkh9w6tTt/SrzFVK4pspoNOJofkRZFgRBwlNPPQXWEocxURhhtMVcD/q3ArAIIfA8hbUghWQ8GWON5cxf+T6sskShT5qOKKsSbSxxHOIpF7ITJ/GxqLquKjzlobXG4twTcZz0RXf/OHpJCAiEII1jkjihblsm4ymjeEzXZCgp0dpS1zWd1lhr0J3Gk4KurRGmw2pDricUesxymXPrlqVstPMEWEOSJvh+gDXWNWpwIuGqKsnWGePRmLZzTam2dU4CYwxd/3fP8wHI8zVH8zmTydQ1guIErTtE//ksy4I4jlmv18RRjBSwv793XOQvyxI/cBFYbdehpCKKY4q8YDKeoHzFKltxsL9POhqxtbVFURR9tFHDel2jPHc+RVmwXmcIIZjNZpRleRxz5QcB2XJFGEYInOMhTUfkxRqpFLb/LtVNzSgdkY7GHOwf4AfuuQghCAInmx4YGBgYGBgY+IvE0EgYGBgYGBgYGBgYGLgpTd3QtDVFWRJHEVVVUdc1k+nUrbK2lqOjOUIo0jQlCl2R2/M8WtMhpcD3fIR00TBt1xEnMUVRkI7cqm1rLOkopSgKytJJgNu2xfc8sJb5/JDJdBMLZFnmJLdSUpY1cZwymo5RSuGFHuPxCG0MlpC9vatMJ1OM6UhH7thF4ZoBUgk63aI7jVLOX6CUQncuEqfrBHXdEoYBddO4grQfEEWhO0cp2NrapixLABfbkyQ8t7tLXuYk8Yi26xDWw++bL77ns8iX/c/YfqX89ZK4QAgIg5A4TtBas3ftgBOzWzl5ckaaphirsX0JXSknfo4iF9G0d7DvHAqeomndFIFLXHINicALqZuKfO18BukopSpLuk4jhMQYyaWnLhGGsYvsaVuquua60EJjQFswHYIKYzRPX7Vc3DNsb8ec6FZ0RiKVRxgnTCYbrnFQN5RVRVM3JHFCGEbk6zU6SfuJEctysWA8ds+wrivG4ZQoigiCAIAgiPB9HxBUZYmUitFkRNd11FXppluCEITAD1zB/3pskjaaqizdvqzAaMD0noMoom0bkiQ5nnBwkUcBh4cHGKMJQ9fEcs8lpiydNLksS6qq7J0fFiUEndZQ10gpQcBitXTNq7ZFSkmnNb7nGlS+57FarbC5k4MnScrR0Zytre3v5td7YGBgYGBgYOCmDI2EgYGBgYGBgYGBgYGbkpcVURQQhhFRHCOVAmNp6pau7cjzgtFo5DL8jWG5OMJai1SKuqrxPNdUMMaS5zlJkuB7PsvG+RVWqxVhFCGkJAxjtDZAh++HlHVLEMacmk5dpr8xeJ4ijGKM0Xi+ZLGaM5lO6DpX3JV9hn5nNLPZ7HiaIMtX6M5S90LcdJS48/NdobhpagLfx/c9ItzUgRf4FFVFGIYuxskYtHYuA9/32bt2jXTkpL5aG1qtEVLheT5hEIDtpw2CACNg/3Cfsqyw1iKEwhhwGUGu4C+lIoxCirJwDROtKcqSLMtccRoXGySlJPB9RmlC01TcetsJRukIpdx9rssKz3f/y3fbqdvJFmsWi6usVkvXuLHO74AFYy1Gd1jb+wewHB4eUDftsYRY9H8sFmEN0lik13Jmp+C2HY/DZYNEUzcdddMhm5ZrV6+6KCc4nmKp64Y0TRmNxljrJh6CIGBr20UVaWNoW9fssdawWl2PlXKvC6DTHaKTFEXeN3yco8DdG4ExFs/zXPyWb/rmis9ysUJ3zkdRliVxHBFFIXVdEkYhQRDged6xy2A0GjtBd5Hjex7L1QI/cDFMTdMSBCGLoyM8z+/jvBq2trc5nB9StzXaaDzfTWCUdcV4PMFqjZASKYSLxUoSkv4eta2L07r+nAcGBgYGBgYG/qIw/HYyMDAwMDAwMDAwMHBTlFLkec54PMYYi1vLDV3dgAXf87HWss4ysFCWFXXdUJYVUgo3MTCaoJTqhcgNTdewOZtR5gVd26GEZL3KqKsKYw1hFBFGIW3bMBqnnDy5gx+4qYE8z4njiDRNSZIEaw1lWfer2wWe72GM8zdEYQQWdKexxhVrwfLa176G6WTDuRf8AN/3iWO3rzCKKKuKvChoW1dMt9bFBCmljgu9UkqivoC8zjKKfE1VVbS6ww/6zH7pCty+75PnGUWZY62LHTou0vcTCS7eyHkmlsslbdv28TodVdVSlg1lWVMUJet1Tl217F3bZ39vzpNf/w9M0ymjZMR4PGFjc4PbbzvN1tZJnn16l6vPHbC/f8B6XVAWFUVRka9LsiwnXxeUZU3TtIBktVxSVhVd1/XihR4LWIPAIrFgOxqrULbkezcbpNBUrcb3QoSQ/ZSDRWvNOlvR9FFU1++H7/tIIWiaBmut+7cUGGt7P4Fr3IB7frrrqOsaLBRFTtM0vVdCYIzpo5E0RmukkFRVSb7OqYryeOLAPT8IowAhLEVRULcNURTi+x5xHKGU7F0aCWVZkmUryrJESY+DgwOyLOtdIQ2bs/+fvXePue2s7/w+z2Vd9+W9nAvk2DmY8UQHlINqLFzFkTzVGAU6MYqngVKrA0qRJqMIpUghDTACNWQa1IQ2SGWmqAqqmApHcTMkgmjcqo5wFIhCGjPmNBwXHyUnwQc44HN5L/uybs+tfzzr3b7CwSFgJ30+0pHNu/dee+211yt8ft/f9/s9thERJvUEnWW8/OU/RD2ZUFcT6knN9s4u0+kcgLIoNgXjWZbHc1WSEALL5YKyLGia9ff19/nGWPYefYCHvvIivt/Vh/nI+97H+37r/A/qJJ6f7/t5vIBr/e3OZXmRhz/9Ba58X84vkUgkEolIEhISiUQikUgkEonEDRmGGNWyWq1ompYQIHgIPiCJOftKavIsZzafx0x9oJ5MyLIc5xzrseRXSjlujXussXHgHGBSTajrSSy8tRaA69ev472nbVq++a1vbmJ7EIKu6+m6DmsNs+ks9hk4R1HGItuh77HWcu3qNZaHK7z1COIm/2RSs1gc0vcd3sWhddu2rNfrseh3YHt7myzL4pa8s3Rdi1J67GUIVFW1ERSqqsKHwGAMxljWqxXr1RozGIZhQEoxnqtDbVwFT4kHSulNKXQInvVqNRYRC6SUSBn/qVTsUDj6s27WNF2PcZ6mszz+//4l3/zaNdYLw+Kg5+JfXuKrF7/OYtlwuFhgrSUEH4uBpSTLdCwnBgggpaJp1hgzjCJHgCBQUiFiRhIxfskjpMe4CX/xzYo//8YOTgTA0w0eIQJFUSBE/DxKCSbTKcCmoHgYBtbrFav1KnYMBI+UcaA+mUwQCNq2YWtrm7IsqeqayXRKlud47zdl20f30nxri7KqCN7TdS1bW1vM51vM5zN2dnfRWrO1tYVUgul8is40Os/o+o7JdErbdgghODjYp2kaDg8OYkmy1tx08w8zm8/RmcYaS98NLJfL2Mkw3gfz+RwfPG3bIIVgZ2eHoiw3jgulZBRBhGA6XovpdApCcP36ddbrFW3TRKFOvLh/Vd/7w4/x4d85xxX/9/P9Xkp875/9Ag/89x/noYvt3+ZpJRKJRCLxHFK0USKRSCQSiUQikbghk8kEY3qyLOP69T3sMFAWBVLAbDojbEqMc65f3yMrcqSIg1OtCyAQgh8z/j1SKYo848qVq+RFwXxrBhKMGVBKIkdx4aabbubKlSt0XccPnXo5XdfTNA1lUbJcLsl0HAZ77yiLgoBgOp3F4bJz5CGgkRAEfd/RNk0sKzYF2zvbR9H/dF27EQi64PEhoHTGarVCKUWWZbRtg1KWsoylvpO6pu1iz0HbtsxmM4L3rJYLgDhIlxIhJSEwFhwLEHHjnrHnQEjBZDKh62LckbWOgOeoizkSS4NjNFBP3w9REAgeEOPQX7BcDyhpmEwmNKsO5y3eeUIQYzaRIHi/EUDKqqJrO4L3uBA27gsffNQQQkAC08ksRg3hEePPIOACtKHksInff/AaGxTBW4ahQ2WKfujIs4yyqnDObnoP+r5HyljUrbWmH4uJV8slQgrKqkIIQdOsN1FO3juqqmIyqWmahhBgOplsBKlMa/K8oO96VqsVAkahJCClRGeKSpZkWR5FJO+wzmGWS6pJzTDEuClrHav1Cj0WJBtjoqtlFMKO+jW6rqVtm013w/7+PvP5nH7oyYuCw8MD6rrGe0/fx3t3MpmwWq3Js4zVaklRlhBiFNNsPsd7z9b29vf7V/o7Yr198d/vxN28+9fu/oGex4vBC7rWz3tNDPb/hwJMIpFIJH7wJEdCIpFIJBKJRCKRuCE+OLwPGOPIdM7Ozi5D3yO0pDfRGWDsgLGWsqqoqnoUFgqa9WrcQg8YE50CWkkCMJtNqesKguBw/5ChN7RNtxl4j+H4OBedBf3QUxQ5bbemKDLm8ynb87iJbp1jGHquXPlWHCKL+Bee2Ww69gFIjh8/xvbWFlU1pesG+j4KF8MwELxnNpuDgKZpWSwWlGXJfD5nd3eXoR9QKiPLcvI8o+87BGD6Aa0zrHWUVUVRlpt4Ip1lBO/w3j214Y9ACrGJ+CFEZ8fxYycp8gopib0KBPwYqRRCiA4O69jZOUae5xtnx6anmegI8MFjneXEsZNkOgdx5DiINhIh4tY/AbwLTCdz8jyP/QchbEQJ76OY4Ue1ZT7fItMZCIGUASkEWsAtuz2vPtXF7ogAnfEIoRmGgbqeUJYl2zu7ZFlOCIFmvebw8IDVajnGB03oupaqji6R+N3He6Xve6w1gGe1WmKtwzlDCEddGZp+GFBKsVgccnB4GMWrPNuIMkoq2rFQ2pgYjdS2Ld4HlFToTCFlLJbe3z+gaRq00tR1TV4UKKXH1w0URclsPgc8QkCe52MEk2C1WpJlGWVZsl6vuX79OkKIzXOkVBw/dpz1eg0EtFIsl0uUlGxtb1NVNTs7u0BAyackpEQikUgkEomXAsmRkEgkEolEIpFIJG6IlHLMpW/Isxwh4+a/MQMSQT/0OO/ZGrf8h6FnZ2eHpolZ8M47tra26bqOYRhYLA4pyzJG0hQlaqIZ+gHvA8MQB/MQWBzG+CFjTYwwUlv0fRujeUIciBdFiVCS9apBSY2QsF7HWKGtrW0Wi0UsH+47fJhQlCXeRVFEKYWXgUk9wRZFLFvOS4rS0w8Ddszgt8bgvX/KNWAGtuZz+q5jf7VC6Qzn/Rjjozh+4gRf+/rXkEJSF7PoLhhnw0KETe3AUSxP3w9szTW7O8e5et1iXXQ6EAKBKDoIAc5atNbs7uxy/fo1ho1AwVjeHN+k6zqO7xxnPt9hb28Px1OlyRCFC0fckp/PtpBKYsw1vDWbc4tyQgARP/fJEyfQAhbLMZ5KCvCOplnTmpwGjyg8zWApiilW6fG71DgbnQhKaayzDMZQliVd1zKbzWma9eg2qCkKT9OsKctyU8y8t7e3iWBaLVfMt+Ysl0uKomA6mVIUBavVkqZZM5lMCDZGK3VdC0KglEKMrpksyzCDYXtnhyzTOGvG3g5DnkWnhECwWq+Yz+eb8uW2aRFC4pzl5ImTNG1D2zb0fUffd2xtbTEMA9/65jeZzecIIZhMpiilNpFSiPg96SzDWMtkMkFKRd91NE2D0pqt+ZzZbPb9/pX+Nlzh4d/4CA9djf/r/Cffx/uAs2//Nd72o/Fn9vo5Hvx3D/HIpb24CZ/vcvr2N3Dfm25j91kThuc8V1ecvPk27v7P7+G2Y/o7v9/Jh/nIbzzElde8jV/7Z2fjEx67n/d98jxn3/5r3Csf5JO//wUu7VuQmt3Td/CG/+Jebtt51kdqL/H53/s0D3/lMq0FPTnFa3/qbdx17d/ykT+48ozPdiParz7MA//7w1zYt6ArTr36bu75qbu49Wlf1/nfeh/3f/kkb/jFd3P3iWe+/pmP3fhaP4erz7om4/WIjz3ER973EJx4A+/+xbs5+e0+hF9y8U8+w4N/+DiX19ENoWeneNV/cg/3/vitzI7WTcdjn/yJd/Pu1z/raM/zWPxsZ7nvvWc4/798hvOHFr1zhnv/+Tu449jzva+muvlV3P1P7uWuW1+s+z2RSCQSL4QkJCQSiUQikUgkEokbE2LGf1lWZFnsIpjMphweHKDznFmes1qtOTw4oKpj7MtqvSLTBSEErl25ymw+pe06BIKyLLDWRjeAiYXN1hm6rocgxl6BGGeze+x4HFa3a5RSFEVJbwbyPGe9ir0LRwJFIPYVBOejYHFwiM4ypJRsbW0RRjEk0xlCSNquHaNnDMKLZ2z/b21t4ZzDGIMxhsl0Ng63OzKtaJsGhCAvSibTKcMw0LYNbdNQVfVY/BtdB0rJsdfgaOjvx3/G/22dZbE45GUv+yF8OMmTV76J88OYbXS0nR5wztI2DVvzLcTx41y58iTGWo4akY/OXwjB4WLBzvYOQsCVK09uXAix6mCMLzI9gxmYTmY469g/2MPb4RmxSrFkeqDrena2d1EykKs9CBoROmalQimBzgMGQWv8GM3kn4pK8j4KLd6js4yiKAA24kzXdlFksB1Sqig+OY93DoiigDGOPC/G7f81eZ5vbs+265gcCVvjfdO0DXmeY62hazu8D1G8cg5VKYa+j8XO3pNpzf7+PiGAzjRVXZHlsR9jtVrStV38nqyhKHIOFwcbgeCoR8P7gNYK77PRvWPY3t7m4GB/E13VdR1KKfIsw1nHYAaMMWNslqJrO3Kdsbe3/336Rb4RFTedvY0zFy5w4XLL7i23cXoXXrE1XufH7ufDnzxPi2Z2y1lu3dW03zjPhT99gA8/9jhve/d9nK3GQz35MB/7nx7isqw49SO3cXICdu8ij3/1CzzwG0+w9wvv4u4T3/n9vh3tufv5yJcfh5tv5bZXZuxdfJxLX/0CD3x0if6Xb+Ps0a3Rnuf+//F+zq9Bb53m7K27mG+c55Hf/jDnJ9V3fI/n8K2H+fhvXubK7DRnb4/HufDlB/n4X/0l973rHdx2g3N+Ln+zz/4Mtm7lttsXXHr0EnvVKc68+iTV1k18+0/Wcv63P8L9X27RO6c5e2YXTcvl8xc4/+8/zsXL7+D9bz3zPQyKLvPQb55nkZ/httvh8rdu4qZjgL/Cw//mIzx0GchPcub2U1T9HhcvnOfBjz/Ol974Lt71j7+t9JFIJBKJlwhJSEgkEolEIpFIJBI3ZLla4VyMKjo42IvFst4xWANdS5blFHnOrJqxvbPNYnFA3xma9Zosy5hOJzFfXwicdWRZQV7oGHmEQGVxez3Pc4yxaKVxNjoG2qbZ5PpnOkNnGqkVePAB+q6jLEqGIW6Sr5cNzluCJ4oL4wa4EJKrV5+kLCqquma5WKKVpus6sryg6/q4QZ9pQoi9B2Z0IkAg+Dj4lkLirME7hxCS6XSKd26MAgpRaPFxa9+ZmOkvRR5z9omDfikF/qlMIkJwNE0sWK7qmkk9YbEcAMbC4vg87xxt2zCfzSiLcnzeMn7eZzkT2rZla2uHaT3loNgf3RR+vG7xuc45urZlOplTT6as1kucM7EsezxOCAHnDW3XsSsUW/NtqjxHYAnBsWx6DhvLPAuI3ONFRhCeup4gj4SieGLxWNaRT3OkkvRdH7f8fXR9SCUJ3iMQsVNCCtarNVprQOK934gPmc4ww8AqLMcuDr0ppPbejwXOATMM9EMPAiZ1jR+jrHyIzgcBKK3Jsoyu7Tlx4uQYixTdH03TxAF/UdA0a8CT59nm2pRlhfdh7GwIG4FBSsn+/h7ee9brNev1mrqu0VrjnUNrTdu1dH10ueR5Ttt2lGMPxovDjDNvvI8d/REuXG45ddd93He0Hd8+wgO/dZ62Os09P/dO7nrZU6/a++In+NefOsfv/t5ZXvXPzqKBC3/0EJf9Lnf93Hu45/RTz22/+Ak+9PuXefz8Fe7+xye//ftd/fZnefHLFzn79vfzth89Gpm3nPvkh3ngsfN87otLzv543HC/8ODvcn4Np17/Lt75E6c2A5C9P/sE//r3LrywS3P1Mrz+XXzwace58tmP8pE/uMADnz7H2Z+57QUOWL7Dtf5uuflO7nvrjPsfvZ+96Vnueet3cCIAXP8CD3+5hTNv5v3vuOMpweEtl3jwf/hNvnjxSzxuz3D2bzwp2mPv5Jv55acfG7j0f/xbHroMu697B//1W8489Vh7iQc//jE+/3/dz8Nnn+vgSCQSicRLi9SRkEgkEolEIpFIJG6IGQxCCppmhfOO9XrF/uE+Qkp8iJvYVV2hpGS1WtF3w6ZgGBHGbeweaxx9bwghHtM7H4euQmKtQSlJPakww0BW5LEjAGIR7WxOCOCcp2laejPgvKEfh8J5UcRuguAIPjCfzanrCTrT+DGCRytNURT0XUc/9Cgdi36HoafrWvI8wwcQUuJc3ICPQ96CwQys1yvCGPpjjKNZN6xXqzH3HmazGIXDuP3f99FtManrTexQCAIQm5X/o5/74Lh67QrWWLa2tslUtilFHp+JJxZDHxwcYoylridRaIhHfkZ8kTE9i8MDjHXMpltxwA74+Kab5zVNS9u2m76Cp7oXni50xLiq1WqFRFFXFQLQUnLTTuBHXj6wVTd4HG0/EHzsBhABqrJCSslgTBSSvKPtOvq+x4fYfZDpjKIs8N6PPQmgpGQ+3yIET9f3SCGwdsCYYXTF2NHtENg9dmwc7EOzbnDOURQlhFgoPZ9vUZYVZVWOnQZydLdUCKno+4EsyxnMsLlXYjeCQSlNXhTU1fg5hoG6no6umRi3NAwDxljm860oBlUVi8XhGGkURanorhD0/YB1HoREq4wnr1whCIEZDCdOnKDrOnT20tv5W37pES54OPX6tz9DRADYfd093HUC2i8/wpdG3cgYgJb9a8tnPLd63Tv41X/1ft75vWyg3/IG7v3Rp4+qK267/VYAuraNPxrO8SePtrB1F//0acN/gN3/+C3cffMLfM+du3jLs45z8vVv4a4d4Ctf2nzulzQeLMDePvtP73iWp7nnvb/KL//L+74HESFy5jWvfZYj4iKP/Ic9qO7g3p8+88zHqtPc8/qzwBW+8H9f+t7eOJFIJBLfd156/3WSSCQSiUQikUgkXnJIKclzHQt3m4ymabA2DmTN0FDkOX3bU9YVzhic83Hgm8fy2UtPXGI2m242+ruuRynJ3t4eUsauA2O4kPoLAAAgAElEQVQsSmVRgHAeMQybgl4hJForirLgcLmIm+3O4nygKgoCAe9djKMZFFmeEQgorWjbjmLsPxiGASE7nIuFxAeHB4Dg2PHj7O/vY8zAZDYnhMDe3h7eB4IPozgAQkisjeXJq9WS6WSKDzFGSWkdhRMEQkiKLMdkFikU03rKetVgnBkdBmJ83pG4EHDesljsx9LnrRllVbFer/HhKXeA9x4P7O3vMQw92zvbMVrHGth0KYjxeg7s7+9hraWe1mRZTm9NLLEeEQiMGXjyyrc4ceIEVVWzWi4x1j1lg4hnSD90XLv+JJV+GVIKCAakoNZLfNaj8Xg/pRssUim6po1CzNE1zNTmu1wul9x88010bctydI006wbrLNaaWHKs419Xp7M5XdfhPUgZHSpSKaRUmxik+Hi8JyCQqwJrDEVRYN3YRSAEy+VydBpkeO820Uur1Yosy1BKcbB/QFGWG3dB7OuAru/I8wwpBcaYTdTXkaAQQhQQ+r5Da01V1Ugpxw6MGL0UQuylEEIQiF0VdnSzqFzR9x31ZEIzClMvJZ746zjo7c4/yAOXn/v4ngW4xKUn4I4fgVfdfhvVl89x/nc+xAcePMmpW87wmh97La975Smq73ESUZ08yQ1T9Z+4yCUPnH4Fp5/z4IwzZ3Z58Ot73/2bvvIfcuo5PzzFP3wlfH7/qc/9kubEWW479RAPXX6Yj/63n2N26lbOvvq1vPb2s5ze+dsYD+1y0w8/6zhXn+CJFqi+wZ986gG+9OyXtHtUwPLr32DJ6Rt/r4lEIpF40UhCQiKRSCQSiUQikbghPjhAR+dBVeJcHMZ2XY+UisPDQ7TKaPuOsirjNjhhs8l+4uRxnLMIC4OzWGPoO49UGq0UAokQcRO+7WKMTNe1lGU1xgXlGGtoDw5wY/RNVVW0ocETWK3XFHkc+NbTScygdzG6hhBFhqIoWK9bXNMSCNR1jRCwXjdcu3qNsiy5du0abT9QFCXWGrTO0Xk+GgyioOCD33REZDonL3IWyyVt02Csoa5rjI1OiaqsNtn4k7pmuV7hx2G/4OkFyWIUGDyrZsFgO6qqhOap7+DpYkLAsVov8d5RVhVd343Czti/MGoAzhkOF3s4H6N0pJB43KZLQQlB7F4YuH7tKltb25RlRTcWWodniQnGDVy7epnh+BKwOGtZtBXGa47VDS4oEHEgb4boQJBKIVXsLbBmQKkcZx0H+4exnHq8prnOyfI89ldIGcuxnUNn8XtdrRYxQqssN7FH1lissyir8N7RtmvyPDpTVqsl29s7WGs3IpIfBSStoxvGOcdsPifLMqqqJs8LurZlXhQxmmp0PRRFwWo5II/u0balLEtC8HgvxiLnwHodnQwAk8mEqio5ODgA4uuWyxXeQ1HkDIPZXNnF4pBpPaEsy/E9XrrhAXtfPcfeV7/doy3tuJmvX30f7/7Zk3zqUw9zYf8Klx67wqXHPs+DaGZn7ubt993N6RdYU3DEbOu7GDcPLS2we3z3+R+XL2wccvLYs1ucIzvHTgJXNp/7pc1J7n7ne9j99P185txlll+/wBe+foEv/AGQn+SON/9XvPk/+jbX67tCo7/drdte5sKjz6NAHbGO31cSEhKJROKlSxISEolEIpFIJBKJxA1xzmGtZblcchSh47xHaYWSOcvFAq0yyrKibeMQulkvmUymhOA5dvwYq+WSvb09lJJU9ZTDg0OyLEcQh7DWWoy1ZDrDOkee53RtS9e1CAGz+Sy6FISg6dx4Do7BGLyzEALzeXQTdF232cz3Y0eCVhohDsZUH4EZB8wCweLwkPnWPEYYWcfBwT5bW9v0fYdzjr7vN6XBfd8xGMN0MiHPc4IHM8b2NOs1RV6ghERJSV7ESKSDg322treRSmLHAbKQInZECIExEHx0AXhn6DqHlCJutLsoPMR/j89x3uERLBaHzObzWFQ8WIQSSCGik4IAwRNcHMIXVYmSAmcDhIAkxir54CF4hqHj4GCPejKFUehgjAuKEUuB4GMUlelXhOAwVvG1g1kcyBcDzgW8iE6BqqjGrX5NVuRkRQZjzI9znn7oybRCj2XF0+kUIQR5Vsf4o7YbOysygo9D/xAG+i5u7Xvvx+6E0dHhHEppprMZRVFsRAxjDM6OQlIfS5o3vRfBo5Wi7/2m8FhIwTD0TCZT8rzYFGaXZRm/z6HHWkNVVdGhYkwUNkR0d0QRjdiVMHZNTCZT+r4bRaNAkZd4Z2m7FiElBFivV1FIkGITlfXSY8Zd73z/MzoPvuOzb72bd7z3bhj2uHTxMb78xS9z7sIllhce4mP/W8X7f+7O79/gOK+ogL1re/A8XoIXypXr+/A8DQRXvnUFmLHzd2UCrne57S3v4ra3WNrLT3D+K+c5/+ePcOHJKzzy2/8a6l/mzd8PZ8WZN/Or77gjDaESiUTi7zAv3TWHRCKRSCQSiUQi8ZKhrutNaay1FqmOCoctfduRqZwsy8nHjXKtFEIoQoA8z2nWa4bBIJCxZLZpmUwmKCnJsgxrbYy2GSxd1zF0ccAvpYw9AMTG4bLIqfIMJSRSKsqyQilJURTU9QSCQBC39s0wxMF0XmCMjfn+KiOMOfX90LNaN6zbFqUVXT8wWEvf9yipaJp13OD3jr5v0VpvhtLOWtbrNYvFAh/iQDvPsxgzNPTkWUZZFlgbC4R7O3CwOByvZkAIyDJNVU9i/A8h1iaIGIskgL7tcCZG9RT5mNEPKCHQQqBEQAno1itwlkxJqrxgUtUUmUZLgZIKJRWSwNB14AIKQZ7l1HU9DtwlIUTBwJiBxeIgFiMTqxTyrBiH5gIRAgiBlPE6BzJmpeCW44ZCOwZjWa07rPOb4X0/9DRNQ98N43vFTo26qtBao1WMhGrblrZpWa1W7F2PgpPznma9pus61BiBdSQ8HJUpz+ZzpJBjR0ZG8DEmqyxKvHPUdf0MZ0Ge5wD0w0BZ1bGoWWmUUgTv2d3dxY73C8TM/ShodXRti3eePM+pqoqh72jalizLKIqS1WoVxQmdcXBwwP7eAcbYjYiQ5/kYtzTgQnSJOGsoy3LT1WFtFJFeapx8+UlgyWPnn2+r/DIP/vr7+MCHPsEX9gEu8plf/xAf+PUHuQSQ73L61Xdxz9vfyfv/1Tu4owK+epEnvp8n/IrTMdLo0hM8N31/yYWvXHlhx/vaN3juKy7xxCVAnuKmlz/95y1HVQ3Pee6LyN6ffoIP/Xcf4BNftICmOnUrd7z+Xt7xC7/K+990Cmh54tIzP2Xbds85zqW/fgHf3LGTnJTAX5zn/PO4Nuyjn+B9H/gVPvz7F1/QZ0kkEonED54kJCQSiUQikUgkEokbsrW9zWQyJctytNZkOmMY4va1VJK8yKnqmq7ryfKMoihgdAa0bUffD3RdjN9RKkbZZHmOVIqmaTAmRgIppdBKE4Ifc/gD1hgmk5q+H4e5fQ/EDf48y5lOphRZTvAeJSXOWoSILoGjAa5zjqbpMMaS5zlSytENECN3juKKjBnjZkQclB8VBB9t0WutECJu6Ftro3hSFBw/fhylNDrT1PUEpVXM3BfxfCAO6Ych5uMrqSiLmulkGsWGTfEySAQqCIQLyACFyphPJgjnUCGggVxKMqnIpERL0AKqPGc2qaPQAmRakWlJriVaifgzKamznGlZsTWbI0KIooSMfwSB4B3Be6QQZCpnUtcEH8bOhPidSCEgKKQwzPOead6ihMF66AeDGWL3gLMx/9+OAg2jS+DIgSJldAzUVQ2AzjTOjQN258myjHXToJQeexEkXddhjKFtWpTWNOt1PDZRtIruGUPfdVR1vYkjivdrsRGugFjwraMLQY6D/izTY3nygBmG8d5ZI6Qgy3KybOzxsI6irKjrmrKMGT3x89gxZqnZdDJ0bRs7PoqCLIvCiXMuOnqUxlrHet0gpMRYE10KLyJ6jP0x7VONvCdfdyenJez98ad46LJ9xvOvfPZTfH4f7LFXcXYH4BW84uVL7P4X+dyjzyxbZr1g0QM7OxyF6Dzf+33P5K/ljtdUcPh5Pv0Hl3n6kZf/z2d4+Osv8HhXH+JTf/z0TgXL5T/4NJ8/hOp1/4jboj71lODy589UDfb+7LN88ZDn8L1/9izGCQ0tzx35P5Pd0yfJ1pYLf/Qwz/wKLft78dU7O+O3cvIUJ4HlY1+OXRNH7D/CZ//Ds77T74Q8y52vq8Bf4DP/7hzLpx+rPc8DD14AC7e++tbv/piJRCKReFFIrrJEIpFIJBKJRCJxQ65euUI55sa3bRvjiaoybmLnBX1vxoF5HDabweIDYD1aZTjrmc3mTCYOJRXOWRaHh2xtbSHGQexqvUIKEfP1zUAYy3PlmJcfCAgV6NqOIEA5Rdf2lEVBUZR0bRwwWxtLlI/y/YOAupqQl+B8ixCC6XRG063HEumCvK65dj0WGFfjUNsMZhx6e7IsZxj6OAR2DiklUkjcWLqc6Qzn3fi8gSzLGIzBOYf0cBSjE4ULTZ6XVNWUYejiZxSCICXCB3IJmRBY5xBZQVVFgaWxBjleYUbhISAI3qO1oCpLsixntVzixwLfo4aDQECEGFdUVRVVXWOMQYZApiSauO1PkPgQcMKjdU5ZVHG4PQyxM4EjscONJ6JpTIbxc47VLS5ovMjxPkb9DGagLCusd+RFjlaKsig3opKUEussdV2zbtYIIRnGeKDlYrkRcbTOkFJiTBfLokOgaRqmUnJUWi2FpOs7pJRUVcV6tUJlGgRUVY21BoGg7+N33LYNbRvvB6UUSkr6oWc6nQKBvu85tntsdOBE90wg0KzXZHkWv1uhEPKpaKUjl81yuWRraxvvQ4zo6uL7ZKObYhj6zcD2YP8gumDGcz5yLryY7L78JHCZC//nx7j/r05y64/fx50338nb3/I4H/mdCzz80Q/yyC2v4tZdTfuN81x40oI+xRv+s6OoIs1tP/kGPnfhoVi2/EdnOHtTBesrXLh4mdZXnH3T3ZvAoed9v+J7/RSasz/9Zs7+1f2c/+xH+eCjp3nVK3cx3zjPhSczqgnwQhKkJhVX//2H+cAjZzh7U8bexce5dGhhdhtv/idPDcFPvu5OTn/2M1z644/xgb8Yn/vXj3PpsOLWW3a5+Kx+iee/1i/kc57g5MuBy5/ngf91yembX8s9bzzz/JFRp97Ivbd/kU88+jAf/eAjnD5zK7uFjee3b+HUG7jntnFMdOIO7rzlIT7z1c/zsQ9e4MzZU2R7l3j80h7VK0+ze/G7t1fc+qZ3cNfXP8bnv/wAH7rwMGfOnqLq97h44RJLC7Pb38xPvtSLqhOJRCKRHAmJRCKRSCQSiUTixiwXizGTXgFgx94A5xyDGcZN/RiPM/TDZtAeN68t3gdWq9Vmozsvipi1byx1PaFtG4o8j3n9QFEUSBkjimKRrSfTGVkWXQzOe7qxt6Dverxz46Z47G442lCXKmbwr9frTVZ93CY3DIMZnQUOH8CNHQV932OMwYd4zkfb40cD57IsUUpthvlH3RHDMNC2TTw/5+KDmyV+z1FvsZQquhaUomvbGBMkJVop5mXGK7dnnJ7VzIuceT2hKkvMMGCtxXqHCw5rHdbFP84HpMrIi5J+6Gm7DuMcxnus81jvx9d5hJLkVY0fB/EEjyC6ICRidCEoqrxgazqjLivs6C4IPhx95Ch8EBicpjE5g8sIgHGgs5JAFIGOnCtH5c4+QFlWMRZoGFBa46xjNZYUO2tjZFKIHQN934/Hite/77qNK8Eaz3K5hrHDwViDzjQQS4+9j9c8y+J9JaSM36sPqNGRUhQFzjrU+J1557h27er4fegYbzQKAFrH+COlFM7aeN/4sLkHjuKJzBjTpFR0pUAg0xkgaNuGLMtiXJcQKCkpspyh6yHErpCje/dF5cwbePNrdtHtZc4/eo4vXYob6LPb38H7f+k+7rxlF/v185x79BwXrmeces09/Ox738XdL3vaMU7czbt+6T7uvOUk2fULnHv0HOf+4grVzXfy5p9/N2/70eqG7/c9U53lbf/NO7nnNafIlpc4/+g5LnanuOtn3s29/wBeULfBP7iXd//sG7i1u8i5R89zqZ1z+sfu4z3vvY+zTy+N3rqTf/GL8Rpx9QLnHn2cq5NXce/Pv5d7f+R5djm/58++y50/dRenJ5q9vzjHuT89/zwRTEdozrz1PbzzTWc5VbVceuwc5x49z+XhJGd/4m285513xxgiAGbc+c/fw30/dppdrnDh0XM8frXkVT/1Lt77T1/1wrZS89Pc8/Pv52ffdJZTxR4XHj3Huccu0c5Oc+db38N733qWv2HvdiKRSCR+gIhwtKaTSCQSiUQikUgkXlLs7R1s/n13d/tFff9P3f9vKKsyblxrFYti227cltdIqWibjq5ryfPYlaCUZrE4JMs0TdPGfPqioMhz+r5nsViws7NLINA2DVmeMfQ9eZGzWq1wzlMWRRz8asnW9hZN29ENHUM/gIBMZdH94CzT6YTF4hAhYL1eR7eDkFjvWS9XCKGo6oqmaWmbhiAEy9Uqbszb6ICwzmEGg/Oew8MDpFDUdQ0ixuaEEOj7GAFijEGr2APR9x1SyY17AKBdrzncX1AVE+pqBkLEMuDpjPl0m2Ho2Nu/jnVRqMiE5NUntrj95DEO9w74s6sH+HzCEDxXrl9n3a3xY9Y/sBEmsixne75FWZRc3b9G1/UE7/E8Nfj3IaCkZms+p6qnrFdL1utYmEzs/0UKEQuYpaQuayb1BOsDV69dY/DxmmghmBTwX575Fm985de4eP1l7JuSl00X3Dz9Bl+6cpz/+c922WNOoUukUrRDjxxLpUGws7NDCIFr167wspf9EN14PfMsw3mPdw6lJdZYnAtYZ5lOpggpcGMht1aKtu2RY8eGzhRVVaGUZr1eYYYBpRQ7u8fQOgoSWZYDAWss1tpoqAiBYezSADb/rKqKvChYLhZjpFFGnuWjqKAZBoNSEiGi+8F7y3w+Y7FYkmUZq+WKoizw3jGpp2zPt1isFuwf7JPnBev1mkxr6qqmazqKPBtdDhalFD98+jQ/8y9+4fv3y53g3CffxwOPneINv/Qu7j72Yp9NIpFIJP4+84P4b/rFYvF9Oe7TSY6ERCKRSCQSiUQicUPyvCAEuHz5Mt4FvIfJZDIOteN2ewieru/GbXxB33fUdb0ZxDrn6MdIm77vx6JfMXYaCMxgoutBxYx6QRyWxz6DjPW6oetajDGjWBHPSeu4G2vH43gfS3UZy5qHvkdKhbWWaixn7oYeP27Jx6LfWJrb9/0YoTOQZTlFkSOVJMvie/RdxzA6MdyY8W9tjDDy3iNlHC77cYPeWrvZxg8hxFLgPMd7xzAMEAJCCLRU5Drjlh86yYmteRQopGZwlnXbsu4aBucYvI9OgxCwwWMJCJ0RhKQdBpp+wDgXH/fxjw/gie4MmeUM1tIOPYO3DCE6F0yIxx28xwfQWYEnYKyJTg02BgwEHiUcAc2TzYTrbUVnFAKwLmB97GfIyyJ2XQgxxjpFR0HTNPH7lXLTGRFCoBu38qVUsTA7BMqqjLFR4/V23uO9QypFlinKqmDMWEIpNcYXHZ2oGJ0GMVJKCCjyAjFGFInxNWVVjWKO3YhAfixmzrKMsihRSjMYg7XR0aB1FM9i7FWGUhqlNGVZjo6bPEZoTaZ478ceBslstoW18X2GYcBZS5ZnCClxzrG1tUVd18gXuSPh7wcX+d1f+QC/8hsPctE/8xF7+SE+9xVg51ZelUSERCKRSCS+K1JHQiKRSCQSiUQikbgh1jqkkiilWS1XDKZnPpsymDgoVyqjqmqOHTuOszHuyAwDRVmMUUI2DmXLkqZZY4xhNpvjnBvjY+JGvBCS1WpNpnOstZv4GeMMZuix1rJer9ne2Wa9XpEpTV3WCHKsNVRVFUtslWLv+h5lVWKNxQyGw8MlVVWS53nsKhi3z49ih5y1TCZTFstFPN9RoAjeYbwlywqUVmDigDpojRAxHz86MBRFXsQNeyHIxwgk7/1YIJzFiBsfWK4WdF03ljpLhAzkuUYXNZebnovLhgbJYr1msVowWIsLPhY+AARBAJRQ6CKnHQbapsG72IsQY4T8aDaI76GzHGMsbd/Sdu0mRkpIxsE9CBHItMZJSds0tG0TnQ2BTWmxxKGEQwrLyVlL2Q3Myw4hAg6FD7GzQIgxnmi9Yrq1TZZlY2zUQFnO2N09hjEmuidCHOwba8iyDO8dAmibhsl0uonLCsGjRlHIe48UkqIu6IcYR3UUwVVVFfP5VhSoTIxWMkNPpzq6tiPL47D/SPB6ejSWVIr1aoXWmmPHj0c3g9asmwYhBEVRsFwuKYp4z3VdhxCwWq2oqgn7+9dHQcvjfRTXvv7Ny3jnqKp6c79kWjOYAYTEmoFJVdP3A85Zrjz55A/4N/zvI7dyxx1zHvnc5/n4Bx/j9I+cZrcAu3eRx7+6xMpd7vzpN256GhKJRCKRSHxnkpCQSCQSiUQikUgkbohSehwMa8qywntHXhQslkuEUMxm1VhcnNM2Detlg/eedbMmyzKsdZsS4lg6m1MUBQcH+2R5BoA1Filjjry1ljzPo6NgGPAhBvUoqSHAarWm6xry6ZyyLPDeELyg6zqqqqLrOpz3DIPBWjdm7kv29vaYb2+BEHR9Pw6tw+iYsDFnX0dHhLVjCfB6RZbnY1eCp8gLdKZjCXTXbcqYZ/Mtqqqm6zvsWLRcFAXyqMhYsCkP7k0/bsTLcUgv0Epybd2yXq14EsWiW3OwXjBYgwshRhmFo8pjQAikikP1ru0ww4AQTz3vaDgvA0gVB9vL5YLODvgjl4GUyAABDwiUkAitWbUN69US710sGfZ+E00kBUjhEQy8YmfNlfWU4AUBifNgfcAYi1IGrfQoQEURQiAwxgAxKsoMQ3SwCEGW5/RdLFNWKm7oHzlEsixu7WdZvnGRGGMoCgdkEAJt025EGx8CeZHjfcAYw2QyYbFYYLsYoxSG6CrQWm+6FKJQEcZOip6+72iabCNa6E08U8BZyzAKJU3TAIHd3V3sKIQc9Wo0bYz66vsBKaMIpJXmcHHIzs4O7WDwwW0+0+HhAdPpFGvtD+T3+u87p3/y3bzn5Q/ywB+e4/Jj57gEoCtOveYN3P2f/iPOHksjkUQikUgkvlvS/2smEolEIpFIJBKJGzKZVhhjaLuGQIwTstaP0T6O/f19ZrP5ZuB8VF7bd13cZCfGxRhjY9zNGN0ihKQoY3a9URIzmHFAXG5iZmKJcUsgUE8m1FWNUBJrepSSNM2a1XJJWdUE71kt13EQG6BtO8qiQJdxyz0Iyf7+IV0bN/KlVBBAaY0QkuVyQZ4Xm83zEMLYoWBp+jVaKSaTadz2F+PmvYzRPcPQQ4iDa4HAO0+e5+DjZw3e0w/dOFCOg3MISB9FhBA8Xz/YxyNYO8dytYzRQuNgPEAsoB4jnEBivaNfLuMw3DmEiNcUIQg+viYAIgTW7RrrHYxOBEQ8L+894qgVWim6vmPobXQFCBDex2iiIJAyIIJAiYAIARcMlw8DIkw4MZF45NjdIAk+gAYhFW0bS5L7oaMsK/phoOtjSbZzDqU1Wmns6OCIg/R47ZumYTqdMgyGqq42Q/0QAt57+qHfuDCcc5RlOXZZ9FjrMCbeU4wFzgKBzqI7xIcoAg16IMtjwXcgUFU1RRm7DKQQDMPA1tYWfd/TdR3z+WwUCQqsMdFRIwVFkTOZ1HzrW9+iKApWqzXeB6x11HUZo7msQQrFetXEexBBVU8wXexKOLqvEn8baHZvv5d33n7vi30iiUQikUj8nScJCYlEIpFIJBKJROK7Ig7VC7JM45zCubix3zQty8UqltHCZhA6DD15XsTNcxM3/ZWS9L0ZHx8oigLvbHQchIAbnQ5FWcTyY2s3kTaMrzna7K/KEiklXRdFBq01vZTYsWtBSIE3MTan69oYNwObWB/nPILojmi7boyp6WPs0Sh0rNdrqqoah9SWqiw35cRKKoQQ5FmOVCoKLW2Lcy4WFwsBSiCUxls2mfqI2PlQFiXWGmSuEAHc0HN9sWS6NWexXmGNIRiLcg4dPBDIMh0jiVyUCKTpCSGKFCEEbIgD7TzLaYY2ujiERJoBR0CKMCoL8bxyrRiGWDwcJHgLgwt4H4UFMQ7IldZ4a/EhQBiPg0OIQF1qprmNl0VoUHrjIJBSIxAoKTHjln3fRzFFjOXTUkahyTkXy7HteF8Ej1KKejJBKhW7JzYxUXrjSshG4aofOnSWjfebpe97nHUQAqvlkhDifZPn0Q0jpMQbxzBEZwoEtM5Zr5bUkwkgcM5S1PXmdyCKEgO2jPf1MAz4UbyQUm26MuK9rjb3kFJHzofoJinKkraNXRFFlpP7PN6jwTOdTqMYlEgkEolEIvESIgkJiUQikUgkEolE4oZYa8aN6wLnLIPpOTbbpetiaXJ5ohqHwDGeyDlHluVjUXKMhOn7nrZtN/E+R2SZpq7rOKivys32uhSKtm3Hob6grKpxkGvRWSCTGW0To4WGwXJweEjX9Xgf8M4ymc7i8FrEouFcK7rekGV5LMBVPubjh8AwDLEAehwyWzsOop0bRYc4BDfjz32IcUg+BIo820TTeO9j0bJSeOLQXnE0lI8D+dilkI9iSIXSivVyCUoDnq7tGdqWzA4UZqA2hjpEJ4HqA8J5cA7lHWUAvMUBgw9cdw4tA9tlydVVg5SCSsW/9kkhCVLSeEAp0Bk1E1rrMIBXig5B4wOdC9HVICAIST2p6doOOwyEYBHCAR7hFbntqIoOicA4iVDZeG3Ah1jeLJWizuN1D0fuh7EMu2nWaB2Fh6Py4kCMAMqLYiw2lvR9zzAMm2F8lmVYZwl9QCpJP/RMJtNNXNGRYOJcjNWK5dyevCjoupa6niBlLMau6pq2aQGx6fQ4EoUgloWvVkuMiT0ch4cHo1MllkCrUdg4PFxRjt0YUXgrR4Ek3vN5no/CVH7mjaIAACAASURBVCyYzseopsODAyRQTyabXpBEIpFIJBKJlxJJSEgkEolEIpFIJBI3RCmFlIK+H2LHgY5D3sFYwJCN3Qgx9mWOHouVDw8PMcYgpdwUD4cQYqmtVCyXC44fP46UisEYlFIoqWi7jkzH7Xsl4ih+uVxRlgUg0CqjaxqMtSitsM4jZNxqt8ZRlvlYtGspigrrzFh+G7DWRLFhLOsN4xY/hFhMLGKOv7U2ljfbmOGvlCL46Izwzo1xOQHv/FguHfPxtY5b+EPfIQKITCFlHIaXeU5ZlpRVRZbnKKlw1nB1vUKi2JpW9FeuMLn6LbabFcXQs+UGtn08OxscuFhErIEJEILDixiHpL0nV4K5WSHagUxKaq2QPiCFRErFygXcGH9UtQVIjUfS64xlplmjWCEZtGbtwXqB94HJZEoTVoQwEL0dAe8HkBWtzREyw3qF0lnshA7Qd2MXhFQURTH2CYD3ASnZuAq890xnM7xzSKUYhoFyPkdrjRvjj+z4nQghsOM9pbMMZy2xuyEWRFdVFe+nIbpLxPi8o0gtM4pGzlqKskJnsaOjH3ogChRmdLUQ2JR3H0Vuef9U4XNVVdixV6NpGpSKbpYoKjmqqhrFMIUb78H4+yTHCKzx/YylriqMsWOvR+pISCQSiUQi8dIiCQmJRCKRSCQSiUTihoTgMfZoCJ8hlRxLftuxANdvnrtarajqmqIoNuJBURTosYT2aHjqnMNay2AM/TBwcLBPWRQ47+nadnQ/OPJ5gdJqFC3Gwt7B0A+GLM+QUqF1TpblgGAQPbP5PLoXrKVpGtbrFVpn8WeD2WyHT6YzhmEYt8Dj9njX9eR5Pm6Ve6yzOGfRKmMymdL3HW50JgTv0TrDmhhp47ynLiuGtgUfECIW+E5mM2azGWWRMZ/P2NnZQWmFsY7lco2zltz15Ad7ZN94gu2DPXLbIN1A5gYmSmGzElsWUChkliOEguDQWsQYIe+QWU4mFaV3FJ1BCkGuJN4OHJUpzxAsl2v69ZLKrKiyHIWKQkQIbKucUE3pqpJrOuObTrFertg98TLm2zuodcdR8I7zQIgCEKrGiwIpNeu2i8N258jH2CBjLd5ZrAs465hMpoCgLCukjOKUd44sz0cRQGycInoslRaAs3YUGDx5ltF5z9Z8zuHhIcMwcHhwQFlV6DEWyXuPGQa6rgME1hrqqma1WsWi7TyjaZqNk6Ce1CwXC9qujRFKxpDnGc46jBywxlDVNdYaptMJ0+mUvb3/j723j7HsvO/7Ps/bebkvMzuzu0NxSe1KWlFLlit1JYuNmFhuStUMXKqRCgkuC9No1UJFKgSqIaW2AxmwXdSArMZKqhQqEBdRATMt00iFpZppQlUULDqmYsriRhxa3NBriStpSC6X83bvPa/PS/94zlwuJVLLSHxT+nyABWbunD3n3HPOXez8fs/v+9lBSklZFsvJlNFoTJZljEYlXWcRwgzxTPFztFjMcdaxtr6GczHyajZfQAi44F7Wz3cikUgkEonElUiNhEQikUgkEolEInFFtNbLmCHvPZnJ6Nq4gltKiVaG2Wy2/HnXtlhrlzE1eXGwkjsW1pXSSKVQQ4E4yzIyYwZBblyN7b1HG0NVV1RVPcQfxZgh7+UQEZTT9f0g3g2EQagL0DQNxmTRhSBilEye5wRgfxZz8A+EvQBZlg1y3o6iKIac/Xq5P2NihJGQcnAjmOVqda3VIDoW5HmBbTsyk2GtpcgLjhw5zHgyZmVlzNGNIxw6tIYUgrpq2P3eg6zZlslsH7H1HdTOJbS1FMoipSdIjzISmQmyMvoVTBGbJjpEUbOUAiU0ZBohFMprupEhCDFEBuW4IEAoXIBMBewowwSLkdE/YFzAdz1N1SLbBabZJytyhBqxJz10K0zWj0CYoIwGqShNy+sOB5ASHzJ6D857iiJeW6V19AUYQ28tQilUCPQ+rs6XUpJlMQLrIPbK9j1aG7xzwz2Nf7TRMMQkQUB4gQ8BrRQIEYv+Lk44TKZT8ixHK03nu2GiRi5jtw6eua7rKEclXdcxGo2WkygHPxdCLD0dchA1Bxj8HtlyoqJtGrJBzn0Q43XwvBqTUdcNXdczHo9xzrFYLBBAOSrZ3d1FCIE2Gtt20V/BKylbvsi9v/NJ7nnqNHd8/A5Ov8h73/xHv8qdD21w60c/wi1HX+Sdvwz8ZJ//v+G9fepePvk793DxzXfw8V8Ytn74Tn719zbZ+NmP8JF3bbzUJ5xIJBKJVxGpkZBIJBKJRCKRSCSuSGwKaPohfghiA2F9/TB7e3u0bTfEyozoug5rLSsrqxRlwXw2I8symqYhy3KEjMVipTTaxELzfDZjbe0wly5djFMIWZxgkEqzs7vDfL6gbVtWVlex1iFljJdRWuOaOkYVDcJmqTU7O9u0bYfOcqzrIIDte6bTKV3fMxqNlnJciPE1cmgQlEWMmAnBUxQlTd2Q58VS8LuYz7HWMp2uDE2IEKOcyhIpJMbo2DhxDtoGrTVra4dAwvqRdY6/7gSj8Ygiy9l/4iJf/7NvcPjJLUw9p5waql6SY1hTmkJB8D05Hq0d3u8jekURQATIlER4h5EarcE3PUJoCJK699gQpwa8UASpcULihWCsJGIlJ89GBCFprMOrjFxmPF117M8qmu1L6LbiNXKfVb+KXT9EVmTk5Qbl5HHI9tFBoUJPcB5PhnWwqGquWt/AWkfX9WRZhic6JfIsw6mwjDMKxCig0XjM/t5ejB7qe9bW12nqKGU+aDQcPIdZlgGBjh6AyWRK0zRRki0k5aQky+IUi/d+EH0bVlZXcc5TLRbRmZBnIKKLYTKZ0DQNbdPifHQaFEVJnsVtqqpCScl4MkHW1XIq4uBZ7/sO5x1ay9hI6nvm8zlFnqOVoixyum5wbgzDOyurh6LnoR8aZ84PTQxHUSZHQiKRSCQSiVcXqZGQSCQSiUQikUgkrogPniLPo2jYe3prmUymCClRStN1NULGVdVjOaKq4vdFUTCfz7F9XLltSk2W5dRVRbdYUBYlhMB8MWdldXUp240r/jN29/cRSLRSVFXFa15z9RBz0yOFxNqepm0hQLeIq8oJgbbr8SHQNg19H2N9mrYlAIOrFzG4DqSUQ4HXLyW5fdehTcznRzDk8EPXNkCUT1fVgqIs8d5TlCVCCJzzBCDL88sy/VnKdh/feoKyKDi0OmXkA3ubD5Nf+AumruaqN72Jtpmhuz1WvOWokRSA8gLfVmjRE4SD0DIKHm8hDwJvHZk2SBEIvgdtENpg2hrrBN4G2l4gtcILgVYKnWXYPjARJUIbKucJAQ4XJevTkktS8ER2lLrukYs5ZjHDP/0EfjxBH4pibRc0B2vnpdJIpdF5SZarKDomirR98PTWEQgobYY4pthAgthUsH1P33dDdFSLVnpZdI+TAPEaHkwIFEXBgcC6KAsWi0V8djITGw3BI4QZphAkRVGgdZR3H0zX9LbD6Cw2x7SKUVUhxnDZ4ZzKslhGLGVZTtM0cYqmjwV/Y6JPI8tzqmqBlCtkWUZRxsaTVHFyZjKd4LxHygPXQk6ex/1NplOqaoF1FqM1Ssrl85ZIvLhscMtHP84tP84ubryDj3/8xTqfRCKRSPwkkRoJiUQikUgkEolE4ooopcnygqxt6bo4leAD9HU9eBNiEX59fQ1jDDs7O4M4tqMsS6q6ou868jynbmrquo5uAmOo6xqlNe0QL+OcixMBgDEZWRajYrTWZJkmBI8QMcJod2+favApdF27lCH3vaUoy1jIdwo1CHerusF7P+zPkGWGpolSXoiNByElIXiCD3F1OtDZHuccQkrG48kyTikeTy6Lwl3XDkXgAD4QhcSeumlZzBfs7+0z295jhGP1ycexmw8y7fd5zb9zI1edup5L//KPWMlyVNVj2hqQKGGR1mMI+BCQwqN7T9cNS9t9wEkHWsRopxHoLJArQaYEXnh871HWQSA2fPoWbEC7CqkkRQ9ZFsis5IjIOWE0f7ZyFd8aT+g3DtN+53HUk0/g9ncQ151AHpuDDSCjdwAlQAqk0kynE/quoxiVMQao7wnOYvs4TeCsw+QGIRgmXGRsNllL08T7M5/P8MEjwjCFkGcoqQnex/vXtCityLIcY2JEkTGashxhrSVXMUKr62OsUde1tK3noPlwMB1gpmbwZ2gIgdFoTIhb0XX9UvA9Hk9wzi7jsqyziE4MTSjLeDSiVTEiKjYJitiMGpVLaXM+RB9JKajrCu9jI8U5S/ABAkwmE8ajEZcuPfUKfMoTiUQikUgknp/USEgkEolEIpFIJBJXRGmFHPL/nasJIVAtFhhjAHDuIHIGuq6lKPIhC37OaDReFu7rqkIbgzYG5yxtU+MDjMoRglh7ty5Ki53zmCyj77rlSvG+72nbBikli0XFfD5HCIZYIknTtkills0JIcTgPrCUoxGz2QylJHmW03cdWZZhtMbaHjGIf7uuQyqNyTKUd8vGg9CSIi8QUlIW5bIwHELAWkvwHtv3OOli9I3SSCFBgO07mroh04a9i5foH38MvvMo63RwZIOV428gPPkEV/VxVbzINPQtEpDe4YVAKkHoY5xPcDHGKQDBgwNEHwgCRGfxmQQkgQAqIGUg9HAwkhGCBw94j5Cgg0Q5j7GgXUuGpseDWONisc78mtcwu/Ad5O428ntgT2o4rBEi+idAEZC4EAgEpJKIYTU+MnoaKAR93w33S3zflEG/jMVSStJ1HUII5CDrJsRnDKILwQ++i8wY+r5jMpmgVJQdV1WF1jpGHcnYcKqqCiEEo9EY28dYooO4pADx+RycFxCfp7Zp47OS5xijn2k4AFpHX8bu7g5ra2uDFyJOpTz11FNIKej6HilVFEZ3Hd7FaRsp5eDuiJMZbdsjpBxcDIK2bcjzV0m0kd3m7O/fyefPblFb0ONjXP8fvJf3/fRxyu/f9Omz3P1P7uGBC9tYD2TrHH/brdz+7jOs/9DKw5Dbz6185ENvZPOuu7j30W2s15RHT/LO976fW05On/1XZue57wt3c+8343khNdNj1/MzP/ce3vn92z6L83zuN3+XB7iJD/76+zj5zNnzwGd+jc+dg+lPf4iPvfv4Zce6n0//1ue5cLknAMDPOP+lz/K5PzzHdnfZ+/3rZ1iXPIsXfG0G/8DpX/w475F383tfuJ8LOxakZv34Tdz6n76HM2s/7Fo++3p+6H01f/AP7+NCpymvvZk7/uubeOzvP7cjYftffZ67/tkDy+Nt3PjXeP9feY7d/4Aj4bL7999ez/l//Fnu+eaVn5fvP976dbdw++0bfOU372Tz6K185KO3kAwMiUQi8eoiNRISiUQikUgkEonEFdGDHDnLoji2t5b9i08yKidoo5iuTBmXIwIhFkaFgCBo6hoCBO8JUuCDw9YWk2VYpem6lrwoGY1GhBDYn82G6QZN0zQsqgUhBIqiROuYn980cRV83/c0bcN0OkUpFeOEnIvTCUVB3/c459FaLeNtdnd3aRuHyTJm+3sorZlMxuzt78VCsxmT5bHIm+fZUsYcpyT6WCQXUJYlPnikiHLp2f4MIaMg1wyiYCVjZj8BmmEKw9FQ7O9waOtbHKImjAxHbnwLa+WE8M1/xbjZxzpL53s6oXAeCBJPhw0CGwLSBwyD+0CBjIvpcQK0HLL2W0eQHhcCCPASxIG/V4E3AuugN4Kg474E0Fug82h6rjL7OO8YeceTq1fTX3uM3e98B/XkHt9+xHDiKsN0JBBaAvF+ByQ6LyjKMSbPkUrRNA3j8YSqqmjaGmOiWyDGE0W8D0OB3SydA1KqpbdCm9iEyvMYNRScRQhBb3uaecPq6qHYnBBQ5AVKSYRQeB8bCePxGDnEcGmjl02pg6mSg8mZEDx9b8myHBBkeUGeZ5TliP29/aFx5Icph4Ysy1hZWaFpGqy1OOeYz2aMJxNWV1ZQOkqaCTGGK07OdMNkghyeLUtmzPBcQ7WoGE8mL9tn+/k5z+d/+xPM6inHT51hnW3Of/MCm3/wabZ2P8QvX1Zsrx++k0/83iY1munrTnNyXVN/b5NzX72LTzz8CHd85HZOf38l+fvxW9zzu/eweXHK8RvOsG632Hz0HPf87ic5/97/hg++Yygr15vc+ffuZLPWrB8/zal1DYstNh/d5O7fPc/3/vOPcfsNz1fqOMmpN8IDDz3CIxfg5PItPMaFC/Gr2Xe/x4zjHLQj7LlHuACcuuH6y/Yz4/7/9be5ZwEb153hzLhm6xvnuPDVu/jETs+vf+CmZeH8R7k29dk7+eRDj8C1JznzesP2+Ue48O37uetTM/TfvoPT2RWuJUD3Ne76B9v0157mzHSfC/IaTmTw2HNsevFLn+KTX9wCPeX4jSeHe303n374BRznAL/FPZ++h81L6/F5sVtsPrrF5h98movts8XMy+NJzcapMxzT25w/dw+f/jvlDzQcEolEIvHqITUSEolEIpFIJBKJxBXR2hB8oOticT7PMupFBSIMMty46rxrWrSOctxOxdXnzjm6vkMKwWg8xnsfi6pFEVf/C0HwgaquMcYwn88BgQ+eru9RUiFVLFb3fY91DmstCEFZjghD/E3MrbdD9JJ+Vh5+XO3eLwW5yjsQsfBc13EFuHc+NjbyYnAlgDEmOhDyHCkEhBBXyktJcHEaYTwes7e3R2YyjD7I5R8RvIvi5rbH9T3BOWQ1Z2Xr26zZPcpRTr6xzqlbbmX05/+aHoFQATpLCI7OhyFmCQa/NQiQCKQ2CGfxYpg2cMPKekvM5bfQEJAmXjcvA9IEnA+ITOOkpAsO5UHZgOscJQKtA8pB8AHtLIdlhbEwv+i46tAGu6MC6yyPfavlz48JTt8AufQgwyCfiJMGcSpB4b1DiOiMaJqGPDOAiM+DkhiRYft+eZ3dsCrf+4BSMaqpKEuMNsydWzZrnLNxSmRwJsQiffQdTKYT3DCBUtcVECiKAmvtUo5tsgytTYzDCrHZoFT89bjvLVJJRuMRgljwr+sKH2JEVPQ7RI+H1oZ+kCWrYRLGZFl0eKgxzjqkkEgpUEqSZTl+iGcChmdJIaREax0F00rR1M3L9dH+IdTMprfw4V+5lWMHlYMn7+GTf/deLv7pA5x/9/G4or9+gLv+0SZ1eZzb/saHeOdVz+xh+2uf4e9/9iyf+79Oc/0vnP7hBYinN9k89k4+9LHbOH5QTX7yXj71P93D+S/czdm3fYAzGWx/9V42F3Dq/R/jA2+/rOx84W4+8Q++xvmHHsHe8PzHOn3mNDy0yblHL3Lb8aG4feERHolJYvDt85z3N3NGAlgefOgccIrTpy/fY83Mn+b2v30HZw46Dv/xWe78xF1snnuAs7ObuHn6o1+b8w+d5/Qvfow7bly2Izj7e5/groc3+crXZpz+yz9s6mJgbxu+f7qCiz+43VP3cucXt2B8mjv+1h3PNDXqTe78O3eyubjyoYDh/t3KR37jFjYOJjIOnpc/uo/z7xomQPbu467heLf/0mXXr77A5z/9ae5/ocdLJBKJxMuOvPImiUQikUgkEolE4v/vdG1H07T0vUXrOJlwdOMqVlZWWFlZIctyZrN9Hn/i8SiOtR3OPyMaDj6gjYl586MRZVEyKsf0g7S263vcMIlwuVRXSBknDYbV3gGJlArrHF3X4ZyjqqqYgT8IcQ8y8fs+RiI552jblqqqAIZ4GrFcpW6tZTyeUJQFeZZH7wGxARJCGCJ1IM+yZSPiIHonyzKU1qytrcXmA3ECQCmFs7GIbjITY3ycY2XnEutPPcZkrAha8IbTZ3jNT/17TDeupjAZ6Iy2t/RtC84SgiXQogVoIdBKIFWgD54+QOug9zBYGbABXACHobWSIAxKFUijUIVGlmqQMWdIIZBIpBPIINFeYVTsB3gLeEEZHIdVw9XNJU40T7GeSbrRmO05/OkDFXt7Gu96CD0Ehw+Brm3Z39+L96RpAfDOkeUZ5WhEnhccOrTGdDpdSoe11rHB5Owg3NaDEyOLTYAhOivLMpRSsfHgHMF7MpNRVwsgYIymKApG4zFZljEajYft9fJeHkwRHAifjTFMplOMMTgfzzNKuOO969qOS5cuIUX0LigVXQxGZ0uJuB28GHEKJsZh1XXF9vZ2bC4Yw3g0RghomgatNdPplPF4wnQ6Hf4+g4MhJyB45Znyzvde1kQAuOoMZ44CdU09vDR78AHOeTj2rl98VqEcYP3tt/HOo1A/9AAPdlc6XslNf+2yJgLAVbfw/p9eB3+OP/7aDADr47XaeXqHZympj9/GL/8Pv87Hfv4KDYvrTnEKuPjoeWYH7+G7jzHjOLe+6xRwnvPnhx/4Rzj3KHDqNG/9vimAUz93+zNFcIDyDGfeCNBw0Af6ka/N627lPTdefiFKzrwtBjE1dc0LY8qNbzl+xa0ufuMsF4f386zJiPI0t9926gUeK57jTT93WRMBnvN52foX97PFc12/47zn3TeliYREIpF4FZMmEhKJRCKRSCQSicQVcS4WdyMxu14rg7U98/kCrTWz/XlcqR88TVMvxbRSSMbj6Emw1lEtoifBOs94EleP930/SInroVjfxox5pQhA07Z455lKhZAK52Kxv2lq5PB9jLYRQ2RMIM8LQggYY4bMfMF8PmM6XaHrWqSMy/zj9IEfcustAoEbmgkH8Tex+RAQXmKdQxqJkDG2plosOLS2Rm8thFgI79uOEBz7s30moymut+RtxcrOU1w9FbhgGesCPUigwxveCEeOIvcuDM0DgdYKY0B70AgEASc8hIBCgAkID7mCEESMkBIgFWjtyaRESZDBIUNASDBAEA4VwFqPd4CHrhdIIXCNxPc+rtKXIEIgw/LawvBEtcuk0ZirjvOdRc3WE/t8Y7Pl5r8kGY8tQUic9WhjotNBSkxhYGgmFUURi/XO0jYNWscYIzk4Euq6IstyuralCQ2rqwVSSezwbBzMO8gh6ojhewQoqbC9xYfoszDGLAv8sfivcM6ilI4i5OG+jicTFvO4BDoM0wcHTSs1PB/WWeq6JvhAWZYYY6JjQkA5GuFclH9bGydltFZY27OyshpF0VmGlAo1CKAPnBBVFRiNRnjvo5Oh6wgBuqEh9sqzxvrz5vFvc/Fp4DA89q2YCdRs3s1dW8+xpQW4wIXH4KbrftjxTnLqOerWx647SfmVbS58dws4xcZbznDsS/ew9eVP8Wv/Ysqx15/m9NveypkbjrP+QiJ/srdy+tTnOHfuER7pbuamzPLIuQtw+BZOn9FsfvEc5799Ea7bgG+eZdPD8VPXf1/xpGRl9fnKKRe5eAk4+qNfm3Jjgxcwc3AFTnDNtVfeamvrIrDBiRM/+H70dddznHNceEHHO8qx11xpmxmPXdh+3uNx3UlO8gCbL+h4iUQikXi5SY2ERCKRSCQSiUQicUWklLRtx3y+wBhF10q89kihWMznWNtjrSMv8qGQGsW4WZ6jpF4WaHe2d1gs5kOhv0QN8TdSxykD5xzexeiXrusoR2MWi0WMR+o6tDFkWYYQYhlHk2XZsAo8RMmyUuR5NuTPe6ztMMZgjEEI0FohRAbE3HqtzfCaQEqo6yjZPdj+QKQsRYzrOTiu91GWW1UL6rpGCEE5GtHUNc47hBBUVcWonGJtz2R3m2m3S8gcExSHaJGPnUM8cQFxzbXoM28nXHgQrTXBOoQIFKFnrD0+gNYS1wsEgnKc0dQNAY/x4BygwQqJyjN0JpGtR2lQ1i+vl3Adzlmk8xA8WgqU0bje43ND0zpwkAHCBQCc94yNxfSOq7MRjViwvXaY6rszNh9ueMOJCW94vQOh8V4ihUBpAwF88GQmBwGrq6vM5zOULDBKg4CqqrB99FpIKTFZtpRXWxtdGm3bxhgqYlE/z3Jc05AXsenQdz3FypS2iw2ExWI+SI0VRZ4PjaIwyIzlMhZpNBqDiK+roBCFJMuyZ1Z8D36HEGJs03w+oxyNgMBisYAh+qrv+6GBBnle4r0lywxCSPK8oCiKYZInehDKokBKxd7+HhBFz13XIqRABkHX9RjzamgkrDB93mq2jbLuy9j+9lm2v/1829fUV5pIOHrsueW6h9aYAvUgGufoLXzoo+t8/v/4PA9+d8bWufvZOnc/9wD6qpt4/3/xvisIiTXXnzoO585x7lG46cbznH8UyrefZOOw4eTqPdx3/jyzn93g4rnzwHHe+ubvvxBT1g49/xHsj3ltpqs/fhsBojPlh3OR7edIO3rmRKasvOCj/bDn5YCaegHP26SSqUSVSCQSr2bSv9KJRCKRSCQSiUTiiggYitHPVKaEjIVyrXUs8OY53jl2d3YpijLGDi0WUZorJF3XUTcNPsTidFHk7O3vI6Sgry1SKnrbMypL9vfrWLSXEq8UWsevBTGeRitF18eV21KK5Qrzg7ghrTSLqhoy+iXWOoQYpg2cQymNkorMxEmFtm1j1I3SeF9BCFhbcfjwOm3bxgaFVGTGwNDkEELgrGU8HrOYz8iLKPlt2za+f+/wiyhk1n2PufQkK6onlwFhPSu+prx0kf7sn2D+6rsp3v4O+j/5InrW0s720Laj71pcERsFMgRC5+NsQmaRw/iBUSCNgUygpQAFEJAyxikF5/BtiK/5gHdRMGz7QCFA4NCADB7nA85DL6BqwRhABYT2rBjF6/D8xdMXWc826Moxi0XHX3y759jVAlUIvIeu6ynzAu8dRseGTvAe7wNN21JkWXyOAoxGIwapAkVZYnsbGx5CxCgi69DGDBMMOoqzlYjNEBkbUW3b0NQ1QoplYV8IiZQeZ/TSv3AQo3SA92FZwK+qBdOV6TDd4mLzwcepAwFDXFZP8J7JeMLT7dMoqZZTD0KAMRlCQJ7nTCbTQRptWSyqQfQs0UrSd7ExcSBY9t7hbWxKFUVJdIFcMQfoVcaUd37oY9x25SSd5+fpi+zADzYTLl3kIlFwfoA+fIb3/c0zvM/WbH1rk0ce3uTs189x8ckHBrwqPQAAIABJREFUuOt/hunH3sfJH1JEn974Zo594UKcGJj+Oec9nDwVo4NOHIf7Hj7PY36Dcw/VcO2bOf1j1fVfhGvzkrHB+gbw1PP8uKvpX9TjlZRj4KkdtneAoy/qzhOJRCLxEpMcCYlEIpFIJBKJROKKSBUji+SQNy+VpChKrO3Z399brvhumpa6bhBC0tQN1aJmd2eHxWJB3TQoremtRRuDUIosz+mdo2lb5FBA1iYjAFrpKOWVgjzLGJUlQgi6th1kvJrZbJ+2bdnd3aVpGqyzaB2bBFJEuW0sQMbzK4oSKWXcT99htEYriVEKo/XgRwiE4MmG1fBCRJ+CEHFKYXV1dZhQiPFDWmukUthhxfR4MomCYGOif9g5VLWHnu0yUZ41bSlExwSLWcwJmw8Sdi+hXnsC9eabEdN1JpMxpewZ5xotFJnJyLRAI9DE2CGVZ5hyhFoZoydjdFYipIYgo+jAWYK1eOtwjcPWPX3l8VFnQHAxukgM3xjbkQkGH8Nw34VASXB9YOwdh13NSlVxXLZMpxNwgce+a9ndz+h9RyAW6P3Q1FEqFvKFVNR1hVaatu2GVfgdo/GIyWSKcx4lFdpolFJDlFT0VAgESivGkxHOWXZ3trE2Srqt6wkEur4dCvc9bdNQLeY0TUPXdYQQpdirq6vkeT44OECI2Mgoy9iQsH2MXMqyDCElSqtnGmhSMxqNWFQLlNZxukHF6YbxeDxEfxkWiwohZIzm6tplUwQC+/v7WGvJTUZTV7HBpDVZlpNlGXmW0zYx3kjKn5xf1TdeswHMeHjzObJ72OLu3/5Vfu23PsP9O1fYkb/Anz/HLraGeKDjx08A29z/md/iN3/tMzzQAbrk2HU3cct7P8BH/vuPcdu1wOIxHnv6CsdaPcXpozA79+dsPnqOGcc5ORT6rz91Cvx5zn05Cpg3bjj1I8cMvWjX5iXk2LEN4CKb52Y/+MNvXXiBsUYvlCnXXDsFLvLYY/YHf3zuHOd/8NVEIpFIvEr4yfnfSSKRSCQSiUQikXjFmM/n9L2lqRuKokRJTVM3jMcTEIK6qoaiKYzHE7quo+/7ZazMZDpBSsGiqsjygq7vY2HVOfruQFDrKIqCvb1dsiyn7bplcbiuG7q+p+8tXR+Lx36IQeraDuc8eRFlyQcSZu8dwOA4iJFIiFghPxA6xymGKNUdj0dkmUFJSZ5H6XLXdVjr4ip3KWm7KG3OBu/C5dE2iIMJDUVVLei7jiIvEM4xmu1jbMPEQOE7ZN0hqhZ6T/jOt3HnzxGcJT/zdszGMXKtyMsJSkm8iyvzrQWhJaLMUOMJerKGGk2QeQlKEggE73C9x7UWX3n6ymPbQLDgY1JRfM8EsqFZINTgihACLcFIMCquxHcObA/eBbz1mODYyAKvlQtOHF7BELh4yfLU0wprFUJqXPD0fU9v7dBMiY0ZIQ4EwtFfIaVkPB6hlKQoCiaTCSvTlXgf8nzpNgghoKRafu2cQ2lNwENgKWA+cBpoY5b3Ww1RVEII6rqGYSIlNhRgsVhgjOHQ2npshLUtWZYxHo/J82Jwb8R9ZFmOAOaz+eDckMtzKstyaDqBlGLZDFFKL695lmVAoMiL6ILou2dN0QQfaNqGto3P+k8KG2+/meMStv/os9yz9ezi8MUvfZb7dsAevp7TPzRuCGCb+z57LxcviwWyW/fw2T/ahvI0N71FA+ucuMpQ23Pc9+WtZ8uW7Q7bC0Cusb56xbPm+hvW4amv8U+/dhGOXs/JoVugT5xgg5oHv3w/M9Y5dcNzBi69IF68a/PScXCOW1/+LA9c3tCoL3D3P3+AF6p2fqEc/0s3swGc+3/u4uzlvQu7xT0vwfESiUQi8eKRoo0SiUQikUgkEonEFVEqxstAdAbY3iGVJsszfAg475fF1jzPqesa5xxSSqSU7O7s4HygqirW1ku8D/Rdjx2mHKbFlPl8zng8XhZ8rY0xN9PpNBamh9XlMY8+sL29HScXTPQVKCHwIdA2Dfk0ehRizI1YSm3zPMd7R9s2CMQgulWsTCa0bQMhsDKZghDs7u5SjsdYaynLAmMy9vZ26buelcmYuqrwBNq2xVmL0pr5fIazw/6FIMsz6Fvc009RCIdzGoPAtG1c1uVrePoi7ht/irruFNkb30R54nWEx/81oizo9i9hzIzWBoSRyGIVVU4QuUI6BaFB+hqFx4UO2TexaWAl1IGhl0JvYeh14H0UMjtADrFCmQStAr0LKGIjwTrAB2QAlUHvQBA4ZAJNqLh2IvmOUjR1x4UtxzUnDC5ItNGIQXwdXRkMTZdsECFnZNkzDgshBYfWDrFYVACMRMn+/hwlFXmRL2XLINAqTsN0bYtzPkqzlUJKSW97lNZMp1NCCBRFQZbFhk/btgAYo+n7OF3w+NYWCMHq6joA+3u7sfivdTyWziAI8ryI/gwlyYsM5x2HDq3RNA11XZHnBUqpKP4WcvmMjsdjdnb2CMGTDw0qKQS97ZcODe/j5AshUPc1k+mU+XxG27Uvzwf7xWD1Zn7x/Y/wyf/zHPd+6jd44HXXc3JdU39vk3NPWtDHuPU/ufkFrOovKffu4ZO/cZZTp49hts/zyLdnWDnlzPvfx+lBpHzsP3wPZ/70M5z98qf4ja8f5/qT6+h2mwuPXmC7g2M/extnXoB0+djpG5l+5T62d2D60298JlLp6AlOlHCxtrB6I28+9iNfmRfx2ryErN7M+//6Jv/L75/jc//jr3Hfdac5prc5f+4Cs7ykpH5xi/tHb+GOn93kk1/c5K7f/k2+cvIUGy/l8RKJRCLxopEmEhKJRCKRSCQSicQV6ftYpJVSMp9XdL1lvpgzn80oi4JyNGK+mNP1XSzmtx0+QNt1KJNhnY/CXClpmpoQAj54/OBWUEqjtaauo9w2Fvjjiu+qqqiqisViQZ7nOOdomma5wl1KFYvUXYf3fjk5EGXI0a2gpMA7x3g0Wu63KDK0jpFGbdvSNC2z2RwhJX0XBc3O9hA8zrqhQKxQKkYjKa3Rl614V8N5HBSGfQgoKan399jevoQqSrbmPa0rWNOe4AK+b3GLXewjD+Ef/JcIAdnrTuJlzsIFwnidLp+i16/GT4+gJocgn2BlgQ0O13e4pqHfX9DPGvq5o60dXe/pnMAGhUPiBQSiBNYJcELQe+jRdD10TlBbiRWGxkProLPgPFgLvoeoOwYjHdJZdp68yHjjGDZIvvmths7ntE7gnadve5x1PP30JeqqhgBVtRiifDK6vqccjei6DgLD6n05SJIlxmhGo5J+cFEYownBYzLD6sohxuM4rTGeTMizbBlXNR6NhvsDK9NpbCZ1HVpKjFboIcLqwINw6NAhhIgOhL63ZCajbeJUAHjyIlakQ/DYvqeqKvq+W07cdG3HbLZPtVjgncdkGVVVEUKIza9h6qBuaoIAIRVVU2NtPD4I6kVF08SGSD/Eg0n1k7Xmb/q2D/Cx/+52bn7dOva7m5z9+lnOPW049ubb+OCvfJhbrnoheznJe37pg9z6+przXz/L5oWaldfdzO0f/RVuv/EZPwLZKW7/Wx/itjcfo6wvsPn1s5x9eIt64zS3/uIv86F3vcAJguPXc/2w2xOvv1xgcJJTbxze15vfzI+rNnhxrs1Ly8Y7PshHPngbp48Zts+d5ew3tzDX3sztf/M9nHwpjveuD/PL/9nNHJ/2bA3HK294Dx/+r94ZmyrrU9ZfguMmEolE4sdDhBDCK30SiUQikUgkEolE4gfZ3t5dfr2+fugVPf7//r99CmctUoAxhq7vadoGrTTHjl2DyTIe+9a38cEzGo2o6ljoP4iQWcYYDVMGUkpG5Yjd3Z04JRCg6zqaplnGwnjvMUYzm80HGW9BURRYa5nPoxshy3JGozF936O1oizLZZMhvqYJzjMej5jP5+RFickMXdexMhlj+x4pBFVV40Ngb2+PcjRaFrTbtlk2UYpyNBSHe4xShOAZjydcvHQJ732MWgoBgWA+n8XCdlHiv7cFD29y49qYot/lr6zlXFPvgQ/0Mromwvgqiht/CnnHf8niwa9Tf+EuFk1FuTLFKyizAtct0NIjpQHf4+tdRL1H0dVUlccT6PvYKLBCsN8EJALhA52LUUUygAW0ihMG2kiwgcoOkx6AxpMJyAKUCjywVkIL6Dz+/f0g+NNtTfamt/C1Bx9mTzh+6W+8mS/vbnDfdx1CKoSK+wM4tLYWmzbGoJQm/hoamM/njEZjJpMJs9n+ECUkh5iflmpRkeU53kWhsTyIN7IObQ7kxOCspa4rirKEIWpISBGlx4M3YW3tEPPZHITE47E2TqjE56hgZ2cbKSR93+OcZTQek+c5F5+8SAgBk5llw2g8GdN3sbGQ5THyKMsypisrSCkAT54XtG1H33copcjzPD47xpBnGY9vPU4QAmc91lmctXRtnL5Q2vAPf+8fv3wf9leUi9z7O5/knqdOc8fH7+D0K306iVeOJ+/hE3/3Xrbf9gE+/vOnXumzSSQSiReNl+P/9Pv7+y/Jfi/nJ2uZQyKRSCQSiUQikXhFmC8WceV+U7Nx9Crqph0y4g27e3tMplOarh2iWvIhasbSzWdRvNy0CCmiYHco1AMgBD5AWZZUVTW8JNBa0/fRT2CMGaJtYrNhMhnTts2QTT9aTjBYG5YrzQ+mDoQQBBkdB1mWEfAURYEQ0LYt3lmUjFE8rreUw8RCjMNpMCZDaz24EiwQ6NqGoA2j0Yjd3T26tiUvYvyNYph8mExomxYlwDQ1zvYEk2Oswbge7wNhyIL3QuG0xO08xeyff4F+f069skZtCjokY63og0Oise0C7BztLf3eDsq3eOHivmScOKgCtAJ6QIdAbkB4UAJEiH+UlLTOo1WcVCg8eOGjRyHERoOKX6IEMSJJxhcEoJXimjE4o5BS0XU9T2xb2uBpmmfcGUprCGG41noZV5XnBV3XDh6EOEEQvQPRpaAyhdIKrTTaxH0gYGd7m7woCCrE/TYN1vYU5QilNIvFgrKI8Vpt17GYz5lMJkunxXg8BiGYVxVZpmI0kpTs7e0iZZQrj8ZjmrrG9hYlDUIommaxnERpmgbnHCsrKygdnzVno+Q7Tst0w7SBxDmHtZYsM0u/g1YKZy3j8YS275DCEQiDAFrG6DD7HCLaROLfAmZ//Gl+65/tcOo/+jAfeMdloU5+xtn/9362gVNvfCnmIBKJRCLx45IaCYlEIpFIJBKJROKKKKURUiKkYr5YUJRlXP1fN/TWsrO7x3wRo2sWTT2sbg/M5nMOrR5CqBgrI4d4GIC27QahraOu6+UEwXw+Y21tnaoafAy2J88LIBZxJ5MxRVHgvacocryPjQTv3dKJcJCRP5vN6JoGIWBtbR2hJXWzIM8LbNdRmBIpBHmZs7u7j/NhuYJcCIlzcX/jyZimjZE2UsZpBGtjdE1vLbLr0WaQ6yqFc47gA1jL1LZgBAFFQGJD9BUEIGiJXb0a3vR2upUpi0cfIRw6hPyZdzFG8tgf3kdez9iQHblvkXVFP7uI7gOytwQf8Dl0XqCMYKfzbFvYtwEp4JCJxzkQLWtiTT54jxBgfUASCALqwe8bAERsPoxVbDyMjaDzAeFBaE1AMO8DzeOPk5sM0zQ8uV3TjC3eO6RS1G1DO5+RmYyRENjeMpmMCSFgrcV7z+rqClmeLz0YIcSJD+/94CuIzYSuazGZYTSexIgjk9E2NSE4rLPLaCMpBHkxiI+HZlZVVayvRZttlmX0zi0bRFKqpXx5Pl8szy2EQNM02N7jvR+E0TGeKU4WdHR9bC4ZE6OV5os5pm3pupaiLDEmWzYq2rbFuQqlNNY5gvcoraAL1HW13LezlmI0YjQZv7wf8ETiZWL61r/MqX96F+d+/7f5za+d5NRGCdRsbZ7jYgflyfdw29tSqSqRSCRejaR/nROJRCKRSCQSicQVcd4hpWBlZXW5EtyYjMUgVUYItMkYjUY0dc10OsFZR24y+t7inIuTAI2kKDKEkEshcYwwMoOQ16CUisLZQZAbi8yWruuRUrCzvcNoPGKxmC+311rRNP3QUAiAZ5niKgTlaBSjlZoaYwxGuyHzXyCkij/rO7K8oCdEQXM5Yn9/lyyLzYoQiCvkVZxgaNsObQxlWSCCIHhP1S6W7gaCRzjLqm9ZmZTsN3OMMihb01oQJqefHGb8778Xd9UJxKjATFcYnXgt8vrTiNEYN17ne398P/XeFnL+XYxdgCnRrsEJgxwVeN/iMk1rCpTYxxiNHo2RRckTezucLANSlxRaIugJe/soLVFOIJSnbi1SSNbGGmltFAKbDGFysmDxiznBFASp8QXIvkXJwJGJ4glhMb7jkIRmZml0T9XU6KoiEAg+NlwAuq4ly9exNsb7RFcGdG2LtRYtFRbLynRK0zRopSAzw7V/pvmQZRm278nyOPly5OgGbdvS9z2Hxmt476L8W0jKokAKgRgcEV3X0bQta4ePUC0WWBufzSwzg4cB+gP/QdeTmYK2adDaLKcLpFRkmWG2P4vNstk+5kDSLGC6srI8X2MMB49DluU4a2PDRGm6vmd/NsP2lvFkQt3U8T0J+UznJ5H4t43yDB/4lSn3feFuvnLuHGe/G1/Wa8e5+d3v5Za3H3tl5dOJRCKReF5SIyGRSCQSiUQikUhcEWsttutpqhqjNVIptre3WVQVQsqlp2B3Z4feWvIso64b6rrC5DlKKfb2dlEqCpUPiu1hiL0pyxFlOawkH+JjDoS1RVHQdT1NXdN1Lc5ZmmZC8IFqsUAbTZ4Xy1XjWZbRNDXdIF9eP3wYP6xCd9ZSFAV9GycL9hb7yyYGCJSUYDJCCOzu7aKEpO96mvmcvCjw3qGkRCtDZRdIqRiPRhRZgXWOnd1dAoGmrnF9TxECazJwzXTMYzszGqAJMVKoycbkP30b7k3/LtmhQ3SLGaMb387oNUdRV10DKxOufUfB6pHXsvdnD3HpS/+EdWfI3/Q23J99lRCgfMe7cI88xFwoihveyuof/t+U68c48lO3ICcTvvGHX+bCk9/iLbf9PJnS2Ce/R/3Vu+GqN9BsfRffLbAWXj/VrF59Le6pLZCB5upT7B95LWw/hXj4T1iUR1A3/BTdYof8wlm8m2H7QB061qYTctsSWhAio6prinKMcy5OsYiAXd7HdulI6PsoZJ5MJjR1DT6ghMANz4+1lulkEmvqQtB1LaNRiXNxSmBUxhiqLMuWz1LfdzR1zfrhI4QQyIsCrdTS59F3PVopwhCV1TYNWR6jkHZ3d5BSU5QlTdvinY8yaEAQG195nlOWg5fBeZSUwyQFGG0YjyfDZE1sIEiphmijDCHEEPulWFQVWRYbb0LIOEGTFzjv6LqOal693B/xV5ANbvnox7nllT6NxMvH9CTv/IUP885X+jwSiUQi8W+EfKVPIJFIJBKJRCKRSLz6kVIipKTtOpSO8SzbuzuYoeC7s7NNnucorVldWcF6T9f3BATWOvreUtct8/licCY0OBdXg4/Hk7gSvHdA9COEEKN3vHNDATZDacVkOmFldZXRaMR4MkFpxWg0HrwGZsjZFwghKIqC6XSK94G266jqasio10sZs9Ka6XSFruuWGfdax+ii6XSCyaJ0uSgK2q7FWRvfs7PUTRNdDFINq94FPniMNmilMVrTzOeovmVFOI70DWWwCGyMETp0FPX6G9D5GNv20UOgNMF6RIDQdCgkkze+nvl4Sqcy9MpRpm//q2SrhzHjCfnxN4AGO1pDb7yRS8U64sZ3kI1WyPb3WTl0iGp8NZPXXodCounIijHZVddSjCQtgnGRMTm8SnXjzTwapjzVZeirT/B0HWivfj1q4xpG7/gZbNugrMW3DbkPrBcwzg2lMYxFoKoBlQ0uCuhtzxDgRNe1WBsjrGIkVA8BrO3xzlHNFzjv8SGgtF76BLz3VHW1fAZG5YjMaIoyFv+11igVf60N3qNVbARERwEEH5iMxwTnkSI6C7zzNFVNtVjESRod3Q1FUS7dGkoqlIrPG0BVzcnzIk4VDOcZiI4O7z1CChCwt7dH33dUVUXbdsPPHW3bUFUVi6rm0qVLLBYL2raLzZZhKqfvO/quJ8/yZ6ZpEolEIpFIJF4lpImERCKRSCQSiUQicUWqusEPgtnWWvqu5+iRDbq+izE0lwmJy7Kk6zqcd5SjMc5aur4fIoWidNY7T9VVmMwwmUzIM8VsPmc6nURRbhuFtlmeDyu7JWtra89Ij4WgWlQcPnJ42QDIsmyZZ98PUmeA3d0dykHGq4QAQmxi+EBve5q2AWKEkpQS27XookApRd/1eO9ASsajcZxcCIHZbIaUkq5rIXi6NsbhOOeYtzMyY1DCYG0g9BbaPUrXs9u07LrAxgjsZJVe5eTB0y5qpC4IXuHnDaHv6W2HrCvEZEp29VUsZEY4cjXF664nHLmG/snHEdkIN5uhRteAMCyOvJ7x2tV86w+/yLW73yH0gfKaU/jZLnsPfAkz30KXJQKN7wWz2nPimkOI69/GpcnVVGaM6AOrZsT2d76BGZ3i0OqU/OgG7UNfRW4/Af3/x967x1p23ud5z3dZt309e8/MGXJIjSTTxMjVuBoRpCMqppLQsFxLRuiajsogMlKhcNoarlBIgE3XDly3MCI7MdsaBdtaQB3ANMzaUmslUmxTNp2KbhRrGHJkjSSeyLTEIXnIuZ2zb+v+XfrHt+aQEi9DWhfK8XqAg8Hsvddt77WBc37v975viJyy3rHxLbFOaBAsraCxITBKdZ0YAEmS4DvRQGvFer0hjiKiKEYg2GzWSAQe2GzWJG2GkoIsC59fKNoWtK1BQljFDxhnKYoCawxCqvA6IUiSlLIsGQ4GDNKUQZLhxxYdx8GFslxS5jlFmVM3zUHB8mAwZL3eYEyLkFBWOceya1FaUK9rskEKgJSCKE6wWMoqdHvESYLu7u1QFN4yHA7YbFYMBlkXvWSAIDq41nQ9EEGo8t6RZgNsa/HeMx714S49PT09PT093170joSenp6enp6enp6enquSxCHuRwjBarmkKHLiOCbPr+Tch0F63DkUhAh9CuvVEmNDt4HrXArBqQA6ig/6B8KwOQgMV1aYSykZDAbUdUNd1+R5QRRpsiwjSRKGoyHeQ12FjP2mabDWIARBwLAuOCGKAqUU3nuywZDleoMn9CIAVE1Faw3rzYayqg6y+BGCKNKoSFOUBcZYrHXUTRv6Fbq8/iROKDYb8B7Xtnhj8dbRVDVaSSSCSCco4UkFDCNFKyJ8a5HeYYxDxQlKhBX0pmkwZYkC2v19WCyZjobIdELyprdSXr6M3349KkkwRY4SlkGcYosVs2PHsUUBF59mWC/YaksGgyHNpWeZX3cdaVOTpBnSGSJnSCKJ0BnF4e9kdf4COkpRWYaebXP9TW/j8GSCv3yJ9uknSW84iUmnaK+RBoZKMMpiFB4hJb5bWe+sY71eYp0L8VNFwWq1ZLVakec5UgZ3QVNXtHVDW4WV+OaK2BRFXUxVWJWvtSZJYtI0OBC0Ut0qfo9zHiEVUaSJuvigthN3jDUopajbhqIs2Ww25PmGNE0ZjAZMxhPmsxkeHyKrVOg+cC64F0ajCavVijhOmM1noSNDa5xzVFWB946yKBgMgyOmqkqSTvhSKsRklWVJWYby8clkjBBgjWM+n5FlKdCVhDcGPIzGI7QKcUg9PT09PT09Pd9O9EJCT09PT09PT09PT89VMSbEDl24cBFPKJQ11iClDJn1XRSNtWFF9f7+Pnt7l2lNi9aauioRQqCjiKLIDzLyhVBUVUlZlUFI8O7gmJPJBK1DmbKUEiEkRRF6F/J8Tds2LBcLqrqmaRrqukIpdeBOUEpRVRWz+aFQsluV7O/vUxShP6EoCtIsYz6fB0GirsmLgrKqaE1LXdfEcUKSpKRpRhLFFHlO2zQhXifNcMbinSNOEuqyQjhIohhrLG3T4KwhkopIxwgRsfaKdrpNfOyN+M2SxDfE4wmurLCmwbmWNl+Tf/ELKOOJYgVY2q98hcH1byS57nXoOEJfdxwxnSLiGKkFajCg3bvIOM5IvCA1DUkmkUqSjSbIZ59GfvmLZNIzHA8ZUjFWDRKLe+N3s19L0myE3jqKTMaIvEDtXyJLhyjjMGc+halb5JtuplER1kHVOMqiREU6DPiFACHxzqGkwrSGIt8EcaQ1NFVFXVVYY8nzHGcd1thOoAkxRkmSorVmOBwRxzFaR4yGA/LNhqYO/QpXBKu6romiGK0VdV2jtWYyGZOkCVuzGWmSsMk3VHXoQdhs1ky3tkI0lzFBfIgikiRhPB6TZQlJEsQIpRVSBrfEZDoJ3QzOUFVlJ1q1NE3o8wjuC31QDp7n6yBomLbr9LChUHk4ZDqdIpXsvifhXhdC4vGsVmtGoxFpliFV/6d6T09PT09Pz7cX/W8nPT09PT09PT09PT1XpW4a6Mpi67pis1kfRMSE4b0LfQJKsljso7TCWkOSpqGMFjC2pSgKpFToKGI8ntC2Dc6FDH3nHMvlkouXLsKVvoFI4wGlJFIJnPeYbvicJClKhyF2HMVd14InjkNOf1EU1FXIpgdwzoMQeO9oTRuiieqGxf4irKTvVsALKfHIsIq9KGiahkhrVosFbd2A95jGIJFkyRAlNQJBFMdEcXBZFEVOayzWejyCZWN4VihGiSaLBMlkjHaGxUN/jH3yz/H5CuWhvrxP8dnP0Hzy/2H1wL+kWS4pnznP3hfPsrU9x+88TPnpT6LjGF9WCA/6ptsZHT+Ofvoxqi89yvDwFtvv+E9Q3/ufsplfz9Z1x9DH34g5fBw5GCJ0BHGMGR5idu0x2sGU5PIuUblgcPgQMo0wNNjlMwgk8XiM1xpXbBBRRgQoAbGE0SijFRLnPUkEniAG4D1KSGzrsK1lOp6SpQNsa7Bti/QCiaCuatqm6YbuoSh5s15R1RVN0+B96D2YTiZopaibUNRd1TVpkqCkoMzzrrz4c6mQAAAgAElEQVTbU1UVbdu5U1xwJRRlQVEUJEka3AZSHERwSSnRSrFZr6nKIEQdOXyYqIsciuKEOE4RQhHHGVGU0LTBcWOs7Qq4HVKFrg6lFLPZoU7cqBiNJmxtzUjShMuXLgMepeRBHFdwX1gEkKYxZVXQmoat2dZr80X/q87FB7nn7ru5+zfPvqKXn/3Nu7n77nt48OKVRy7w4K/czd1338cr28NrgNnjzG8/wM43fMffgGv//H3cfffd3PNHF17hBoa9R+7ngS/+ZQ/Y09PT0/OtpO9I6Onp6enp6enp6em5KlVVkWUDJpMxZZWDkAxHI9q6pW7brmsAtNEMRiOkEFjnGA6GLBb7CCVI0hRrHD6KUF2prXM6FPFag1YRzhl0pBkOB6zXaxCCqixoTYuSmrZ1DLKEKIoYdPFF+SZnNA6Fzd47tHY4V+O7eCIhQk5/nucYY4jjhOFwiDGGzWZ1UMzbtg3GtGRZhlaKxhha55BAU9XY1oYiX6nI6zVJosP1KHHgxmiblrZpkUKxKXPGcUwtJLubgsvRGLVZ0RRlGLQrx/6jD+GUYPq33oVOFDz+F1z+zB8iNpdod/6cwd/5IXIEi8+e5vqT34n8wqdhvcD721HFmmbns0T/8dsxX/gczZc+j0XSPvkmjn3v3+LiF75AJTSTUcrku96Met11tP/yPJ6I5MRbid74H5Gef5qnn3qSwbmzECkmb/3blMMh+oaTHLvmeqInv4JPMtK3vYsWif3yFymNxzvIlWBZlqyUpnaGySAmVqF82rrgyABom4ZaSKSQRJFCepiMxyyXC+qqZjAcMhqNqesgJllnieMEI8zBKn+lVOi8kDJEbCHY2trCO8/u7lOAx3biQFWVwSWgNZvNmrKqUEozzDIAxuMJVVeUncQRcRQcCvuLJVJplNJMppPgMqkqNus1XgikVDRtQ5KkWGtI05Tlcsl8fihcY+c+mEzGjEbjcD+0hiwbUFU1eZ5T1TVxHErBkzhhb3+P6XRKlmY0rWGx3GOQDYji6LX4mvd827PHg/f+Mg/snuS973mtz+XrZ++P7+WX/2CXkz9212t9Kj09PT09r4BeSOjp6enp6enp6enpeUV451gsFsRRTFvXXHj2fBAXspQoUmzygnW+4dDhFI/HOxfihmQY1GulwVnquiYZZAjhmUzGLBaGwWBA2xqMlWgddau9Q0kveGKXkMQJm3UOwGazIcsyoigiTVOU0njvDiKLsixDac2wizpaLBZ47w4G1nmeg/eUZYUQYVX6dDLtypodbVNT5gXj8QRjDN7DcDwCH4qaoyhGSqiqAoRHANaYsG3b4r0jjlOW5YbLQhF7gRGKsYKR22D3nkJmczK1xO88zGZziWwwpH32y8Sri5hWsL9+iif/1e+QRIrt4gL+3z2BagooSvzZf4OqDX5nAc98CbXZoG3BqpY0f/qHPPnvz7C4vCRtCtyDH+Xy6U+Smoqk2sct96nrJXVliFxLtp/z9P6GifK0p/81IkpYfPK3mfoKudjH5yvqP30QIxRi7zyRNRjAOs9wlLG7bCkMXDPJMM5R1jVN26KkDCv3jUFmMgzpI02UpuRFjo4iHNDYlk2eY1uDjhQq0hhrsZ27BCEwbYszluEkpeyKv1fLJWmaBmeKUjjhuOboNaG8WQhs17ngvWc4GOKdwznHxYsXAN85HjzGWsqyIk1TojimaVqE4MDZsr+/h5SCNA09HlJKEP4gYkkIqOqaI4ePhKgvY9lscugKlDebUMw9mU5CP0QUY51ns151HSHgfOgEMa0ldwVlWb82X/K/Zpz8Bx/iQ6/1SbwqDLTfrH1vc/sHP8Tt36zdvwjG9V0gPT09PX+V6IWEnp6enp6enp6enp6rksQxeZ6jtOLQfMb5Z5+hKEuOHbu+WzUu8M4TRzFpmnLp0kWUlCwXC6QQRFHM6NARrLWkSUJrWooiP4ivkUIgZSg3HmQDyiJ0JqRZSpIkoU8BgdahaDdN0yAAaN2VLFukDM9LKYmiCGstly9dZGs2J9/fRynFZDLFGBMcB22LlIo8z4m0PuhVcE7QNm3XyVDQ1A3gQ+G0c105dErbhnJn34kLoisbHgyHoQvAOUQ25NnNgtQK5kIS4dFI6sv7xMeOEM+P0jz9F5h8ycZZUmeIvCfLEmpaRqsNIwUDb6AGG0tc4/GXLmMbBx5YXMQZGElPLSzl5Wcwl59l4j1TCeLJyzgl8JHEzwa4dY7c30N7T+thS3ta5TEOovwyCkmUX8J7S+MkIlHYL38Jh0c6h/AeHUOWQJ3nmEazEZJ0kuLrEDuUZBlY231mGiFDX4OxFmMN1sJ0OiOVEEURm+WKqiyZplPSNGW13jCeTEJUVRSxWa1o6pojR49QlSH2aL1eoaQkSdOu0Fpz7okvk8QxRb7Bec/WbI7WGikkq+WCqqpwzjEej2iaUBDurggWCIbDIXEcPtMrEVqj0ZjVakmaDrrILosrDVJI6qqkbhomkymD4ZD5/BB5vmG5XGCtRWtJ09QkScJoNMF7KMsSIULKcNOEaC8pJW3bUhZFELNew+96T09PT09PT8+L0QsJPT09PT09PT09PT1XJazEDqupkyTh8JEj1HVDUzeMxyOKsmBra4oQ4KxhPBqFmJqukDlLM6qqIs/XDIcjokgDAyaTCU3dkKYpm3yNdRYlJc4a4m6leds2KKUwJuy3qiqUkl1Zc1jxPhoOkVphjWG53KeqylCUnKZEUcRwOAQBxrRYa8jz0N8wHo1w3rFaLsiLIrgeNmt0FCGkJEoSlNa4Lm5nuVjgrCUbDJFSEicxVVmidSjtzTcb1qsVDocQkqaoqQdTvHyWDEsqHJFw0Drsep90+xq4pBC+JsMh8WgHcVtxxIdSOy09woKQYCqLVCClw0agHCjvSQUIBVEKVvjw0wSdIZGexoJQHrHJUdYiI1AWUhUOMpmCF+A9aOXQtkVaT9VYXGWR1uFDxQR4aC1cyCHdGhE5S5l7RpMEcdHRNg3ZMDgApJDoKCLSEaPJmNV6GUquk4SqKkkHGavFApwnTTPSNEVKyfb2NnVdoZWk2OREUUQUx6xWy+699lgzIEszjDVsTbeom5qyLomUZmtrwmq1Cv0WUURRBpdKuCctW1sznnnmGSaTSXePtaRZFsQfIdjvejOGwxF5vgY8QvhQ4F2WaBUErThOyNIUgMVigVLqwMEwHAwoy/LAFbFYLBiPx2w2a7JshFSKuqnxnnBeJohRw9GIsuv1eC3Y+cgv8OsPl5z8sQ/x3jd/7bO7fOKXfpWHqlt43z++kxMSwLD3+T/gY7//MI9fLDGAHh7jTX/n3dzx9hsYP6+Z8exv3s19n9vmnR/8ALcf+eo9v+C5iw9yz688AN//E/xo/XF+7U/OYWTGsbe9l5/4oRuuOswov/Ig9/9fD7Kzb0BnHPuu23n3372NG8av7Hy+ivUZ7vuf7+dsOebUP/gAd705e+6pxx/iY7/3II899fLX/rKsH+ehf/EJPrWzyzokgqHHx3jT33refrr3I7QPnOW+u+8GTvLeD72Xky+138/fx92/cZaTP/Yh7pCf4Df+xac5t29AaubHb+Gd/9kdnJpdefEFHvyVe3jg4gv3uffZj3H/759+btsbb+euu7b51C/cx9kj7+QDH7yd7Rdc0oN85CPd+/+C4105Vnjt2d+4m7vhJe65np6enp5vF3ohoaenp6enp6enp6fnqiilGY1i4jji4sWLJEkSVmZ7SNIEqSTOWoQQSClxzlGWZddjYEmSMKCPopjt7aNsNmsgrMgejUdEOqKoCmazGVqFIlohZZdlL7pM+ZhBOkBpTVVVjEYjyrKkbRvyAqbTrTDI0xF5nlPXNVmasV6vGU8mOOcAkEJSVgVJkrBcLQEBIhzrynGtdaRZGGxXVYlzktVqFZwG1hLFMdZYlFaMxhPquqKqKxAQd+9NXhYopbFa0cqIoc05kip83WKMx633YXYIMTqM2z9PbTxaQOtBGU/TQiTAt+EUWxf+gBOATBNEa7FGYE2Ds+AaUCrE5CQachuEhNIEAcBYiAZDzGJJnA0RReimkB6aCgYZtFYgGo81Hu/B2lCgLAErwn6ch1jAVEKVDCmeeZo4k8y2EsRlTzYYkCYpja/QSh1EBDVNQ5IkGGtIswzwyK47wXpDkefMDs2I41CiPBwMaJoG07RMZ7PQj+AseX6lAPu52KK2NTgPZV2TpqFEOU1TirJEStmVKmt0qpmMJ6w3K44duy50HSQJl/cukyQxRVmxXC5Dybe9Ej8Uc/ToUYzpYqsGGW3bEEcxk2u2DpwEpm1ZrZZMp1MW+/vs7+8fRCEdu+46Dh+e0LYtVVXT1IbZfE7btiyXS5QKnSHXv+44eZ6T55vX4msOwIm3nCR7+DRnHz6DefOprx4anHuUM/sw/t5bOhGh5Oxv38N9j6zDsP7EKbaHJbtndzj78Q9z9pF38oGfvJ3tVzpQfxHKh+/n3mXL8e86xSQ/B8def/VBxrMP8uFf2+XC+Dgnb5rTPn2Wnc99gg//xZ9z1/vfx6npqziBlxERLvzRr3LPJ3dBarZPnOLY0LD3+GOc/fiHeezMO3n/T7yCaz//IL/6vzzArtOM33CSU3MN+S5nv7TL2Y9/mMcv/Dg//yM3QHodJ286wWNf3GG3nHP8puPMeT3zV3AJ5Zn7uOdzj8H1N3DqjRF7jz/Gua98mvt/dY3+mfdyMn7pbV9wjXqPx3ce4N5/lpG9xDbrf/thfumTazh6glM3ZZRPnmXnK5/m/n+6R/uP38ctWcZ1J09xYmeHnd2S+RtOcXwOr381n0tPT09Pz7ecXkjo6enp6enp6enp6bkqWRIzHA4AgfeOLBvQNDVltxrfe0dtDXVV4/FEUcxsNkOpkBl/6PARxmXRFRobkiSs4lZKs9nkSClQUlEWoSi3rusgUAhBlmZIGeKGqqpCCDhy5DDPPvss1lrG4zFZluG9RytFFIUi2+l0SpzELBYL2jYsz4/iGCFDUbR1jkhHIESIVlIKY0KkUdPUtE3IwK/KirIqUF5QNXXnrigRCIoiPxBPIIgYUnqMKcnSIVmaMM0y9PnDVBe/wiYRnLOSa7xl2DRUu19mePR1mPVlpDXEiuBIAEY6uBCUAAukCoxMiI6/Hn3z98K//xz2sUeRXiDxKA3Cda4BCWkExoOSnZigPC5fgwBflXgBUgEOIg1SQOQ9UoHwIDXoCpyD2n31/WCAJYrLRqKF5/h1Q7SoiKKMNI6gK6m2bUvtPBJB2zQkaYKQgmKzIcsGWGOI4xivNVprFvsLjh49inWhb8I5h9KKOI6QSrHZbEjimCxNaRuDNYbF/oJskJFkKYfnc9Z5jgc2mzWT8YRY69C1IUAIGWK1qhovBNZYmralqCo8Aucd2SBFCoV3HiEFTdsGd4SOD2K6hBAAXLp4gSTNqOoa8LRNy/7+PkkSI0RMpCOEFFhrsNZgjOHIkcPs7e3TtnVwOUhJkiQ452iaIJzN54e/Bd/ql+DGW7l5dpqHdh7lbHOKU88bMj/+8MOsmXPbTccBMJ//KB99ZA3HbuMnfvzdHL8yWf7RNWd+6x7u/9wD/G+/+/owCP9Lst6H237iZ3n38Vex0cVd+L73899//7GDoUcYiO9w/++e4eQ/PPXKhiHl2U5EmHPLP/xvuPPE80bn5z7BP//kLsxu4X3vv5Pnnio59/EPc++fPMB9f3ySD3zf167Vfz6GM7//ALsu4+SP/RTvfZ5IQXmaX/8fP8rOw6fZ+ZEbODE+wTvfM0P/yg675THe8Z67XtqJ8DU8/rnHOfljP/u8/Zec+Y1f5v7Pn+VTD685+fbxi2+4fIj7P7kLw5Pc9d++l1NXXlae42P33sun8xffrFwbTv79n+W9bznYoDveDqcfXXPL28ec+IG7mOl72NktOXbbXdzVOxF6enp6vu35OtYF9PT09PT09PT09PT8dUFKQZZlbG8f5sjhw0SRZjabMxgMsNYwGAxD3rt3tG3TDVLDYL1uGi5fvkTbthRFxXq9Yb1eU1VlV7LcBOEgCcP/5XLJaDRCK81wMGC2NaMqK5TWXLx0AWMMZVkyGo2o65oif26aFYQGyWQ6paorBoMBTV0jhKBp6s4VETEYDA/cBnVdMRgOiePQ7yC7Doa2bWi7HP2mbkmzAdlggFAS7zxahx4GpUJPg1KaJAnRPFEch5XwSqHTjOFsm7X1lMbxRCV4xkDVWup1wWZvj6r11A7WTRj6txYqA00DpoW6hrICPxig3n470d/7LxF/429jhAYZinqFI1gQPAgvkT4IAnUDzkJTe1zrsC2YVlAWDmdAIhAtqBaEBWVAejBN+IPRE8QIAAdoAUYLnnCaTdWiBXzHsRhhS8BjjKGuSgCEECilwENdN9RVhWlaNusNZVngvQ8dE8ZiW4OSIcJKIGlb2/VRJAcl2ptNTtm5QpRS3TFgOBoSRRGz2Yz5/BBCSg4fPoLWmjRJGQ4HtG2L1prLl/eQUrJarRFSUpRl6C6oKsqyoirD/SKkwHmP1qor6a7QUYRpW2azOW3T0rYmOFR0+D7s7e2xWa+o69DF4LzHOY9zjqIoGA6HTCZTRqMRe3uXkVIyn8+pqoooitA6pqmbLvrrteIYb/3uObgdHv2z55Xhuh3OfK6E62/lHccADI9+5iwlGbf8wPNEBAA55tTfu4MTEsqHP83ZrxGiXhXTN/Pdr0ZEAJjdxo8+T0QA2P6+H+W2GfDFR3m0eQX7KM9y3z+778VFBIKoskfGLT/8fBEBIOP4u27npIQLnznNuZc9yOM8sZuhj9zGO9/8Nev7s9fz+kOAM19/v/Ib3skdX7X/jFM3BXGnKsuX3Gz3//s0u8CJH7zrOREBIDvOHT90y0s6EjjxLu56y1dt8IqO19PT09Pz7U3vSOjp6enp6enp6enpuSqj0QjnLKvVkk1RMRqNqaoCpUL57GazZpANQpSLCtFGURRRlgWTyYQ4jtlsctq27QamIfKmqkL0TKQ1Wkm8c8y2poxHI+o6DIzbpmEwGJAX+UEXQV3XaK05fPgw3nuapiaOQymztY66qojiiL29PbaPHmW1WpENgqPCOYf3ns1mjVIa5xxaa1arFcaEYXNbtyE73xiUVszmc/LNGmcdQoCt24M8fSkl3nucswdD47ZusN7RGolKMxZZRiI0e7ZmojxN5xpI8Kj1HlI4HMF9IAARCxLrUTIM82VIX8ILi/IOr0DMj6JUEBBcGwp6pQw9B96F/QkBSdyJAjK4CwxgW4tx4XF8iDEqG8giqFtQQKyg8aE7oTEHGgVPG6h0xEYPWT77FJMtxbEjAi8czoNUIa5ISonsOiyU0hw6fIjNekWUxGRaM55M8V0PQd0JQEqFgu7J1hStFVVVUdUNDsFgOGQ6VdRVFT43axkMh0wmY1pjcT58dmVZMB5PaeoK7z1VXTEcDjvhqSJNE4RSDAZDqqqkaRomkwlFUXTCmGWz2RBFEXVdkiQpVVUxmUxwDg4dPsxmvSaKI0bjMev1ikhHPP3UU4zHY+IkOih4ruu6O27DZDJGCMHe3h5pmrK9fTSIVE3DoUOHkVJy4fyzCKnYu7z/2nzRO479zVs59qlPsPPwadY338oY4IunOV3C8ZtOhf+zy4VnAW7gxIkX2Ul8kpM3ws7OBS5cBl6ug+DluP46Xq2OwBu/k2MvePAY3/lGeGj/HOeegFtufLkdPM7H7jnLOgeGN3Dqxq8dmV/giS+XQMbT//Z+7v/s125fspcAyyd4eg3HX2LBP5zgjp/5ee4AaErW64vsPnWep7+8w2M7j3HuG3QbZNvbvOQpvCRrnji3B2zz+te/yOjoxhu4gdOcfbHjTecvOWy6cHkfXtCo0NPT09PzV4FeSOjp6enp6enp6enpuSp1XaHUgCzLsF5gTEMUxSilqeua6XRGUeQYY0nThNVqRZ7nKKUQArx3nUtBcO211xDHEXt7+2zWK5qqYuvIdidKGLamIShbCoGOYwQeAYxGY7TSxHHCcDji/PlnmUwmLJdLAIqioCzDYHg4HJLnG7wfPk+8CNvuXb6MjjRFURBFQZjY39/HWQuCg8ejOCaMzkOc03S6hbGGfL2hbVryTU42GFCUOXEcBwGhbSmKAmcd1lvaVtJ4z56UDNIJaXGJYex5/UQyEB5nwDYtliAixFGIJ1JtuGbfRRVJCdKCK2rs2UfQ7/ghfKQQMrgHhAARgzQQqSuRRQIvBMo7UKB1eC7SwWHirccrwsC+tqRJ92HrUOIsBGSpwjWhC6N1gIDDCbSzmKeZcOHCksGWZmvLsBEtzrQMsmF4ofcAeCytCd0A48mULEup2xq8pyor2qbh2muvoyiK7j5TOGfROg4ugralbhocUFdliAtqIc0ydFfC3TQNQgpWqyXOOi5dukikQx9CksR470nTlDTNwmdUlbRtSxwnrNdryrIkjuLgcCkKptNpJwKMkUJSVTVxHNO2ljwPcVave91xLl68QBInLBb7pGnCaDxmMplgbYuUkuFwyHK57IQm18V6BYfFlTgsYwyTyZTBYEBR5FjjidTLhNZ/K5ie4pY3fIKPfeU0Z5a3ctvUcObhsyBP8Pabr4ykV+wvX24nmuwbcRny1Y8ttg/NXvTx2aFt4ALlVR0JJet8zskTmrM7p7nvd0+9RDxTye4Xz7D7kvupKCt42Sn+/hk++s8/wunz5qse1rNt5tkF9r4BC/jH01cvI0BJmQPMmL/Y2/kyn8vLHq/9uv0VPT09PT2vEb2Q0NPT09PT09PT09NzVZxzNG2LLyGJIhAaayxV04Zc+vUaAaRxjGkasjQlTRKyNKzkVUpRuILZdNLF2zQ0XfzLocOHsN5RFWGILKRitV4Ra02apkRRRNXU1FVFrDXCe4rNmkGW4Z1jNByxWC7IsowsS8myjCiKGY3GtG0QPIxpkVKwWOzTNA060sxmM4wxmNbg8SipqOoKrTVKhcz+pmkOSqTXmzXOeYyxSKXJBhFt06BjjVOOpq5RWhNHEZWtUUoSKQ1e0CDRR46yfGJJYioevOQ5NYJrIhjFodTYuc5NQHABOBdcCEIFQQEN0ht46jHMJ38TMbsW6S2u8eDAd+XK1oU4JOc8znsMncvBheMgwYngQsCCaW0ocW6DKGEdGAneQF0FEcH6ULZsPTxlJHsrwX6zh4kER6+VRLpE6xSpos7h4A7e9ySJcNaRJhHg8cBoOKauKgCGwxF5vgll18YghCDNUrSOmM3mREnclStrptvbrBahE8G0LU1ddj0ba6ZbWwDEsQiRWcbQGoNxFiE8zpnunAyRknilqIo8CEQmOFAiogNRaDabdz0gFXEctlsuF0gZysDrOrhgloslUimUUiz29w9EM+fcQXTRer2mKEKEklK6czvUDAYDqqri/PlnieOYvcv7aB3uzdeWMbd8zwk+9pUdHv3cmtu+53Ee3QHefMvzOhMmzKbAS4oJ5hUM7L85vNSq9wvPXgDGzK46V9/m1n/0X3PH8Yt84p/ey0OfuY+PfvfPc+cLXAwnuPN/eB+3/GUFk2aH+//X+zmTZxx72w/wAze9mWOzjGycobnAg79yDw+8ZklAGdkQuLjP3j5/eUdJT09PT89/MPQdCT09PT09PT09PT09V2V7e5vJZMr117+O8XiMIET5WGspy4KqKsk3ecikTzPwHikk4/GYKIrIsozxaESSJGzWK/J8Q6Q1Rw4fYTabEycxURwfRAMdOXwYraMudig66EtQSh+s9L5SfHvx0kWSJCFJEgaDIVpr6qpisb9P04ToGGsti8WC1XKF9579vT2GwxHT6RaD4RApJNkgYzAY4Kxl2HU/5Js1Sivapj5wGyy7fbRNQ5plzLbmrFcrEIK6qmjbFoTAd06B6dYMEcdUwwmbbMqlBlYeGiWZDcJrtIQkaA4HQ/tWgEi6Hy3QA4GQFmly5Gf/GPfIvwZrUClEMcTdvyqBeAA6gmQA6RiEklgpcSrs2ykRHAaRRGegFchUohOIJMQxDAcwTGEYwyALZc+DRPCEHvOnl2ourgsGE8GxayVKWqSKGI3GRFojRXBxRDpCIJBKYqyhriuEEGgdhvFRHBPHEUpphJBkgyFZNmCzXlPXFXmes7u7G4by3uOdDSv+TctoNGQ6neK9J46D28Vae+BSEEJQNzXWGqq6oixL2rbBe0eapl2cUihCHo3GoYhbhOirK3Fdly5dCgJHF3cUxKWK6dZWF4Vl8N6TxAltaxgMh7RtOHaWpQfRRUop9vb2WC6XFEXOZrPpnBfuIFqrbVu8h2wwYLlavNZfefTJt3JCwu6ZM1z4s0fZcRm33Pz8et9jbF8D8Dg7Oy+yg+YsZ78EyG22Dz3/iZIXxuSf44mXLxN4dTz5NBde8GB3DHmM66652g62ueENGcjjvPtHbiGj5PT9H+Vx99zz4dp3OHvWvHDz5gy//t/9HL/wSx/j8Zc7zJdOcyaH7Oa7eP8P38aJ43PG4yys+HQX2L18tfP8ZjLmuuvHwAWeeOJFrnFn5+Wvraenp6fnPzh6IaGnp6enp6enp6en56oY0+KsZbVcsNlsaJqWPC8YDIY455nPDzEcDjDGUFUlW1uzbrV1iBoyxnQRNBXzQ3OOHj3KaDQKXQX5htVqhVaa0XhEkkQopUjTBCnDADqJE9IkRSmF92GldxxHFGXOZDIhG2QHfQVKSnQnXmilqOsa72Fra8ZsPkdHmtF4fNDBUBYFURxT5EXoXohiyqqkLEtkN5SWSuGswztPFEWoKMILMNayv7/HaDwGAc57RuPxwTlOJlOSLAs5+1FMPd4i9wm1F3xu7XlkT7JoQmyQMeGndVBbaJ1gXcBqA3XjqTYe24ItoXpmSfv5L1BvLFUOVQllAWUNZQl5DkXd/buGpnXYrmjZGrC1RwO+cpgcXAt247BVV/Jcw6aAvIaqhaqGpRX8u41gVbUMtacRnpvekjHKGvAKZ47JIbkAACAASURBVD2bzQZrbSilJpRWR3GElJI0TXHW0TYNi/29EHnlHFVVkW/WaK0wJgze4yTEGg0GGfP5HO881jrW65xLFy9hraeqKtbrNdPphOnWjCwLAlaapsxm8068GncdHBF13bLZFBhjAcF0Ou0+X9v1bgQ3ymAwYDgcUpYl0+m0Ez0MQsBgMODo0aM4Z0MMkTWhE0JJ5ocOHVynEAIQ5HlOkefEcRJKoIXEOc+RI0eo6xqAw4cPMxwGAWw0GjEejZhMpq/l1z0Qn+LtN2Xw1KN85OEdmN3MrV/VhaB56/ecDEP2P/gE554vDrg1Z37nY+w4yG6+lZPd5GH7mm1gzef/7KtVg73P/BEPv2xM0qvk4gN85E/2nveAYfeTv8tDS8hufsfzXBWvgBvv4K6bMshPc9/vPjc6P/k9oWx45xP3c2b9/A1Kzv7Ox9hxBm48yYsFIn0t5f6Kr9JW3Jozv/XRFymp1hABtN8St8fxv3Er28DO733NNZpdHviD03y9ZgndxSO15YsIFT09PT0933b00UY9PT09PT09PT09PVdlPB6jVERZ5jhr8d6jtWa9XjGfzw/Kji9evHBQajsYDLvyY8Pe3iW8h9lsxuHDR1guFqRphnMFultR7ryjKgsEnkjrLi9fo5UG6Q8iiaaTCXm+RmtNlqV47ynKgqYO2dtt25J0kUrGGOqmBjzWWpRSJEmClOqgJDlJU6w16K4cOpuG0uiqW7EOdMW5DUmSEQ9jTFOFkB7hkUjSLEPWkqbL2PfeU5fFwar7bDhkb/8y+XiCHAxZbAyt9WRK87q4YShDD0JLiBayFrz0qM6toACdhOgjEQki3dCWoYMgVlCHKofwAwgpqRqHEmHbwkIqg+Mhld0fgr5zQSjAQRQFdwQShAbvBdqEKCLbwpNC8//mgsiVRJHg6PUJx681JLEHJM6H40qpsNbRtg1ZliG6ob0Qkq1ZRF1VSCmDU8Q5VBzhnUP7+KCkezgMkT9SKrYmk4PXusaAEOzv7zOdjkOEUduipWSzWocOD2uxVYm1FghRQk0TjnllwC+EoCxLnHVsbW1196mlKAoOHTrEarVCKdX1GHiEEMRxjJSCyWTC+fPnieOI1XLFYDBACEHbtgghMKbF2rZzGHjOXziPjoK7Js8LZCgNCe6czYY0zUiSpBO1as6fP8+hQ/Nv+nf6lXDiLSfJHj7Nua/A/B1vfUGBsX7zndx50xPc98hD3PuLD3PshhNsD0t2z+5woQEO3cJdP/jcKH375ls5/kcf49yf3MvPfekEJ6+L2PvyY5xbZtzwhjmPf+UbdOLDjIsf/2V+7nR3jMcf49zSwPgUd/7gKxntf9VVcuKH7+LUzq9z5vkRRzfewfve8TT3fuos9/+Tn+PBG09ybGhe3bFuvIVTw7Ocefyj/OI/Oc2bbpij6z0e3znH2s2Zz0r29i9w4SJdtNA8uCl2d/hXv3Yfj2/fwDvec+uLFEt/gzhyO+/9/rPc88mz3P9Lv8CnbjjBtu7OL8nIKL8uMWF+zTawy87v3ct9f7HNDW+/i1uvBz5/H3f/xlk48k4+8MHb+2rmnp6enm8TekdCT09PT09PT09PT89VqaqapgkdBkmaMplMmc1mpGmKF57J1pg0jTl27bUMBwO2plOSJGKQpUxGI6bTKddccxQhBEW+QSlJXuQsVkuctWRpipaSyXjCeDzBOUeWDbDWslqvqOuKLE0ZZCllGbLm67qhrmpGgxGRioPg4GE2n2NMWK6rVIhXStO0y8GXxHGM9466rtnf3wtOibrBGsP20aO0bUPbhsLmwWDAeDzBWMNoNEIqgfMWJ8A4i3cwGA6QUuK8QylFHEckaYJQiuViwaULF8A7hsMhdjCgvPZ1LHSClxI1m3NWDNm1isIGN0JpobJQtrBpoGjCv6t1cB0UC0ex9LQGmhbKBhoLTfd/Y6BtHJIuJskHfcECeDAOuloFGg9tV6Rc2eBGqAzUDZSVp24FtVU86xRPO8mRAWxNEoZbkre8OSFSbdd6AFJFSBWhI00UabIsCDKtaa/0LuOcI04ShAw9BlEcs3f5UhiyFxvWq/BZ13WLd7DZbMjzDU1TE2kVejiSlK2tLQaDIePxGBC0JvQfCARtUxNrjalrTNsSaU2kgisiy7JOWGi7AmRLsVlj25YsSRhkGWWe42xwlNR1TRxFDLKMYZZ1AlNJlmUkccrWbIZ1LggF1qK1Ioo0SZLQti1pmnLkyHYnQigOHTpENhigtCJNU+IoJo4SmqYlSVLiJCJNMy5dfE0zbZ7jxlu5eQZwjFv/5ouNqzNOvuen+an33MrxGVzYOcOZR3bYS45x8od+nJ/94J2cyJ738umt/KMP3sWtb5jDxR3OPPIYF4dv4o6f/GnuuPEbuM7xO+7gAz/+Tm6oHufMI2c5V044/ra7+KmfvouT2dU3fwHxCe74uye/JuJIc/xd7+dnf/zdnDyWsfelM6/+WPEJ7vrJ7v1Yn+PsI2c486UNs5vv5P0/81P85zeHcugnnnxuxf6J77+TkzNN+dRZzjzyKE+sX3r33wi2v+/9/NTfv5Xj45bdnTOc+eIu2Xfdwfv/i9tCh/R8zF9a9jrxTu787jm63OXsI2d49Nw3+WJ6enp6er4uhPdXfqXr6enp6enp6enp6fl2Ym/vuZz0+XzrNT3+//1b/wdSyW7VtexWmw+JIo3HIbVEoaiKMgz9s0G3ulxTFAVb8znL5RJrLW944xuw1lA3DZcv7dG2Idf+OZdBiKRZrlbUdU2e52Rpymg4RCiJc8F1cOnSRZxzJElC0zQkaYg+UkpRVTVRHLNY7DOZTBBCsLe31xXkhvJe5zqXQ9epkHWRNru7T4eOByVJ01DcvNmssdYhpaDIC5wLA+X5dIvpZEq+WXPlTyshJMYYiiJHOMH20etYrfNQprt3mboqGT37LNNnz/E6bTl87TXcaJZ8l92gJLStpzJBAJAiiABaQhIWx6MFOAEqAgwMYqia8FpP162gYFN323dRSbEKZcppJBEyuBUi1bkQCM+hg8AgCGXPrZVUyZA/vNzw5bxlewDnG8/JmzLe/CZJogxaC6ROWE5u4f4/H/KFJxdYY4iiCO89QgqGwxFaa5xz1FVFVdeMJ2Pqug7uhKomHWRYZ8nSAc47kighiiPiJCaOY9I0pSgKsiwjjmO0lkRRDHi+/MQTTCdT4ihiPB5R1w3GtKzWG5I0dBVAiCZKkgQIIgXed1FKCddf/zqKIqdtW1oT+j8OHT4M3pFvNkipaNqG5WrNZDJhf3/RuXAuMh6HCCWtFavVgtlsznA4ZL0O98XRo9ewWq0oyxD1NR6PWC6XpGnKYrHk6PY1rLt7yFpPmRf87//nfd+aL/rLsssnfulXeWh6Bz/7X93KVTuKe/76cP4Bfvl/epC9m97Hh95z4uqv7+np6flrzLfid/rVavVN2e/z6aONenp6enp6enp6enqujvcMswGNbhFSsFkbxqMRrW2wzoN3CKGYbk1ZLQVZlrG/v08UhUFwFGmGwyH7e/vsXbqMUpJ1vkFJhcEgheDQoUN450LOvrFUZUGcJGRJyPSx1pImMev1pus9CN0MxrQMh8NQhqskTVXRNA1N2xwU8FZVRRRFRF3ETNs2XXa+RipF1A2q26aL4xECY2wnCrTd8Q3ehcm+UjJk97chK18IQdM2aKVZrxYIKbHW4pxksVpR5AVK6zC1F5pqdgjZ1uzuXaC8eJnt64/w2XpAW234jrgm9gb/vHx0T3AUSAlCQhqBUgKRKpQzJHSxR10MkhcwDjN2vA/Fy9IHccBKh7BBMHD2OQFCAcIAEloleKqGZ1rFhUXJlwoPCp6sBPKIZLYNeANSIIQEFNZB07Q41zkzkoSmroN4UFcIkXWOhJTWGOI4OYg4Go3HKKVpbUuUJUgvEJ4Qf+XDSv+6DsXJCIGxlrIqmM1mbDYbxuMJrWlDp4YxgD8o5W6NOYgvatuWKIrI8xwpJVIphlGEVIqyDL0Y48mEerFAaU2eb0iTFOccRVFgrKVp6s7FUgOCQ/M5m3yDENC2kjhODmKSrpQxV1V54I7RWrFYLJjP51hrmc3m5EWOc+F+iyJNLb89wgPWn/kDHtqHE99/Sy8i/DVk/W/u5Rd/f58T73o/73vb8+4At+bMH36aPeDEd77aqKienp6enr+q9EJCT09PT09PT09PT89VOXToUMiorytG2QgcNHWN0IKmqVFSkgwSFos9kjhlvV6TpilN10/gvWMwyFgtF5jWsFqVIMDaBq0UeEeapKGA1kMcR3iXYq0lSRO8c6E8OQo5+lWXgR9FmvF4zP7+HnGs8d6RJDHW+zDMN4blcsF0MkVKRVmVJHHSnVcQPMr/n713jbXsPO/7fu9t3fblXIYzEofy0MmIOSNo7NICxwgFq0EomEEqIzIiVxBQGajQuh+EVgUU1HbhoHbSCFFcWEXdQA2iD3YQBWERO4gCKU1HMI2agpWasjytxtWcSsfWHJMj6gznXPZtXd5bP7zr7BlSlIaiLNGp1w8YkNh7Xd512ZTm+T/P/1/XjKo0QeG8x5iMul6lorS1WNulSQcpaduGUTVKQoQQBEH6J5GyrDg5Okre+ERCjDStZ1G3KKEwWoOQ+BCQoxGLrbPYesXx0RFVMedtb30zz71whzD/On8xC6gYkT4iRZomKPocBa1AKYiFhnGFuzPH+ZAmCXTKWIgxZSqE3i4pzyC4FKpsAyiRtptkSUBAgOiFiBVwaCS//Y3AnzQOh+ROG1BaIDYzvLA42eGjQMgCpUqi0LgQcc6hlcJkhvnshKoaMR1vrovp3jm0yRACvHMQoSxKpJAorWkWDSbPCZ2FkCY8Ukh3eg7j8YSmrunaltF0wsHtF1NehzEYk1GWJV3XYa2lbVuKMoUYC5FyEaqqWmclCCH6QG5NlmecnJwgpUzH7yx1fcKZB84yn88J3pHnOaVSdH32gZByPWVhjGY2O0EIQZ7n1HUSEc6ceQCtNScnx0wmGzjn1mHM08kUk2Vcv36d0WiMEDKFN0uJUq+nkLDLb37kN7hBzXzu4PyTvOttQ+ngzyOTH3k7O//mKXb/1T/g73zhIjvnSuBuBkZ58d3DuzEwMDDw54jhv/gDAwMDAwMDAwMDA/fl+Pi4D5WFosxB9NYwQZDpDKUURV5gC0tT15RllbrvrUAbTV23CKCpUyFeCEFe5Ny5c4fzD57Hdh1KKoiR7e1thBR45xmNRrRdw2rVYjJDCB5IQbVVlTz4l8t5Kl5XFb7vFM+zjOVySQyBzGQpDLcXPFKWgaHrWspSIQTkeUZZlKzq1HUuhaDtWmzXAYIIOO/QSjMqK0RV0TYdLkJeFsyOT4gxTTlUVcVsfkKWlSxXK6IIBCIxksQY55jPO5rlCqFLNseRPzxpuPN7f8i5sebBMxMOvSarF0xywVjGZEsERAmLAEsPs0WktjV1LZgvBa2PBC3Bh5SL0NsixZD+5AJMhAdHsJmB7HMVnEvTDicBRJ7xohW8aB2zKAlG82LtOAywDJLZCi5UmrqxdMaj/AqnGoTMaeISIcYoo9Ha9GHanhA83jmKsmAxXyTxZ5qsgNqmQWuN957WdQitWMznjMsKIQUxRpx1WGnxLuBdQJCskpbLJcaYXhiAEAOnwcjGGFarFXXbIJUiNg3Re6pq1AeDG0KItG2LFUkYiBFWdUMpBKPxiMxojFIEKVlZiwR0H9bdtg2jPhvj5GTOeDymqkqccxwdHfXWSwqtFUpppBQcHt5ZCw1aa1Z1TeYc586dQ2tFXTesVisAtH49/6o+YZLNmd8B/YbH+emfGcJu/9xSPsoHfm7CM//6M/zO7i7Xnksf660LPP4TP8kTj50fJlUGBgYG/hwxCAkDAwMDAwMDAwMDA/dlsZjjvCXPM4oydfQrrbCdxegc21rmccHtg9tMJlOUUnjvKcuS2Bf+vQ+88Y0PIoQgihSQW5YFbdcRvOeFF76eOsptCkVuu2Rf1NmG8WiM7SydtWilcDJZIS0WC5xzvOHcWe4cHqF1lgJ+bbK5McYAqfs9z3OQktVqRdPUSCmo6xqtNVKkonVmzHrtzllEnmOM6e1yQCEw2pDnGRLFynuC98j+uNZatNZU1RhrI955pJYgBJ332K7BtxbXeTrrsULRlWOaFRytap6fr1jNV/zoecNDG+l8PkY6CS2wlIIDC390Ivl/X3Q8t4QFgsZHXAREClmOgOtDliVJRJgomEg4u4AfHMMbDGQihTU3Ab4RYJqVuFzzYrfkwHn+ZNly5OFYSE6EBKl5UEDjPDF6YvAIHZFKIAkUSmJdi9KarMiRInX4m8z0YddqnWWRJgIqmqbBB0c+quicxXvPYj4ny3KUTNtZa/E+EIk0TUOWZeR5vs7EQIDtUiaC0Zosy9JAQwgUZZUmTBC0bQoMP83HALBdh/fJ4yn0IdxFnqcg8RgxWrOxucHJyQkxRiaTCavlCqkUIYQ00TIaUZYV1jrKskErTWdbhJA0TUMIASEEIQSOj4/6yYgksiklCSFZMXnv8c4nb6rXjfM8+d98lCdfxxUM/BlicpF3/Ccf4h2v9zoGBgYGBl53BiFhYGBgYGBgYGBgYOC+xBjX3dTHR8d0XUdTN0ghIYL3HhUkG5sbfTZAsgly3jHZmHDnzh200pRVyh/ApiK3MRlKyjSRoCQxxrU9jdEG6yxVlYJ6u7ZLAchliXUO79J5MmNo2oYsy/v8A0tZlDhryfOC5SoFHSul8CH2PvSGqkye/VJKtFJrO6O8SJZK3lroPffH4zFN06CMoa5X625/AJMZWMa1AGG7lhAlzkFZjpBC0lmLsy36NJg6ps564zXRR5ajDU6KDY4WNU19wnN/bHkgM5joyaTEKEHrAic+Mgswd565S9MJThuWwdIRCaTAAx8jgfQXPoNgJCOFS8LBvoOvWthUMFYCI5IIYZXCHqw4cZGZC8x85LYXHMVIq5OoUURo28BxLXAbKRA6+ACyYSQdpa+xTUtnLaMihVenXIQ85RyojhjC+lmWRYmQgiIrQUiklIQQGE03CN6TZjnAZBk4x8nsBK00on9XTu2KTmYzhBCsVitEVbE8OUnPrapYLRcIKSnLAoDlcolzpxZCiqqqkljkA74P7wao6xohRJpoANq2wVqFMYaiLOi6ZJ80mUzw3nN0eIRUye7o9F2fzeb4fsKl7M9zKiqAYD5fJBEDWC4X6fNI//3AwMDAwMDAwJ8dBiFhYGBgYGBgYGBgYOC+aKNYrRZonbqmR+MJWmtsl2xhxpMxeZFRr1bM5jOafpogEiiKnBA8q66jqEqWiyVSihR2KyV5XiCF4OioxvuwnibQxlCWJXmRr8OVm6ZB9EG0MUaKIsd7h3MeKdV6emB2cgSA0YqqFx7quqYcjQjBJ+sZpXAxIkihvkJKpBDkuUEQqcqSF77xDbTRWOv64xnapmE+m6FU6nxPAb4ZtrNorYgx4G2krluMysjKDGcDRkCZG/AeckHXepTQ1E3HqnMcN4ITbVg0goMOzrqc1tUUUoDSLG1HGyI2QgfMIxxHqF3HaS5zuuN3JxFC/5nysAGMBRTAHQ+FSFkJglTUjhE6PO362JEFgigFJSlXIFcGtGRhI1F0nNa7JYGKlolQYB1S6f65OIQUqbhuNIvFIk2xmIxMGpbLBVmerLJSAHOGcw6lNc47lsslddswlRsAzOczqrJiurWJECmno65rjDHUTU1RlrgQUNpgsjSxUHuHEYaqStMPq9WSqhol8UtrxpMps5NjpNbEEAjeU1UVbdOwubmVwqK7jsyk4x0fH1MURS8CODY2tlitVqxWc8aTCZBsu7ouZWvEGFj1NkzOJXGraZpkpbRa8sADZ5nPT3AuTfcooxiNxt/7H/XAwMDAwMDAwHfAICQMDAwMDAwMDAwMDNyXqhyxqpe9533AaIUoM2IMFGWB946u7ZjPF+QmByGQ2lBVJXdePGQ0GlEUFd47IKKUBgTL5TwdT+lke5OnINpTmxelNfP5nKZJ9kZ5mYqwm5ubxBBwXQQUJyczRqMRq5VFQO9LnwSH6caUO3fukOcZmTaURUGW5diupW0bMmPw3hFDwAtBjIKuszjvmUyn/ZSDoyxKAEZVhbUWAK0Ns/kJ2hg8gbZp6DqHVDlKplK+Dx6pJEoUIMF5i7UNnRWErkYg6fSINjMQOzpbs2gD1rV0IaJCxLsO2/v4n6KALQHbJOFAC3oxoM9GIAkJAXCk7+qYwpRfjCAFKCICQSQJKlYIWhRCKkTo2NQCbSRZnmF9RCCx1lNbgQgp+DnTYFQksuINuabE04WCpq5RUjHZ2MDHQK41ZZlyBZaLJVlu1mJS27WgVB+MnAKpnfe4kGyjjvvcAWMMSMGLd16kLEqs7ciLMtlSZTkCcN6nKQCpiN4zKivKslwX70+nU8qyQmtNU6+IBMZVie7fu3q1oigKqqpitVqyvbXFCy+8gFaKokih4EJAWVYsFnOEEKg+eHk63aDrWqy1aVri+ITNrW3OnjnDbD5DSInRhsPDF6mqisPDO70d1ojgI9Y5bG+lNTAwMDAwMDDwZ4VBSBgYGBgYGBgYGBgYuC+T6QbTjSlNU9O2DV3X0XUdWaYRIpJlGYeHh7RNi9GnkwQFbdtQ1w3nzp0jhCQgCCE4OjqiGo3Y3n6A+WxG0zQURYnWJnnHa03Xddiuo21a2qahLEp8DHRdx3g84eT4mBAiRVkiRMooCMGT6YwkViTrmqM7d5iMxiwWc6RI/ffWdsQISqm1BVLwAb0O702ZCUprYiR1oM9moBSjcoqUCojMF3PatgUghmRvlKY2SOcSpHUYg4hgrcN20LgOH3UaCbARdIU+80a8DQhToZcHyG6Jcg7nLcSACh5FRHuHISJF+gudBrSIKJJYEIAoBCEmyyJHOoWVgiZCh6ABLIJWCDwiyQhSgcwI0hCFZuTmZKIDH3GdIytKlDEgIm0wBCEpVaAwSVCIasWD4xHbueSFrsP1YcZTKe5a/miNyTKc9evpEecdp6MNWpv1pMt4PEYIwddvfR1tND4EirIkhkC9WiGlwtmOk9ksiTYiPadTcSLGiMkypJQ4Z+k6y2QypaqSINS2Hc5Z6romRk+e5ywXC0yWJmBOLYeapqGqRozHI7peHNBac3jnDiu7YjKZMpudIIRI+Q6LeR9MLteh4jFGtNZpGqFt05SG0mRZmlyw1mKtJc/T9Mxyufy+/r4HBgYGBgYGBu7HICQMDAwMDAwMDAwMDNwXZy3OW2L0ZFmxtvpJRVgo8gLbpc+yLCOGQNs2+N4mZjY7oSgq5vMZRVGwubmJQOCdS13fvfVL6iRPQkTdNAhgMpn0mQuOGIBeiFgs5mxubFHXNd57tFYIUoBt17VofZpnkEJ2pZRJDCD2YcoOrTVRyv56IiF45rMZZVUhlcI6l2yZ+pwFEVNh2TmbbHg6i5aK5WKBt5YzZ7ZxDo6PVgQf1wG7wXliTOKENoqCAkIgE4qpkkgPOh4zLyvm5Xk6cQEbAr5zeNvQISnaJeP2Dvn8ABH6vIXoUaRzxAgixj6gWGK9Q8UkLghACoVEYYSmUIZgcmKWE2RGRBOUScdyS6TvUA5k7PAIdJaR5RlaK7TSNHi8qqmKlioDKSPRNDw0cbz5TMHBCxFjMgDmsxkmM3RdS7CBEAJlVWKMRqpkbeWCY75Y0tQrTJbR2RSAPJlOGU/GCFhbBQVA9zZBWV6kUGyTQf9s6HM2irJA9XkYIXic8ykkXJXJOktrFos5xhjyvGS5WBBjXL+TWZazWCwo+smH0/d9sVyilKIoq15Qa9fntDaJE23bopRMWR9Gry2bnHNYa/v3wKC1Ic9zXrx9G601zjmqakTTtN/nX/gpcz7/jz7Cp7424R0f/AXedeGbt9j/9Ef4+OfmwAXe/Qsf5PHJy7dwPPtrf5vf3C258p/9Iu955Dtcgjvk2r/8AuV7n2TntV3Ev1/84Sf5+X96nXM//mE+/M5z3/n+8z2e/q0DLv/k47yGvV8b369n9C3uzXzvaZ6+fZl3/+XTzw54+lc+xtXbl3n/R9/P5e/lmgYGBgb+HDMICQMDAwMDAwMDAwMD96Vuapzr8M4ymW6R5zk+BLTKMJmmKHKKPqRYm4zlckFZVTjnmE6nzOczDg8PiTHw4PnzzE9mKKVSwV9pyrK829kfA0qn4mtT10AKNM6yjOVqhdKGtm0pirzfVtF1HVqX5EWJkpqNza0UiCwEdb1K2QpC0DQp5DfESOx9gmKI/TUUWNtxcOcOznvGk8lLLGZGoxFdnQrVWZbyIEKMqehtHVmmefzxx7Ad/P7v/yEHB7fxwaNUmmogprwCoiYaTfSBzbzgzdtbFNbx4tEhbnGMDQLyDeLWm2gn57DVAyxljmlPyO7ssn3nBiM/I7Q1KjpyLWg6R20DUkSEzDEmo+kafIAQArWLtNGg8i2ULAhmhC9GyGKKyvopjPoYefw8uk6TD8gRnooOgc4MRVGgjUaFFm8sDTV56ch1REhJ1IFNEbl8vuDzz69ApJyD2WzGeDKha1uMzpLtlZQpzFgKytEI5QXGmBS+rTWr1WptT7WeDlFqHcbsXbIvihE2NzcJIUCMzHvrIASMJ2Ns1+HbQJHn6xBl5xxZlrI1yjKFfyerLdBaM5/N2FBbtDFSVSNWqyVdF9ZTCscnxzzwwFlCb7uUcg9y2rZBCElRFClQ2lrKsiRGz2QyYXZygpTJvkkpRZZlzOczjDEonSZ1RtUI5z2ZMd/HX/e9TLj4yDn42gF7e4dwYftl3x/w1d15H8Cxz41dx+OPvbyscJP9fUBeZOfid3r+Q57++C9z9dZl3v/e13oNf57Y5am//2tcO/Pk97F4/jo/oy8/xUf+yTXO/fggFwwMDAx8vxmEhIGBgYGBgYGBgYGB++J8CkBGp07w8XiTpmk4nh0hasFyuUJJzebmJsvVkqZp0MakAi+n81R6zAAAIABJREFUocip6L9cLKiqkrpJQbmjUQq+DSHlCZRlyezkhK7r+kKtYzwapywFk9E0NcGn7XxI9jPb21sslyucq2mA6WSCNoZltyTPC5R2nBwfU/bH8d4jlaJrWyLggocgWK5WtNaiu5buyFEWBRLAB4JzBO/XUwan62uaBm8tP/DQD/AjP/QXqUZTJpOCP/rac8xnS0KMWGeTv1AE61IqgZaKXGtUliGU5oGHHoLZCfPVEo/CFBInj6kLsFlJVrRMp2fZeJPhLduW+cmMxeyISaFZNh3zZcvmSLJqJUYprAtobYg4vnrbcrsWNJs/SCMMMQRECChvKcSSSgvE2EE2xbWGrm1ARBCC2NszSaXI8oJcT4hFzW0fiZkiZBGhMijOkuk38fBkzObucxzUqdgfYsC2LUopCB1KTNOUgA+EGDg5OkZpg1QKbTQhRDY2NpNI1BfcU4e/pqnrFOAsevuiEOjaFqkkZVnRNDVZllGWafrFWs+oLLHW4r2nKAoAyrLsJxxkyv3wHqM1y6ahKAryPKezltlshvMuWS4Zw+bmVhLIrEMI0WdlRDrbb6NV/3vxjEYjxuMxbdvQNE0SndoGYwzWOkIIFEWZLJO6jqZuKPKStmlZ1IvX4VeeOHfhYUoOuPW1PRzbLy0azPe4cRsmj13h/BeeZfdLf4B77MpLt/nGHns1sLPDJfmdnt2B/S4v4N833vp+PvrR17qzxYX7b/Wny/fxGb3SvQlDfsjAwMDA68UgJAwMDAwMDAwMDAwM3BdtNMF5jNEoJZnNTtjYSGKC956jwyOm0yl1UxMB2YfZdl2bQnN7MUBqxXIxo8hzgvd451gulvi+QC+ExPvAYjkn+IAQYt3B3bYtVVXStslaSIiKtm3J85wsy+g6i+2S4NG2bZ/hkCGlYLGYpzwE55BSIYTAmH6qIASwlhBS17mUkuBTda4ajbBdh1QpydiYDO8dzlqkVPjogYi1FqUEmZEUJvAjP/xmzp8/w2y+JMZA23TMjxbkecHB7RXexxTArM3aGqcqK8oHz3F0eEhwjslkgiRlHagMlMwhGqQvmW4bRg86vn7rT1Aa8tajfWBaCHTjkvCxbBlXJeNxiX9AkN9ZUPtADKuU3xAigoAUGikEWTFmNKqw1rFcJpsf27WE6Ne5AwhJnktK3WA3tlhuPQR5QJoRYvKDqMkb2RYlD/8/gsOv/AmBgBSqvz86HdN2tEcNRVkhhSTEQGc7ZFCAQEqxDsr23qf8ihAAQb1arm2J2rYlz/IUkk0kxkCMkbIoEKT7uaQBIXrxQazFhK5rkxDlHcE7sjzHuyRKSanwwaeJmLalyqo0SQI454kxMh6PmS/mOGepyorYT7hopeg6S1HkaK0Zj8cYrZnNZ/2x5VpISIHPJTGmSYhqNKJe1RwfH6d34vXi4g4X5bNc39/nJle4d6jA7d5gH7j8lndw/uaz7H5llxvhCpfvEQzme1/lELiwc2koOAwMDAwMDPz/iOF/1wcGBgYGBgYGBgYG7kuMkaoqmc3nCKGYz2eMxmPGkzFt0zGZhDRZEAKz+QwhBF3XEmOkXtZY2+KzwHg8psgL6tUKow1bW9up69ulQrOQkoPbB33x11IVyXrm+PiICAilUEqxubUFCKqyXHeiCyFo2oZRVdE0DVmWbHLyvCDPC7R2rNqOIstoVi2zxYsUeY4xZm2fMx6PyYpinZ8wn82IMa3bdo7FYoF3HhFjKvYKQZblBB/wQfHl3edp6pa2aWnalqIyvOkHHmRjMmZxPKesKpRqsLYjM4pcS4gydcy7logk0wqUwNm2t90RiAAgCd7jvGX/0FGVFX78Rpq2xWeREBwdEApJ9IFgHMcCZl6Rb485m5e01hHSAyU6TxQCozWE0E8cZJwZjVA65QosF3O8dcm6KAaC95zZHnP+DRMKWfMVueBsAdNRjilGZKYEYfjhR/8SX96/xeqk7UWlkrZpKMqCruuIRDLviUSETGvwIfTvgUJrs84UyPMcrae0bZuEjRBR2jDSmtwky6IooetsX+6H038xSiWxarWkKqt1iHfbpMDjoigZjSfUqyUxRIqiRGnVi1pQlQXOeWxnMcYAka7rGFUjyrJkuVyitKLIC7x3SRgJkeVyxWSiuHPnRaRMIliWZRR5jl1fk8LalqZpmUymxBCRUpJl2TqT4XVBXmLnEbi+e5Obt+Hi2btf3djdBXbYeeQcb/jjCVc/t8fuHly+Jwdhb28fOMelR+4JT5jv8cy//gy/s3uLeX9penKeS3/lXbz77ReZSOD203zsV65yAMB1PvnzPw+81PN+vvcMn/rfnubGczUO0KPzXPqr9xyj5/o/+3k++aXLvO/ndrj+jz7F9ROH3trh3f/5B7hy5ltf+n33C3P2fvdTfOa3b3Br6QBN+aZLPPHX3807Lr4sLOKbtn2Fa4ZXzgF4Nfv2+wFw+yof+/mrcPZJPvy3nuizEhyHX/wMT/32NW7dTvcLXXLuTY/yxH/8Lh49c1oO6vMFeJIP/9eX2Ptff4OrX75F7U7v70/ynh+7QMmre0b3Mv/dj/ORf73Phb/xC3zw7ffcn/3P8JGPP8OcHd7zdz/AlezuV3v/8u/wid+b8OTf+jBPHLz03qTn06/6sx/j5z9L/909J3WHXPtXn+RT177FNQwMDAwMvGYGIWFgYGBgYGBgYGBg4L5ICZ1NXvDOJe/3EAJFXnBynMKJnXc45wnB07Ud0+mU4+MjjDJ9YT7ZIjV10xdlBZA8/K2zKWOhLxIfHx8xqirarl13k5+GMWttyEyWrGKcQwjwzkGEvC/qCylSpsJijpKS0XjMbHaC1oaySGufz2aURUFZlv2kgsD7QF6WHB0e0rUteV7gQ2BUZHTOEQHrHLIPbE7WNqCV5uh4wRev3SSEyOz4EO8t040RIeY8+MZzCF3x4p0lEYHJDJsb22xsTFjVK0L05EXJ88/foshztFLE4JEiYrShKEoCkbZtqZtI0zl8aBBKE/BE4YlC4aVEK40sVD854QgRrGvRmUaoVGMPEWLMUEoihEQAIQYCkbqtyWLA2pQnIUXy7weFUgVNZ3nhxRPsas6mOWTjIYWSBbH+Ou5YEdWYh9/wMNubE57/+m3G0w2c91hnkZ1CqQ6lNSEGtNEYY+icQyrZiwWWjY1NrLW0TUMwGueSlZWUguVyifepGF9WJXmWs6hX1PUK7zxt26SwZJMRXKB1jjzLCCFZJTVNshra3NzsQ7Mn1MtIJCaRq5+qaduG6XSKUorZ7ISqrMj6nAVru5TbIAVKSqQUWBswmSEvipTxYcza0qhtW0ZVxfHxEUVR4nxAyoLxeJKyIgDnXT8xkVPXy+//j3yN5tLOBdjd5+ZNB2dPywZ77H4V+MFLXMpgsnOJ8nPPcmN3Hx65sN5m74+AjR3efCpAfONpfvV/usqtoJn84GUe3dawvMX1r9zi+qc/wd7Bz/CLf/MiFA9x+W073PjyLrfqbS687QLbPMxpSsPBb/0qH/vsLZCaczuPcn7kONy7wfVPf4Ib157kQx98gnMvsVK6xdV/fJ1ZtsOjb4NbLzzEQ99GRLjvfuGAp//hx7h6C8jOsfO285TtIXu71/nMJ27wB3/tQ3zor56G/9Zc/+cf45NfqtFbF7i8s42m5tb13XTNtz7AL7x351sUZF7lvhsXefRtM/a/uM9heZ6dt5yj3HioL5bXXP9nv8wnv1T3a92hJN2v/a99nqd+5Xnqn/sgj2/cc9pwi6sfv8r1F7e5sPMo2+70GX2cg7YXOe7zjF7O5JFLnGOf/d0buLfftcCaP3eTOQD77N+EK2shap8buzVsPcals9ArFmu2Lz7Ko/N9rn3tkPL8DjtvLNk+XwJ1v8Uen/oHv8y8nqRr4JC9L+9z/dMf59bxB/nZn3iF9PCBgYGBgVfNICQMDAwMDAwMDAwMDNyXjenW2gYoM8mzPnjPnTuHeO84c+YMX//61ynLisl4ykos6TqbQm1tshvSSmOtxzmPDwFBR1WNQEAIno3NTb5xcJsQwrpIPJudcGb7DF3b9eHMHUVRsFguGI/GWGs5PDwky7Lejsasi+JpygDarsOHQNdZlNbMZyfkec6Z7W20Nr2tUgpmbtsGF1KXvLOeUkmElyxWK5SSKKOR1uGahrZpkEqhlMRZsM7jgmA5WzJbNPjgWLWeo5M/ROsbxJgmO6SQTEYTlosWeUtiXcvZN5ylioIXDm6zmK9SFoMUKCEoy5KN6RTvA6umZrFc0jQ1MSb7pWT7k1BKMhlPKPKcVVOzXC0JLiAERASQcg9AIJViVIwYVcma52RxgvcufdfnQJxa9gAYY9iYTCEEXjhYEuyKiw99nTe5F5nMBQgJYoSVZ9D5BrlRREhd+0ZTlRWdTc9ROEeMgbKsyPOCSBKaYow461itlsRIEmp6eyvfi1FSJGsj23W0qiH4kLYPEULkzNYDdF3DarnAh0hVFuRFwWK5wrlkoTUajdZiWNs0lGXJqs9fKIoC62zK1lCaru0QMeJsR7fqEFLibEeW55zZ3mI0mnB0fLzObmi7Dt2/F0pJtJRkxuCspSxSmbdtW7TWLOZzympECB4FnCxmTCYTtrY2v58/72/itAC8+0d78NhO+vAr17hew7lHLjKBuxZIu1/l4CcupC742ze5WUP5Q5dIJVvHtX97lVuh5PJP/yzvf+s9PeH1s/zaf/+b7H7hWXb/5kV2Jjs8+d4t9K/scqs+z3/43vfd7XLf/wy//tlbsHWFD3zoPeysD1Oz/+lP8PHPXeWTv335bkc/AIccnnsPv/iBK99hJ/or77f/b36dq7dg+7EP8F/91M7d7+p9PvOJj/PM//5Jnr78YZ44C9z5PE9/qYad9/AL9x7np/b5zP/wj/nC3h9ww+1w+ZUqMq923zc9zvveO+GTX/wkh+PLvOu9p5MIwK2n+TdfquH8k3z4v3ypwLL/6V/m45/b59kvHvL4X71HArhznevnn+TDv3TP9t+4ysf+x6c5+Nwz7L3zPVz8ds/olTh7mUfPXuXqSyywXBKfJBBq9r52AI/0K9//EtdOYPJjP8T5Vzjc+b/8Pt43+STXvnbI5K3v4n3vvCvcnP5zPnmCD/3ck5w/vben1/D7z7L3Exf4jvO/BwYGBgbWDELCwMDAwMDAwMDAwMB98c6jtU6FXCnI8zyFFvc2Ld4nq53TEGKlVF80F0SpUiHYe6bjSQrM7T3iq6piVS/R2jBfzDGZWdvZOJcsPYQQIKCzHUKmMNtRNSLPc1ZaY53DOkfbtmxuTOnajswYhOi77GMq3Drv19Y31trUGe5s8u3vbXSIsFwuMCZb+/SHEGlWdQrgbVuaeoVrOzrbUagSEH3BHdqmZTafYa0jEvHe0nUuda8rhRCpID+qJswXS+qmprUNq7Zhc3ML5wNNl+xuAIiCygZ8lCxXK07mM6x3EF9a5D+9sCIv0MazapbMFvMkorh0/hBjEgdE0hKkUGxPYVlbuq7jeH6E67dNmkNM10ZEScV0MiGisV3LYjEHt4IHjsjDMcYFQBGlJ4iCbKwQMaKVpnNJDKjrps8aEGRFjl+tkEKxymqsd2l93iGk6AvtBqXVPc8hTa50tsN7n6YSshxEyqzIswLViwx1E6hXS7TJMEavxRZjNHVds7W1hVIahCfvczTmiwUCUEL3eQ6ngdqCqqoQUhC8RwlBnhmMVozHG8QImTG90KHwTmC0QgqBJIkWWmmODg9TjoLWbG1upikdJSmynKZJhdDxZIxUgvHkZTY532/OPszDJRzsfZV9drgA7O/eoGbCY6dF37UF0g325k9wbgLu5k0OgMs7p+XaPW7eKtFn38GTb31ZOb98mIfPwO5td9/s3r0vfIFDSq785L0iAkDJhf/oCS7/7ie5/nvPsv/Od3Fvz/nOD/3Ia7Kz+eb99nj29w+hvMK7/+bOS78rL/Cud17mmX96nc//n/s88RMXIJCshA6POHJQnlZe5AXe9XN/j3d9u5N/N/v2HH7tFjbTXH7ny6c04MJfOA+fO8R9U2hxyZW//rLt3/Aoj559mqu363Wp/jvjHG/eebkF1k3296F87Eke273KM3t7zH/8HBPg4Cu7zJnwjh9+rZMDE97xk/eICH8q1zAwMDAwcMogJAwMDAwMDAwMDAwM3JfTEOLRqKCuV6yWS5q2JevDh5erJAZAXBdtpZLUbUNRFH2+gWS1WiYBoF5hjKGuV8QQMFmG8z7ZE+U5WhusbTHG0NQ1Rd/JHYXoJwdalFK9RVKqe/s8JJseAVmec3R0hDEZbddinQcp1yJF0zTEGPssh466aXDeYbTpA5V9H94LxmSsVjVd02HbDmctQgjyLFvvr3UKEp7PZ6mrf938n+ybTovhWmnKMl3Lql7RtKm4fnIyZzZbrAODhUjhzjoz5EXOcrVivlrgg+8nLlKdP0SQvYogpewDhD2L5YKm64B0rEiAGIAUWiwQGKNQRrJqlutpkxjjutgfWV8GSqkUaG1bFosZIQSMVghpAAnRpYkEQEQISicLJ2MIgPcB71uKskT1eQijskIoyXKxQJgkNGVZBgJiiH3Qdsqv8M6hixxsej9S7kBMVyMERVlgdEb0gcPjI4SApuuY5DlCpOkLKSRd2/XZBLafcGkhpmupylHK8vCOshxxfHxIPy5D3ayo5IiiyLE2iR5KJbEAKZACJuMxzlqy8QhtDN4HyrLEKMFoXLJaGOo62SxJpYnBUZVFEtimE3wI5CZZh02mr7OQwEV23gzPfukmz8/hwuSAr+7OobzCpXWN964F0o1dx+OP6XsyFE632eHd/+0v8m6ArmY+v82t577B83+8y43dG+wfvZq1HHDzj2ug5Pl/9xRP/V8v/77mMAdOTtd6+vk2D/3Aayl5vMJ+/aQF5fP87m88xR980xIOKYH5c88z5wKTs5d59PxVrt56ml/9736HyfmLXH7Lj/Ajb7vMha37rOm72ff0Ct7+M/zC2wEc9bzm6IU9Dr7xPDe+ssfu3q1vdWLOv/FVHf474sIPP8rkc8/ctcDav8GNGi5efII3u6s888U99sLjPCoPuH7t4GXv2HfKFttb3+q7Qw7uAK/K3mpgYGBg4JUYhISBgYGBgYGBgYGBgftyWsi3nWW5qDk+PqEsC+q6ZjKdYIxJdWohEVLStS1GCsbTCUTW+Qi2S/74AD54FosFSmuEtTjr6DpLVVX44DHaIKSg9p6iSDYzre1YrZZorZMoUOTrYGVIEwgmy1ksl4QYIXisc3Rdi1JpHyEFUqaAY2MMWmtCjEkI6Qv/px38sbdICiEQA2vRQESIISClxJFyHbTSfZAwL50WEKele5BKYXRGXdd0XUeIgUgKCoZkTRR7ASICeZHjg2e5Wq6nJ0Q/URBjcgc5tSxS2iC1TCKPTce+qwYkO6OYLg6kpChLOttR1yucT/kPp3/SupM1lCDlTRAjTbO6a3+EhD6UOMVdRKKAEAQ+KtrOYu3dNUuZgrKFTO+IUIrOWpz35FJg8hyp5DroOoU7gzYGISNd24FIokZRlOm+CnDBUVVjbNfinEVIsb4Kay1SpffNOYcPnlFVpfwHKXpBQeKtBUQSkIJnOtEURUnRT960XUvbNhR5iZQKgl/fWyEEUkhi8OR5jhARkDjrKPKc0bgkzw1SSqpqhDEZy+WCsihomobxeMx0OmFV10ngyQxKqT/V3+9r4dLODnxpl719ePzCHjduAz+08xJrmJdaIJXc3CdNM9wTnsvRNX7z13+DZ7/x0g54vXWO7fKAw1fdJl5z68vX+FZlcGioG2AtJGj0y7rxXxJQfA+Xf/qjvP+t32a/9RJusfvFb70ClqnrfcI5nvjgz7Ldh/7On9vl88/t8vnPAtk5rrznP+U9/8G3Shb4bvZdL5T933qKf/rbu8zvve265PzWNvXtw1fYZ8r3ZBDmwiUulc/wbG+Bpff2mHOBi38RLtod+OIee3vw6BvTO1b+6KPfhf3Qt7sGl3TUgYGBgYHXzCAkDAwMDAwMDAwMDAzcF2d9Kr53DW3bMplMUFpRr1bEELHWMRmPsa739lcK2xf6vXXU9QohBGVRMp8le54QUqF7o9pMEwnOYUxHWZbUTeoUV/0UgXW272T3OOd6myDJcrlESomUyUqpbTu00pyczMjzPFnUWIs2yTKpaZuUzyAEuTFYaxFS4p2nGBcsl0usTWHSqi9qx5gyHIipqN2sVigh+9DiJBh478kzhfcRKSVCCKztgNShL2TKXYhA07a4vigutEIJ0RfnIxEJgvUxYggsV6skIoQkGZyKDPT/ToyI3tJnuVjSti2EiEwKRhIERFpIFIJAyhwIIbKqF3jv1131IYokCPVTEanhXiKlZLVaEUn2UFKK9Ee87EWJ6RwRSfCBzrZEZC8eCaxNOQJSSeqmRusMk+coqVBa07UtddNw5syZlEEhFWVVpemBtmWxWKxFLe8cKsuw1qK1JYTIaDwiIujaZm0n1XYdznuyPEt5BwLKskCp9PzrekWe5RRFQVmVtF3HYjGnbRvyvqh/5swDzGYziqJMuQldi1JJQWmbtp8EcWhj+vBkT9e1RDxFmXF4eERZVsznc9xqxezkmLJ8kLpumEynxBjJTcZ8vkiTGOr1/6u63rnEBXa5+cf7uPoG+8DOzqWXbnT2zexsXE0WSHdK9k5g8mNvvuvV3+3y1D98imvLkvN/+a/x1972Vs5vlZSTEs0BT//Kx7j6qoWEHd7zdz/Alez+W37P2HkPf+8DV15dIUVv8+hPfYhHf8pR37rJ9S9f5/r//Sy73zjg2X/+P0P1i7znke/BvsDBb3+Cj3/2Fpy5zJN/5XEuveUcW/mEMqMXU15JSPhecZHLby159gs3udk5+NotOPskFyegH36Yc+xyc/+A+e0/YJ+SK28dUgwGBgYG/qzy+v+/k4GBgYGBgYGBgYGBP/NY2yGVIjOGLDPkeYZ1lunGNGUleIcPobfFAR8CWZYRA2R5gVstU7c3ERd86uY3hq5pmc9mVOPROjMhhf1KQow47wkxFdNPw5alSoX/oD2r5ar3s0/rbJqGqqqS6OEceV4ghCRG19sVxX4aIU02TCYTfOsJwadCeQx453HWImW+DtCV8m6nvFIK2/aTCVKglCb4FCANAiFkChCOcW1zJPu5gUo5dAxMRp42CJyIyHzEqk5hzTGE9USCEIKmaZLlk0gByLHvyFcqhQ1Dyg4QQuBsyg9YTyEgMFojZbpvKbMiyRUxwmq1SiICJD9/KSkKQ9N2xJA+RwiEFHRtSwgebRSC020zlHz5Xyl7MURmxAjee5RWhBCRKk20xBjQxoAUlEWFAExmsLYjhkDXNkks0hprLd65FGqtU5e+MboPZbYoqdBG0zQ1ZVEwHo9Z1jVZnqf16iQWABityfIMIqj+HTDG0HV+LZxoY9DGcHh4iO0cdV2jlGI6mUKMZFlGVVWczBzBJ7EgCWA51nYIxDoo+9Tuquu6FCCepemGLDNUZUnXphyM4AOzkxlFXhC8T7ZIzn8vfsbfGZOLXDoLV597nuvdPnCBSzsvf94XuLRT8szv3eSr10puUXJl5x5fmq88y7UllI+9jw/95M5Ldw0H3LrzahZyjnNvBG7vcv2648rbXraG7hq/9ku/wf7GFd7/c+/+9t3sb30/H/3oqznnyzhzjnMSDr5ynevdFR59mZjhvvhr/O1/uc/2j76fn/0bFzn8d7/G//LZPc7/9V/iA49pyvMXuXL+Ilfe+W7mn/tVPvLpW9zcvydk+B6+m30TB1z/4i3gPO/6L97POzZe9u0LB6/hBnx37LzlInzhOrtfvg5fgfKxh5PY1AtRz3zlOs/m+yAv32OLNTAwMDDwZ41vNbA3MDAwMDAwMDAwMDCwpm4a5rMZbdcmgYBkK6O1Rog0gbBYzFmtViAE8+US6xwheKRMgbMxRpbLVZ/hm/zzESC1Whe1vQ8pFDmmKYfFYonWqeu8bVKB2XuPVJK2bTEmVfQODw/XQkEIEaU1pp9CSNMLyZ5I9fZDIPAuYK2jbhqklLRt6oDXRrNYLjk6OuwLwS11XdP0dkTOWbx3tG1D13ZJHHG+L+yLVCjXhq2tsxidchSSiBC5vN3w+INzfvwvHPFjb5rx9vNL/tJZzdZ0hNaae82F7hU+pJRJQJDpWqbTKaPRaC04hBBSWLQQRJk8fwTJTmg8mVKW1fo+CCFwzq2zLOCuldNoPGE8Hq+zHU4/X1sf9TZGIUaMMb1Q048lpFGGtIGSSKXI87LPNJDJ/ioGBOl9cc7Rdm1vDZQCq7M8ZzxJHfpGG8ajMc57Fos58/mc0WhE13V4n8QFqSQhBEI4tZFK12a0YTQaUxQFxhikUrRtm8LAbcfhnRdpe8FiOp3inGO5XHH79ossFkuMyciyHIEkMzl13WBMmpqZz9O0QtM2yb6oLF+STzEej8jzjK3tTabTyd37Q2S6MWFjY4MfuPAw040pk/5751yyPhqNMNrctcV6XTnHw3+hhP3P8/ReDWcvcfEVbGMu7lwEbvOFL+yDvMjOK1Ty66PZS4Nuw5xr//w3uf5NVjMaDICl7u5+evlHr1ACu595imvzlxyZ6//iU+wGB49c/i4sce6DvMzjj5UQdvnUv7jG/N5119d56jO74ODiW9IKti+cwywdu//H09x6iaOT4+iwAWBr65Xtib6zfU2yYepqmm860pzDl2VQuFtXeeq3vlsh4ZWf0bflkcvsSNj7t1fZC6fvDMAFHr4A7D/N018Bdi5z6X5Vql68rOtvvuKBgYGBge8tw0TCwMDAwMDAwMDAwMB9WS4WOO+SDZB3VFVJjIG6rlMXv095ASFC23UpJ6EvuiutCN73nfOsxQBtunVoLaTCeYgeKZOw0FlL1wsXxMiqrjF9wHHysw/rQGRIxW2lNZ3tyLKc1XKBD4HJdEpdJ7EgzwuWiwVRRHzwgCD4tC7v/T1WRklkyLKVbMDWAAAgAElEQVScrrPUqxVVWeGsJYSAVApnLd4HtNEonQrV2lSEELHWMp1uI0JguTrmjGl58xnL286d8NB0xSizrDpB0CO+1owpzQY3KDmag3P+bpF/bV10Nxgh+Ij3genGJkTBql6uMxmElNw1Puqtl4hsbG4SgbpeEINPYc19oPF6Wx/64N8Nog80TZ0snUihzkLEl+QoNE2DUvolhfI+YRofw3qSQylNZz3WpmJ50pEkwacMhdGownlHlmV451FK9RMngczkKcuga3v7qnSmtmkwxlAUZRJ2XJuefdelcObgyfMMpRTamJSv0dTpHfOOzlrysuJU+FBao5TuJ180ZVkgS5Gee1XStnZtdYVIIorocyFOBSutCkJYoU2ankg5HrIXxSw+hPX0iNKKSo0QUlLXNdPpFCkFWudYZ1ktl3/qv+HXwsWdi/B71zm48zLLont5ZIcdrrN7BOzsvLQQ/MgVHh1d59reb/KRv/8sly5uo9tD9nb3mYdttrdqDo8OOLjN/8feu8daep3nfb91+a77ds6Z4RlqKA8lU8xQ1jimWamQhFCA6UiuRSFyq8RhEQqoUKgwVENt6UJWIBVtAwuRXVtoHEBObQSqYRphXUuoDNBISJhGTVdyQ1uaVMOIE3YkckQeknM5l335ruvSP9Z39gzFy4jUjanXjxjOOWfv7772YOZ93vd54DqALW64Htg5yx//9r2c276Jd/38Ozh+8/v50Lue5rN/dob7/vEneejmUxwfGXbPPcb5AwOTW/nAz35/LXFuet+HuP2pz/Lw1+7jU2cf4uSp4xSH12JgctsHeO9hN/3xn+H9t/0ln/vKQ/zm//AIJ07exFZm2P3mY5zfM3D8Pdx560uUY17RtteFaY2dh7nvny848fqf5M6fOcmp247zwL/a4cu//UnO3XyK4yOonz7D2ecMxZEtisu7w2TCS001vBwv8YxebpP0FKduhrNnd3l+GDfc+MYT8LXzGODkW05du0i1vc1xYOdL9/E71Qlu/PE7ec+bX8VlRCKRSOQVEycSIpFIJBKJRCKRyDUJBf1sEBIsdV3hnGOxXND1PXUTLGCstbRNQ55loWtcBisanehhIiB0kLdtS9f2JEnKwXzBfB46zlerFfPFfMgFMLRtCEnue4MxlqZp6Ls+FHQJtkLWGrROwmt9z2IRRA/jLMaGAnaWpVhr6fsOnYTOf6U01hiSJPjga62RUtI0NW0bbGratsNZH4rYQxZEmmakWbbOXbCDMGJsaB/2QN+11NWK2cYWrzt6hB/bFrz7jZd54/QCR7LLFPKArXzBpr7Mm8pv8B9sPcuJrZytjU3SNCNYJA0ORQyTAIScZAvBh18qjl53jOl0gzTLw+QCIBHIId7ZA1XToFTC1uYRJpMZ8qrJhG+nWq1wFq47ej0b0w3yLB9yFjj8H37Iemj7nq6rh+75Kyfr8ThrgriBp21bzBCmLYTE2mAfJRBkWbjWpq7xztG2DQzTDtaG76uqBgRZmpIkCWVRDhZBKVmahJ+VJWrIxjDG0HUdbdcyn89xQ4DyZDxBK4XWCVmeo1TIoWjqJlhRDSKIFIK+7UiHddEOtk5N0w7CVVAzdJJgrKWu67CeEomxPZcvB78erfUwZROmHmazGWqYLFkuFldNhXi6tmV/f580G6zD8h9mEMBV3HySYEhUcMvVlkVXk97CLW8IX544ecvzC8HpSe76xbt4xxu2YHGeM185zenHl2y+9QN89B9+jP/srdvABZ781pXW+5Pv/gCnNjX1U2c4/ZWv8uQCQHPivR/lEx++k1PHC3YfP83pr5zhfD3lxNvv4mO/fBeniu/D9T/vWk5w5y9+gg+/7xTHs13OfuU0px89Tz05wTt+/mP88s+f4sopaE7+/Mf4yPtOcbyoOf9oON+dbptT776bj33kDrZfshrzSrbd4h1/53ZOjHS4J39xhgvA9k99eNgeLpwd7lVyC+/54Mf4xC+9l5sk8NSTLxNc/fK8+DN6OfSV9fNtYdwhsBvgJKf+5nfQ63rkHfzcu05QyF3OfeU0X/76D96qKRKJRP66IvxrY2YyEolEIpFIJBKJfBu7u/vrr7e2Nn6ox//cb32a8XgydHdL2rYeOqsTqqqirmuObB1hVdUhyNd7rOmZzSaUo1Eo7vcGKQWrVU3Thg7zNE0xpl933fshFyDLctI0ZT4/YGtzi6auqKsqWOSkKXmeD+JBMExZLpehD18I5vM5aZpQFOXgcS8pihH7+3tIKdYTA1JIrLOMxxOWiwVShcmJpm0xvQEhAQ8eetNjh2DeIi/wzuGcZTmfo5QauvtTZhvbwWbHebIs54brj3PTrOLH8nP8+JFvoqjpvaI2CUoqcmVJEsHcbvHV/bfweLPNN59bsLu3j3V2mDQYhITha+tD2PF0POPIkevouoa9vcvMD/aG4n2o6XsBQmqkUkxGU2aTKb3puLR3ieVijrU23PPn/ZNQMhlvcPx1x+m6hsVin0t7l/DODx3zwU5IeMiF4+5bnuWdP/IsZdKDdzi1ScWP8PjW3+Z/+Rd/ymPffJrO9GiVhiK9lFjnGI3HIDyT6ZQ0zTC2YzIe07YtRVGiEx0skPQwneAdzjqKskQKgbGG8XgUJg3aliRJaNuWtmkpRyVN01AUObY3bGxs4L1nOp2yWCyGexqEiBBWDQKPTlPqumUyHmONoShyDg72yfOCJNEhA2SYqhFCDPZaYa3meU6W5xzsH7C/v8tstsFkOgnTLx42NzdxlhAwPawX6x1N07BarcJUjve87vgNtE2Dc47//L/85R/YZz0SiUQikcj3jx/E3+nn8/n3Zb9XEycSIpFIJBKJRCKRyDU5snWUJEmoqxV1XdP3PVVVMRqNUSqE6XZdh1IqeOenCeVoBEJw+dJlLl/exRgzFPlTBNCvJxk0eR7CifE++MULQdOEbvdVtRp88S3p4MnfNA2rasXBfE7VNCAkSZKSDZ35XdfTti2H1jVNU5OmKaPROBTQAessUoRicNd3dF3HcrnEWRuCpdPQNqu1RiuF8x4hFb21warGOpIk7PNwQgFAKw1ChlyHas4N6R43b15CCUttCx67tMWD37yBP//WMb61mOC8ppQVt0zO87qiYTIeo5JsEDIESInUCSpJkSpB6wSEpGpq6qYiSTLKcozUCiHDpIGQEqEUyBDQXNUVvbFkeclksoHWCXKYLLgiI4SRgnBvK7ROKUeT59kXhWd0OKAQhJ9DqykOf/cMQcTdYGekyIuCoiiBEOzshmDutu1o2xYpgm3RZDpdd/IjwrmIISPCDuHGfd8PuRBBEHIu5GIYY0jSNARySznkHAQBw3vP7u4uYsjmaIeg46Zpg8WVCMHUdgjUttYMzzgEcfd9TzpkJICgLMu1CCOEoG1bLl64sM6NcNZRraogcqQpbdvxzDM7NHVNVdVBEBpyEbRSZEnKxmwDrsrEiEQikUgkEnktETMSIpFIJBKJRCKRyDURUuL6YFfTti1SCuo6dE5rnZAkmiTN1gVfqRRSSLxz1HUoFEupCM36oWs+TZMhqFmuLWKs9whCx3nIWDCheDsUbLVWdF2P8452sD9aVRVbW0fw3oVAYqXw3tMMPvpShqK+lMFWyfQ9Uiqs9QgFVdUEyx1jB+uiFGdDNkB/mIkwFMwPO8fN4PevkwStNV3XorXC4VFSIqUP4cP9nFIuGaklQnieXY350s42j++XjFPPXq0ZF/uMU0Mql/RtjcmPsre9hV1eJlvtgze4tMBkYzA93gev/aSes9+0zNISkY8RxQTbtzg0PiuQzRLpPV4IKpnwnB6xmY/p0bS1o+8q1GoOIuQrSGfpVUE12sRZxTGv0ElOUozpmyHYVHo4zGEQ5op4EKKdAYYMBo914XkgQg6FVALrXCjUD/e0a8N9643HmIRSjejaljTLsMasJz/CGgy2QzrReB8CrsOzdkOQtBxCs7twRsMERNe2ZHnGfD4fJlk0QkiMsUO2gSIrc7quR0kZbJiMIc9zRqNRWM9S0XUt3vswfXPkyDrXQanwWtPUjCeTYJPkPdY40iQNAoW1JImm63sEPYnWHOZz9H1PWY7QSQgI701P33+nKbaRSCQSiUQiPxiikBCJRCKRSCQSiUSuyXxxECYC0ox6uaQocpTSLJfL0AmepMwXC9QQxpwkCc558jyjqipmsxlCSvKixA0e+EVeYEzo/DbWgpQoD0oriqIY8g8WQ2E+iBLLagWIwd7GkqQp1jnSNAEEfd8NWQgmFKmH4uyhwGGtResEISVt1wwFX4uQAjeE4iZpStM29MueUTmibRsSndD3PQBKKdI0o2lqkjTBmH6YAggd+s6HPn8hYCNZcl1xgJAW51O+MZ/y+HJKh2DfwP+zN6N8SrCZ9RgKHt9teHxri9Ov+zGy1UWOLZ7GCYl1nt3RMWRf41RCanpm8/McKM3SedLxlJWasmwbeq9oixnTy+eROiFr9jnIN9g5+hNs5AXlYofd9AQ1kuu/9VdoD0hFMd/hYHYDT//IbRRdTb18mtl4E7EpWRqJcQ7tOpJEM5k/i7ALxFpAOLSBEuDs2l5JyvCc2q5F6mQIQnaYrqMoSoQUtG0TRCbncB6M6ZgwwRhDlmaoIaA5iAahkz/L8kHEAK0T6rpiuZiTF8UwIROyDLq+pyxLVtWKtuvYPzggy7K1rdF0mIAYlSP29/cZjUoWiwO01rRtw2Q6XQc7e+8w1qK0pqor0jQb1pOmGTJCvPeMRmO6thsyQUIoeF3XZFkQK5IkYevIEXpjmM8PyEy2ntAIweNh4iYSiUQikUjktUQUEiKRSCQSiUQikcg16YdAYa0T2q5bN6FfvnyZLMsQQnBwsGA8KpFS0HU9QkjqukEIQd8bQr1a0XUdWZavg2wP7WEARuMRXdthbQihFULQG0Oqk9BZv1pRlqNQjB6EhKIohikJSdu2aK0xxmKdRfsQoHx4DOf80NE+1KGHirdzDjwYY6iqFd5D33WYNF2LCIeTDd6HqQPnHIKwrTEG53tUGsKGAaQAIRzerEAIrM/YNyMqq5E4LJKVFfzVhU1K7fFecKlznN9IuZQd4ajp+VY2ppJjVL9kkUxxfYtPMvJuxcV8E6kzjs6fw42PYsaWeQ/OGazKmIkSk085fvksK5lyfnIjTyUF23VPPZ2xkGN82yJUihOaG5xjPjnGc5s3kR5coEZRlptcl27zlJ7i+g7tWrSS/I3VLtgX2iKBCIHEbshqECEgWko5uB8JjHPr6Q6pBLbvEInAO4Y1E4ru4GnbBk9GMthGGWNQKqPvO+QQtF2WJVW1WodfO+cpigLnPInWFEVBVS1BCPpB9FF5DohBwPBhGkEpgCGnoVivTyBYLQ3TJmU5whMmJbquHUQGT1mOgjWREEynM6q6ClMpHtI0YzGfUxTl+lqUlCQ64ciRo9RVxXg8xjoHh/uKRCKRSCQSeQ0RhYRIJBKJRCKRSCRyTaRUSKHoexOK9YkmTVPadoWUkvF4Qp6HYux0OuOZZ58BISiLgvF4QpIkJGkSbI08gKeuKpqmRmrNarUaxACFEPDssztMJjOkHLrQffDTH43GeO+p6npts5QkIfDZmODLPxqNKApJ2zSUo1GYMhimEpqmpe+DKLJaLVFSY13ITDj04nfOkWX52sNeKUXTNIM//mDz5DxpGjIZ6moZAnydQziPV6HArgErMhwpwitAI1VKIsH6cJ0exdyEjn8Ai8JZT2J7Nvslz6YbXExnpELTS4VwIoQQq5S9fBObjGiNwPoUMOwXG0hvUd5j845qeoxxvYtoV3gUtUioREHnMvpkwu7kRvp8jHUw2XsSo0Z4NH2S82z+RoQsOVhKdkfXg3doU3Ns/hTS9fC8hAVxZbE4FwKivUcISXA3ElhrMcPEh3cOay1KabK8QGuNFJq+60nTkHOhdYK1hrqu1/ZSYfeOummZTKZBzBFh/Zkhc+MwRNpZS1nkKCmHCQZFnudDaHUIXD4UiC7vXkbJoCz1fY/SijRNWC6XTCYz2qbBWEuWZjhnKcqcrmvJ8wLnHePxBIDVaoXpLatVmMIJ5x6uczKZorRm9/JljOkpyhJjDGmWkGUZbVvjXZicGY/H3+dPdCQSiUQikcgrIwoJkUgkEolEIpFI5Jq0bTvY/LQIqTDWkSLIsowsy0JXeNMitcaLYF1U1TUmTRmPxkM3uAmd/4C1LogDXU8qxGAbJFitluR5jjFDwG2aBusjY/EIlNJDZgJkQxiycyEzoOs6+q7HZBbv3WBfw3C84Id/GMIsROh+P5wwEFIgCTY5XR889g9tk7qqHjz5zdoyJ88yHATxgCHgWITJBzkED4ew5i50/HuFEI5JYsi0oDFw2OF+w7hnknqc0uzMU4q+BtfTonFeIrxBOocGlOuRSCZAi8Pgsd4h20XIOZaTMAqBx8sULzUkKUlXIU2PTD1OAr1BpBarUozMcKbDS410Dgk4nWEQCOtYOY8JV4VEsLG8iLIGKRiK+1eJCEMmwzBeEIKDh1wMrRTWhmdjvaU3HVIx3CsFPlj6jMfj9RSDdxIpg4AVFCixthMypkfrhNVqCQi6rl3bGjlnsYCSYapAEKyRtNZ4Z1FSoXX4JYQc1oclS1OKshjCwA1SyCFYmjB5Ayglsc7Sdh2JDlMQxaSk77p1EPjh9IrSiq7ukFKRZRm9CevNWoe1YTKjrpuQ86BTlstFWONDRkckEolEIpHIa4UoJEQikUgkEolEIpFrIqVCKkXd1CSJJs9yhFR0fUWeF6xWK5yzZNko+NlrvfahN85RVVX42oScgSzLaNqWqq6HwOJQkD0M0S2KcgjEDR3ph0G6i+USrTSj0Sh0qSu5zi44tC4SQtDUVyxngnAgaNsW54KI4axlNBpTV1XYVgqsseu8g6qu0EpT1fV6KkEIMKan61qw4Rz7rgMhqKuKsgzChhgEliLNuVx1PH5R8PoiIU1abhhXbOYFz60UEslm0vK333DAVraiIedfnrueo/UzHN/9BkW3QuhdSp2Tdw290CTAaDQmbVaMrGORjTk6fxYrwOLJ22YdSiy7mkJLtnyHaZdsrC5i+wWT5QW8TEldg1pdJmkX9EJTNAeU9EyrS3TtkqRa0aYTNpbPoZRGmYbCrJg0l1DekWYZaZIRJBgxPINg7WP7PggPSmKNQanwjJ33OG9DwHbfkmiNSCTehe2V1HRth+cwoDghSVKstbRNM1gihYyDvusRCOqmGayUHGVZhmwNY0AGMamqVnRdh/PQ1jVpmqK1ItEaqUK+g3WWNE04evS6wW7LcbC/z3g8WQtaQQQZJjC8AA9933FwMCdNUtquResEKTVumLhABBGrsTX1+tgaKUWYxhmEGK2DZZKzrHMgIpFIJBKJRF5LRCEhEolEIpFIJBKJXJN0CBW21qKSJHTr2ysm+YvFAqEUdV2jtVpbDjnnODjYX9vNHBaAl/0SKTVJktL3hiwLocxaJyilMCZMEOR5CHWG0FGeJIq6buj7bph6WDEajREi5DLkRegmb9oGrUNne5qmdF1PluW0bQgLbofOeCklRVFgrKGxDdY60jSjbRt6Zwb7HYV1liRJcc5T19VanFBC4Z1HyuCvn+iEsihJkwTT97StYq9JqK0mSTpeN5rzzhsK/u2lDLzn5o2WWzb2yFTD0vRcV26zeXmXN138N+A8Vgp6pUmswUnNxmSDvB+xe+lpJl1HnaSUfY11AusdRuUIKYNNk1Ak7jJltUdV7fKm576KkxLdVngp6UlwXYOVCq9SjtkDpG0x3/q/aU1HWtd0ScaoWdItdxDekNuWmZtTpJqy0AghQVwVtgx4a+jqBjzDBEewOeraBucHccGF0OIQnB2sooIQldF1DUoL+q4LEw1CDJMAmizL8HicD8HEXd/jrA/r0/aYvifNcrqmoSxLmqahNwalFdJ5uq4L9kaE9ZJmYi1Q5HmBtW5YuyFbA4IQ0JsurMs+7Et7j3PD1AuS1aqiLAs8Au88bRemXpbLJWIQohgmV4L4ZcLPVAgnL8oxzjnK0Yi6rvHOE4lEIpFIJPJaIgoJkUgkEolEIpFI5JpYG/IHkiTBEzrznXPr4qtOEszwnroONkWHAcree0aj0RB6PHRoVw1ae8qypG1b6romz0PAbVGMWC4r8jxHSsVkMmW5XNI0NZDjnAu2M0Nx1tpggzSdTmnbDvBMJ7NgpeQNaVoChrbpkINIoQaxwxqLc24dqlsUOc4FEx98sDfyeKSUdF2HUpI8LzBti3eetEjpWk9RjhBIJuMJRV7Sm55lUyO959mq4GvPrnj7jQnTpOGtxy7yo7MU7yybeUuhLK1NeWK3oLaC1HccaS9gvMINNkl5qtne2CRPOw5Wc9rVs2R9z6bwgMM6gfPgkSQKJmVBmo9x1ZyD+QGiayi6fYL/kcXhw/utQ2lNWYzJc0VbH3D98hl673DeI51DYRD1BbyAVHi2tjYYpRO0MBhrh8yL4VkzdNTbsP+2aZAqwTtHNwQkC6kRSARysKqyFEWwzTKmDxMqKgRi4/1gPxWsjkIRvls/i7btkSIU6q0N6y5NU9RhtkXb0Jue2WxG3/VkWbaeLlBK0XU9TduQJgld2/LMwRznesbjKaPRmCzLWa2WVPWS6XRGMgQ613VFkgSBqihKjDWAINEJq9WKsihI0gxYkSRJWMtC0jQNRV7gnCNJE6pVRZZn4KGqVkiZDILaa+Cf6otzPPxH9/PQ13eoDZBuceK293DX+25l6zs5vUfv5eO/d4btd9/DPT+9DcCZ3/84935tm/f80j3ccd2rOKcX2ee1L+MhHrp4ive//fD9F3joNz7DAxdPcfen7+bUqziN/3/y79d9MV+/j0/97g63v9q1FIlEIpFXzGvgbyeRSCQSiUQikUjktY51LhTLRSgOd22L1po0CxkGUgjMEE4sROgi996jlUZKRZpmGGNIkpBxkKYpTdNirUVKyaElfJomCAFJohmNgsiwsbFJ2zYYozk4OEAIQVGUKKWGArJdF53Bry2Pcp1jTE9dN0DojrcuTCI4G3IVkiQE6tZNzXg0xoVq/NoXP1GaZhAN2uGarTFhAqLvUDIcXyuFVDqcv5Q0bUdverQUPLXMmCUzfuwGy1h3jHXFZNKEgr539K5gZUoe253x1EKTYPixbcnju45lD9pLtsuMtx+raPqWRy5VaNsxTjpOHgkF8W9c8jxbCSSemzcUP3pEsO9ynrq0QjBnhWOzlDjryZXloBNcqj0JjjcdUSx7i/GeY6Met1whhMUK0Mpzw8zx3NxgHLx+K4PS0zlFW6/WmReEWAaCsRM4IambMIEgbMi3GI2ntF2LFBLrHFJpEDLkX/hgBWQdjNIC6xxpmgzrQ2GsYZyPyfOCvu/Aw2q5Ik1zlFK0XUuig8glhAgTM8bQdi3eQ920wc6qLOn6niwJky+7Bwd4gtVW33Vorej7YGGUphl93+NcWJzWWtIkDRMV1gIC76AcDZMPvQnrJ5zFOjmiazvSNKNuVqxWK6azKakOnxulFM5arLU4b7GmQwpJ13bf/w/1y3HxYX7zn9zPjgF97CS33lBQP32Gs39xH7/2tTPc/d/ezanih3uK3xFfv49P/e5ptt/9Wi+LR14Ri9Pc94enqfnOxKRIJBKJfG+IQkIkEolEIpFIJBK5JqPxhDzP2d/fI03T4CMvQxCuMSFHAO/RWjMajdl5+imKosAqgxvshYwxCCGpqhrwFGU5dJYrpJTUdU3X9WitKYqc5XIBCLwPAcch0FghJSRDIbjvO/rekKYJ8+UiWOk4j1KhC3w222B3dzdMEhQ5y+US5zzWhaBb6+zaPse5MKnQ1A0IP+QhuGCLIyRpmgyBzh1FmmOsYbVaIoWgl5Ky1AiCoNI0Nc47nFcse8UT84I/f3KLN832OXmsRjiPQGN9ws4i5Yn5iCcXOfutZqx73jCreW6e0prQWX/dKOWNxTNccimuB4FlmjhumjXsLw1vvm7EhSdDYHEuOt446fjys5JjecMbtlvO7WkyZeg7zzS1PLlU7LaSQklOHrWcvdyzv+o4sdWwWhr+5usKVGL4dzs1tx13uNdJvrEr+dGjFSu5wb+9NBTpr7bgERDSrT0IMQQKG5I0w/QWqTR5IRFesFpVeB9yAtSQvWGdochz0iyISXlesH+wT1kkWAtd1yGkwBiLzpPwe+JQQtENQkGYNNAIAVIK0iSlN91gF+Qw1qzXV7WswUmSJKwpqRST8Yi2adBa45ylKAt60zJJJ4NY0COlYDKZ4hFY48JkjIDOdGgfhLKDg4N1jodzDikEBwf7AMznc9IkAWBjY5PVconpDWmWkiUK7z3ND9XayHD6j+9nxxSc+vl7uPu2yfqVC3/ym3zmwTP88Z/ucOq9x1/xnk/9g0/z6e/lqV4L92JZE9vc8Uuf5o4f5HlEvmeYnYf53D+/n3OrH/aZRCKRyF8/opAQiUQikUgkEolErknXhUDjvu+RSTKE3mr6vidJEg7mB6RZvrYAms5mOBuK8IpDr3zPalWxGqxbUiDRmiRJsMYOQbTBGsYYQ9d1gGC+mGMGK5o8zxBCUlcVLs8HIUDRdQZjQud433WAwTlHURSDABE8/IUQeG8H6xiPMWYQP0aDdVNKlmfUVYVOEqwJ+9FJmKxIkhS8D6G7PhTMEYKubcnzEZ3pqeuO3lgcAus9wgsutZq/fGZMY6ByJRu5R2nFolM8PdecuVhwscvpXNivEj3HJhmVkWxvaKZ5hjc9B/s11hTcsJHg2wYtLIlweC0Q3oMUWDTO91w8qPgbWx2vz2uqyYi6tSgFibSo4Z6UacpmbpmolnlfM9ItpXbcOKkpcsczFywaj5YrjozG5IlgXjvqZknf9XjvWZe811+IYX3I4Xn0SBUK7FKF46ZpipAC7wVJmmCdwXuLVOH55MVomDzwQ9i1ZrlaUFUrirIMhfc0QyDo+x6tE+xgeaW1pqqWFEUJAhTwjQQAACAASURBVIqiDJMkth+eG1RVhXMerRO0ltR1gxewqioSFYr5vemgDRMGeX44dRDWZFk6rHX0xlCOSsww/TAqR8PETTaIDmqdFTKdzTC9oevCZMtyuWS5XGD6kDXiE8/l3ctsbGysbcF+OJzjyZ0JevNW3nWViACwffs7OPng5zn79ce48N7jsR888oPDLTj3p/dx35+cYyGPc/y6HXYu/rBPKhKJRP56EYWESCQSiUQikUgkck3quuLSpSVJohmXJWmaoLUizwvquqLveowNNjdFrhiPJ1y+fAkhxWBdZFksFqgkAeHxhLBcNxTjq7oa3meGvAKPGCxwnPMkOhmEhRDW21UGZBesb4SgKEtGSpFlOXt7ezjvaZqGy7uX8c6vC8BCCLIsDwXpoqAsS6pVRV4UdH3ParUkz4tgbZMklGXJYn6wFkKKokBJyWo+RyqFNZbJeIQ1Hmsci8WCzjqs9yFkWAi8EPQoLnbw1UsTvrHUnNgqaWzLpXnHykgOOo31HiccjZM8cUmRKEORJGyOSxoneeyCYm9l8N4xUpZ9K7i01Bin+MZFixdJCLPWCecP5uxVhv3ccDFTzGvPqvV0xlP1ilUfMgrSfERvFrx+2rE/N8xrT28stqvJipzeCJ7cU1gvcCrFLjS1bVmueqxzeL6t4D0ELOMdahBeDp9bU9cICWU5pm1bMikxtkNK0FqhhtDmpmnpe4uQQaQxw6RBmoSpFu8cvXMheHmwz3LWIQVorem7jlE5wjpL17ZsHRmzWq0GQYkw1dCHbIO6aTDes1ytAEGf9GxuzKibikIUVFW1Po6UktFojLOOtmnJsgwrBG5Y913TMSnH5HkeAru7FikFo9GIVbUgS0M2gjEGpZMgoFmL1JpVU9OZHi+DcCblD1NIOMn7/+EneP+LvfTsBXYAtiZsvYo9v1RGwu6/+SL3/ctHOL9nQGq2br6Du+7a5s/+x3s5c917uOeX7niBaLE49xB/+IcPcfZwmxNv4z1///3cunn1scLXFx78DB9/kCFbgRdmAVx8iM/8xgPw7nv46JvPcd8XHuCxp2oMmuL1t3DH+z7A7W/4Ni+n+jwPf+H/WGdI6NFxfvLv3M3tl/5XPvPgBU598NPc/ZaXuxtDJgHv4Z6PvImzX/hD/tWjFzAO9OZJ7vj7d3HHG4pwb/74Ec4fGNATTrzz7/LB/+gkE3nVrswuZx74Ig/81TkurAwcnvfPvp/bb5q88NB7p/ni//YAj5zfDcc7doqf+Y/f9ZJnai6f5v7//cr7Xy4v4wXv1QXbr7+VO/7endx65LsoQX39i/zOg+dgcooPfORuij/+OPdGISESiUR+oEQhIRKJRCKRSCQSiVwTKSVZll3xxCdMJyitMdYilSLPc7xz1E1NORqRJMm6EFtV9dr2RiBx1pFojfNQVzXWGpyTg/0RjEYTqqqirfq1h37ft8HOqOuCHZGUCAge+U0TrJL6FiEhkcEep+u6wdc+FP3HoxF935NnOd4Hi6OuC0HL1lqEkCHwVydr8QARut7TNPjaCymH/YXAZ+eDn78H6jaECwvEYPUDrMUE2G0VLhnTzTWLylJ1g9hwJWSA1gr+3X5Gpj0iyZm7EXsHc843CmNSlr3AzA3Wah69HKYe9loBQpFnOXuV5fQcagNPHmjmreKglRgncHikF1RWhsI8mq/sCHCGi7VnrwFjEs4vJU9VkmcqydOVAJFQjgrc3NCYmrYX6HUhU4AXV752IR/DWYvw4F2Y4JBaYfqepmnQSRLEJK2RSqGThFSlQyBxS1EmOOdp244szYJlkQ5rrG3bMI0wdO2b/jCbQ6C1DlZUSiFkmBTpe4MxPWVZIpUMuRbG0BmzFrQOpxxm0xnWOiAEg/e9Bd+RpTlZVpBneZiW6XvMsF6csygpKIsiTEbYsF7NMK1jjAEfLLrGo2CRpJVC6zDlUg/2TgBZmmKtIUvT7+fH+ZXjDLvn/ozP/8HDLOSEd/ytt33PignBLmkHpGb75K0c17ucO/sAn/31gpeKYVj8xe/wqw8u4NhJbr2toP7WGc4+8WXu+5926f+7D/G2ArZuupVbF+c5/cQuxfGTnLy+YOt4AdQveS5m5wE++ydnuDA7wS23bdE/fYazT53h/n92gf5q8aM+w72/fi9nVqBnJzh1U3jvI//i1zgzeoXhEd0Z7vv1B9jptzl5660ku+d47ImzPPDb91G/c8HDX7rA9s2nuPX1u5w7e57zf/Y5fouP8rFDa6n6DPd95l5OL4KYcfK2bYrVDmceP8P9v3OGr777Hj56dTD1cw/xm//kAXacZvKGU9y0BbvnHuP+f3YG5AtPr370Xn7t985Qc/h+fSUv49HHuPueu67kZTz3EJ/9Jw+wIwuO33wr2yMwu+d47Ikvc99vPMnuf/PRVx+MLDe56d0f5q6fuomJhDOvcjeRSCQSefVEISESiUQikUgkEolck9lsRlVV1HVF13VkWU45Gq+LwnlRUOY5VV2jh+yC6XRK27ZY62jbdphOKPAeptMp4/GE5557DuuCr33XdbRtw2g0pixLVquKzY0NemNwzpAXOWmSYq1jf38f0xvUuprtESKE5kopaJqetm4oR2XYxjkO9vcpi+uGLneDkJLVwcEQnjzkJBBCdpPU0zYNbdNieoPW6kqeg5ChQNwHq5yDg33Go9ABH0KEQ2d8KDSHIrsXBJserTEeLs5X9Db4t2ulg5DiPUJ6jBfsdwplBJtFwbcuzVktF3gvcC6IL60DvGNlBc57nBekWYoxlmVTYS1YL9jtFAc9WAfOizAN4kFKzSjP2VutuGwtzkDfCbyXCBK+/LSmd1C3BkuY+KgqR121QYxQikSIkG+NIFQgQ8iwR9L2ht6E61PDpMiyqsjyEqV1KKi3NVIFgWoyGVMtViwWC7xzOCBJU5wLFlDCCOQgHAR7KhdEnSGTQqrwTPKsWItdUkqMtcMa9IM4NBT/PXR1Td91TGdTpFQURcJ4MuHgYJ8szRFItBqmBpSibVta2rD+83zIUQj62Hg8YiVqsjyn71pWqxVN0+C9RymNHc6j64IwIpWk63qyTNLUFaPRGCElzjnSJMEPAc+vBS78yWf4zIMXhu+2uf0XP8qdr/8e7fzgYe57cAdGp7jrv76bWw+b5+vzfPGzn+XLL+GDXy8Mp/7TT3D3T6w34PTv/Rr3PXqWR7664G3vnHD87Xdx1+ReTj+xy+Qtd3LXupj+0kLC7qNnOP7ue/iVqwrvFx78DJ/5kws8/PA57vhPbgLg7P2f58wKjv/0R/nIu4+vCyu7//pz/NMvnH2F92CHnTfcycf+i9vZGv44O/9Hn+KzXzrLw186znv+q1/hjmNX7tdv/uP72Xn0zGAtZTjzhc9zegHH/9ZH+PD7TlwRXxanufd/vo8zD/4Wnz/x3/OBmwEu8NC9D7DjCk598GPc/ZbDd9ec+f1f496vfdu9qR/hvt8/Q12c4M5f+Ai3H7vy0u5ffo5/+oen+fwXTnHLPziFBs7+nw+w47a4/Rc+xp0nrtrNX36OT/3RDo+ducAdP/UqDbHefCcffvOr2zQSiUQi3xteRG+ORCKRSCQSiUQikefTNDXz+QFaaXrTU1UV1loQgqZpsMYEqyJrwXuefuqpYGU0dIoLIZhNN3DDxIIQgsViTts2ZGlGmqakacpkPEEIQdu2IcBZCLquw1i79prXWqOURimFVorRaLQOczZDQd5ay2g8Js8LdJJgTCj6N3VDXde4ocCrdYIQEj/kJzjnsC5cQzqIEnkephfatqXvO6wLNjveBxFAa4XpDW4o/npCGPSoGKGlDg37oeKO846qbWj7K/kCQbhIEVIO7wHrwXjBwXLJYrWis5beCYwHLyTleIYXmt5JrA+FcWstq6amtw7jwuwHQiPTEicUFonxEuPDBETd1NRdS2OhthIvE1RWYrzmUg27LdRe0TtBZzzLuqUb9s0gLkilhvyJK7+8CAVxax1iyDeQSpLnBVIK+q5HJxqlwzP0zmGtHQQlNUyzpJi+p+976rpBKb2+tyHfQpAkSRATRAjzFmK4prqmaeoQ0I0I6xRP3/e0bbcOQPbek2bhOY5GI3SS0LbNWpgA1lMP1ljSLKOqKkAghRwmDULhX+uQ89G17fBM0/XUTFHk9H1H0zTD2m7oup6iLNZrOU1TkiQZIjeCOPJaYWEmnLrtVk69YYLmAg9/9lf5nS9duPaG3wE7/9eX2QFO/uxdV0QEgOIE73/f215yIoGT7+Wun3jeBtx6WyjyN/VLCwXXpHgbd/708wvd27feyjZQH+63O82XvlLD7HZ+7ioRAWDrP/y73PGKRZaCt/30FREB4MRNN4Yv3vyuKyICwOwktxwBLl/gAkD3VR75Wg3F2/iZ9554/v2a3Mpdd54Eah7510P//sUznL5IuH9vufrdBaf+3vs5+W0VosVXH+Gsg+M//cHniQgAW2+9k9uvg/prj/DV4F5G3wPU7F1aPP8K3/ohfuUffYKPvFoRIRKJRCKvCeJEQiQSiUQikUgkErkmzz333LrA//rjN1BVK7xzVFUVApfTlLquyfMCISVVXZHl+SAkwObmBovFkkuXLvOjb3oTXduSZTlaJyil2N/fQynJZDJlf38fKWXo6EaEfAPhWSyWbMxm+MFGx1iLkND3weqo67vQvS4E0+mExWKBc24QIELRflWtgnDgCNfgPUIKsixjNVjRtG27tqXROoGh+CulIM9ylssFWRJEBmMNZTnCdD0M2ct+CGOezabUVU3VLEPoMoTMh2F64hDvYDKZsVjO13kCoeve0/UNQz5wMD9yHqQnSVKmsw0O9nfX12aGYOj19oTt8jwnSVIWywXOO/A+TE8MFjwCgRQK5y3T8YQkzdjfu4wYMhDEIOYcOhgNcwEkOqEoxwixBxweV5GUY2TlSBKNaENR3vsgrhjrSNOUbhCKuq4hTcMasMaQ5Hk4d8EQsqxwzrJYVOR5zng8DtdpHd4FIaBtGpy15EWxFmyauiZJUq7b3qbrOpwLEy9VtVqvia2tLZbL5TrkG++p6xqt9WA/pJnPD9jc3MRasxaTgiWRYLWs2ZhtMl/Mg+VW3zGfG5q2ZVSWpGlKOSoHwUBhhgwNpRSLxRzT90wmU6azKXVdkyYpSoX1OxqNvt8f6e+Ym37mw9x0+M1gi3Puj+7loZvvefU2NQAsePL8LrDNjTe+SGni5pu4iUde1MKmmG29ZDHjwuU9eLUx0Me+gwDpJ89x3gEnbuTEC16ccPLkFvc/tfsKDrrJ5ksETmwfP/6Cn+mri/2HmRVvOvkCEQBAnzrFyT84y9lng/CwvbMTfj9x4wvvX3oTt5yAs09c+dGT3zwPQHPmfu7beeH+dw3Aec4/CW+7GW657VaKr53mzB98ik/ev83xN5zkx9/+k7z1jccpYvUpEolE/r0n/lEeiUQikUgkEolErokQgqIoESIUhNM04/Lly0gVgpXbtkEATdsEz/sh9JYkQR9atqQJ119/PVIIpAyd4oeF4VCclVRVPRxHBN9479FDcXW1WjEZT6gHj/kgWgguX77EaDwmTTOccTjv6duavutRUlHVNdZaEp2E4r+xjEYjFstQ1E2SBO8cw+gAWinMIE70psc7F7ruPUghkQjcEPKc6ODrL6TCWs/aW9/09L1htrGBXEhW9RLnDVfsfwhTEEDXd4zEmK2NLfYP9un7HuvdIBwM958gUBwKDHVVsbmxCVPHfHEA1mLs8+1wBMAQOn1k8zqEkKxWC4zvccPxGeyJhAhn1rbBkspbx2o5x1pz5diDqHD4fd1UCC+ed0y8xTQVDo/zFiFACYk1PV5Isry8krPhQUqFVJq+68OUiFYoLSnznPl8STZMDOR5jhSC5XwJgE40QgpSldIMz9c5h5SCruvRWpMkCU3TrCcQ0jRBShXyG5xjuVyG66hrpJA4a1FS4r1DaY1WirIsEIJ1SDKEiYjFYoHSCXXb0NQNRZFTlmOatmI8GiGlJM9zrLXs7++DkAjh6bqOsixJkhRrQrB4nudBZBrstpqmodycfU8/v98zjt3Bz73zy3z2zy9w5swud/zUq4lcPqSmXgFssrX5Ii/Lly5XTGYvEiB8SGiLf3VMJrzMngNdTQ1sHX2Ja3+Z835xttg+8go3OWSxx+LlXk8Lkqu+vXDp5SZJJkxe4uJ3nzjN7hMv/hrU1MNEgn7zXdzz4e0hBPsC5x+9wPlHH+Z+NJOTd/DBu+7gxCuMkIhEIpHIa4coJEQikUgkEolEIpFrsr19jKZp1t/neU7d1NjBIsYaQ1YULJZLur6jLEdhgqHrqJtmbfVSliMuXXqOzc0trA3ZA1ofdnMfkGX5eoIgTTOapkYISZImTCZTmqbFdD11VVMUBXXTkKQZBwcHeO8ZlaGIOx6PWa1WtG2Lc6EwPBqP8c7R1MH2RkmFtZbGtkHcUJK0yOm6jsl0hpKK5XIxdKM7iqLAGhPCmxF0CPCOLMsAhryGIBFYY1ks58xmM44cOUq2Srm8ewk/dO77IVgZD73taaqGo9cd5WiSsb+/x6pa4nF4G94npURIESYS8LRtTdsWbG0eQauEg/k+xlYw2CUdlvedD8VrayybG5topdnf38XZb7POCZ46wb7JWI4ePYZWCfP5HtZ0w/4O9yxw3tF1Hd1gIXSIx2NtS1qWWOfo+448LwFo2o5suJa+64LlVG+YTqdIpZhtbAQRx4aqpNYK8KxWS6bTKWmWcbA3ZzQeYUxHXdeYvifPc6azGdYapBSkaTKIFUEkyLIcY3ryPGMyHtO0LdPpjPn8ACDYdBlD3zZkScLmkSMh0DkvUYlCyZCPsFytGI/HJEka1shkgveO/f1dEq0RCPK8YDweIZDs7x+wWq0oipwkCWJJnuf0fc/W1hGmsxnVaoUaRLEsy7DOoaRgVX0X9jzfZ078yI3AGYz7bu2XCooRcHGP3T3gu5pu+AGShhDo3Uu7wAsnBn6gTDaZwEuLCV3N1bLK9tFt4KXEBLMWBL7tINz+kU88L/PgZU/ppjv40C/fAd0u5889ytf+8mucPnuexdkH+OzvFnziF95xbbEmEolEIq9JYkZCJBKJRCKRSCQSuSZSynUOQQhFbte+7kVR0Pd9KDNLyWgUsgnKcjR41wf/fqVUiOUVkrbtBi/7hqqq8N6TZdlgnxQsaPq+J00ztNa0Q3DtoX+8VILemMH/PuQMaKWGqYaK5TJ0rltrqZuatm1o6opqtSLL89B9rhVKKdIkWR+vaZowEWAdbd9dlQEwHM+70EEuBOPxhDTLho53GyYwOOzud3R9F6YetGI6naGUDjLDYeFdiHV+QtPW1HVDnhVMJ7OQ1+AdfvjP4XA+TFt4D84ZqnqFdZ7xeMp0unElj+Lbnp13juVyDsB0NmO2sRnyJ65CwDojoloF+6fZxhZbR44ipTyUPdb79j6ct7UmfCOG68EjlaMsx5TlCCVVyEKQiuuuO4YaQpF1kpAPgcVaa/q+R6oQGJ2mGUJIlJJIFcQEpTV4KEfBJmg6nQbRwRiMMdR1RZKEnII0zULQsglrzg6h10IIsjwnS1O6rgVClsbhPsaTCVIn7O3tI4QMAeFCMl8s8Ah0ktK2LYvlIvz84ADnHLPJjL7vWa1WKBUmGpwLmR7hetLhOsI9DhMNwdooTEaEMrBONHVVMV8seObZZ7/rz+yr5vwDfOZTn+Tjn3uEF5MKzj5+DoDN2XczjQAw4YbXT4ALPPnkixzp7FnOfZdH+L5w44lgaXT+Sc6/4MUFZ7/+vcmP+I64fjtIGf/vWc66F75szpzh7PC+bYDjwbrpwtfPvlB8cOc4/20XtH39NrDg0TMv4mvEDvf/6sf55Kc+x5f3AM7xxV/9FJ/81fvDfUm3OPHm27nzgx/hE//oQ7ytAJ44x5Ov/mojkUgk8kMmCgmRSCQSiUQikUjkmiwWC/b396irit3dXYwxZFlG27RcuPBcKJR6z3g0oixLZrMZaZoyGo3I84LJeBKKrdVqCGiu18LBoR98yEvQoTPbWrIsGzrJc/I8p6qqoTM/BPd678nSlNlshpSSJM3w3qP14EFvDPODA6rlap3loHSwXQo2PiE8uTf9MFUgqFYrmrahqiuapkFJiU4StNZ0/ZATMBThl8slbdNSVyusCVML3rswOSDA+p758oCua9FSMypGHJb5D0N8Q/6Bp+s7Dvb3woRDmpEkKc77QTjw/x97bxtr2XXf5z1rrf2+z/ude2c4MxySoqShnFFMsaJsqqbTULAcWEaVWobBIAoCITUQBKlQKLUiwHZhfzCQqLULpIBT1AGMQCrAxnJgpZFTy7XUSLZpd1RqVI8i3UqUyBF5ybkv532/r71WP6w9l0NaDqnIIpl6P8AFh+ees88+5+yDIddv/X8P1ljnBbBdsGAtVV2S5Vs8zyeOYnzPdwv+3aI5p89hKcuMsihRMiCOkk5efCvQeGFCwmKp64o82+J7IUk8cELgLqQ4pQs0XCZiXziWtQgMSZIynoxJh0PCMCQI3eL9LX9EWTqpsfMFbCg7QfJ2u0UI73QSpCpLoijBtoY4SQjDsAsf1Ok1iICicGFUmqZOmNw0tG1L0zTUdc1kMnXVVsKFE1VVUdfNbbVHAbarnCrKkrppkFJxfHyMad30hVLyVA59a1qirip29/aI4vg01Foul9RNzXgy4uzZPeI4RkmPQVe/laYD6rpmsVg4QXaWUZYFVVWxu7tLFMXEyeB78C1+hVy8l7uMhv3f5rEvv3gyotj/TT75hQLiKzz4l7/7goNLP/AQe8D+v3mMa7evbOsDPv07V/mu5zK6mqGiKF/mjt8Bwdt48K0xrD7Pb/3uwYvCls2XPslnnvnze6pXfC7FVX7nt2+8+P3aXOOxT+0DMQ++44q7bfdBHrobeOYzfOILt3scCm789u9w9SVv+N7bH+KShPnvf4JPH7w47Dn8vU/w+QXonfu4MgW4i7vObdCLL/C5J14SU2Rr1hUwnfLdxk89PT09Pa8dfbVRT09PT09PT09PT8/LUlUlUkhU6GGtW0hdLpb4QUCk3O7tWrs+fSklRZ4TRiG7u7vcuPE0FotuNJ7vs7e7x2KxAEDrlrKsqOuKNB2gdctqtSKMYrcjXQriOERJyXK16gTBFqlc133TNLRd575uGoTvkw6GVFWN6HbSSyVPRbbKU6eLy1VVo6REKR/PkyjPQ7fO12CtRQqB7p5PKUUYBICgKHJEawjDgEZrGt3g+x6maW8lA51HAKqm4nh+zO5slzQdsC2y0+qeW1JhrJtgKOuC45MTRsMRaZJSVJlb4LcvCJxFJzOwOHHzarMk8J0sOApjGq0xpnMl3Db50FrDNtsQdCFFGIQ0Tf1CxVJ3PgIwrWa9XeNHsXvdUYLWG6zp7A6dT8EYS4vpjvHCdmhhBZ7v43sBolucN9adR1NXeJ7vpNZ1jbEtnvTwPQ9rBWVZIaVCKRfcSNk5LCxsNxm+3/k3mpamCyJ8P6AqC/IsZ1lX7jUGPk3t5Nu+H7BebxiPhgjpqpnW6zWj0Ygsy0iShNV6xZmdM0jPQ0iJ8hRFkRME3USBUORFjpKyk4uHGGtZrlauEqosUUqxXm1AgDEZUjp/yHK5otUaKSXpYMB6tSKOE7TWlGWJ7/uAIAxcgCaAOIq+J9/jV4S8lx/7qQd58p9f5frHfolfvHgvl/diimevs39Tg5zx4KPv40rw5/Bcu4/w/h+5zq/87nUe+8e/yOfuvcyeN+fJ/RtswpiY4rsLE/bcjv2DP3yMX8svcddb38O73/LdnrTHlZ94H1e+8XGu/94/4ReeuMR998xonr3O/k3f1TVl3+1zfGfncv9TH+fa7/8qv/TF89x7eY84O+D61w7RBmbveJQfe9Ot+w956H3v5fr/9En2P/FRfu7zl7lywWf+5Fe5sXLnXtx+7uOH+Fs/+VV+5V/s85l/8gtcvfs+7p15L1wL3nne/V/cqiryuP/H3s3n9j/tZMv/9jJXLsSQHbL/5AGFibny44+8UAb15Y/zkY9dh91386F/8Mh/qB67p6enp+dVpJ9I6Onp6enp6enp6el5WcLQLc4CjDpXwXgyBmxXLVOQZVta09K2huOTYzabDYeHN0mTlOFg6Ep6rOXZZ58lTVOGw+FptZFSHtvtlizPSAcDBoOBq0o6rTJyVTfj8ZjJZIJSiqIoyIscrTVJkjAaj/F8n6Zp0Nr97O7tcf7CRYIwIIwi4jhBecqJjoWgbQ1xHBGEIVVVgXW7zG8FFuBCAeV5RFGMlJLhYEgcJwxHY3zPBwGDoas5opMhu4RAYExLlm04PLqJUG6S4nRiADqngcVgaa1huVywXC2JogjfD0/dCPDCFAOCU+lyVVUcHt0kL3KGoxFSvnDsW1MJwv0LeZFzeHRI09TEcYKnPF4oQuomGITEWEtRZhwePkdVlwwGI3ce7iU5MXUXZiBuhQjdj3W/c06K4WkFlFKuwiiKY4IgwHTeiaapaVtN3dSnEwpN07jFes9nkA6QUuB5kuEwddLjVjOdzbogSeN7PqY1zOdzbBdivFB5FdA0mrqrJKrrGs9TJEmK1u4zjuOYs2fPOelzo7lw8SJta1BKoXXrnqO79n0/QErlwoO6pq5rNpv16WfRNA1RGDMeTVjMFxzevIluGqqqIknSbprBI45jpJKEYcjOmV2Ucj4OrTVNV3n0WhJffh8f+gfv5+HLM3h+n2tPXGP/xOf8W9/NB37mw7zv8p+fMXfvXR/kw3/jIS4NGw72r3HtKwfEb3kvH/w7D7sF6tnwP3wX+85D/PUfvkQs5zz5xDUe//OqHYqv8P7/5u/xnreex9/c4PoT13iyPM/Df/tDvPcNAEOmr5YIIL7Co//wwzz6g5eYccj+E9e49rU58fkrvOenf5YP/8RlXvRp7T7ET//XP+3O/WSfa09c50Ce56G/8V915/5ihg98gJ/9mUd5CB+htwAAIABJREFU6O4Z+pnrt10L7+Gn/+EHeeTs7cd+hA/+zKM8dPded+xrXPvaIfHFh3jf3/8Q7/9LvWm5p6en5z9mhL3djNXT09PT09PT09PT87phPl+e/nk2m7ymz//P/ulH2WZbfD8gjSOMMYxGY46Oj/CDoFugdQPPde0WhdvW9cSHQYixBqU8mlt99p7P7u4eR0fH3TRCAghOTk6QSpHECQh7uvCqlEddu0kC3TSMJxPyPKcoC5LELTCLThYsuq7+oiiJohApFVVZ0LbOMyC6RfP1ak0YBi5QMC3GGOqqci4HKamqkiiKEcByMSdNB/hBQFNV2KZFSolpW5q2QWAxVuGHIzwvwFi30K88N1WhlEcSpyjPI8vWp9MFtpMjY61zERhLEETESYy1Ldts2wmWO7dCFyLcNkiAEILACxlPJiwWJ9R13YUg9rYFf7pJCUkcx8RpwnK+oNYvnkqwxmDa1gmWhSQMYybDCfOTmzRNTSd1ACDy4P1vXfLwpSMSz9WetK1iUwy58eb/ko//q8f52lPfYjyZkBUFWVYgpEQKQVG4P1th8bo6K2stfuBTFmU3ZeGBtQzHQ3Tj6qfKqiQMQuqmPl3gF0JgW0NZFuydPYeU3YvF/aNtNaPxCCGEm4SoKrTWGGPw/cAFSUHwQhAQRRR5jtGayXTGYjFntnOGqixQUlHXNVLJLgjLGaZDsmxLEIZYY5jOZqyWq9M6rkY3KKXYme10AvCS0XjMarkiCHzGkyl1XVFXFVGcYI1htVryMz//0T/37/R/VNz8NB/9Hz7D/IEP8I9+6vJrfTavmGsf+wiPffk87/6ZD/LIzmt9Nq9zvvxxPvJ75/nwBx/pK496enr+f82r8d/06/X6e3Lc2+knEnp6enp6enp6enp6Xhbd6lNnQRzHBIGPtS2T6ZS2bamqCindDusLFy4yGo2YTqcMB65OJo4ThJRkeUZrDBY4OjrEGLcr3AmX3SIsuHqkpm4Yjcanu+GrqkRKSZKmLJcLyrI89SwAnZzZ7+piAobDISCoqhLleSRp2gUStRPhBm6xWkhBXdeUpetRn0xneMpDN5qqKrv7hvi+z3azoShc2YoxhkY3p6/71nmKzuMghUBJBbigIi8yyjI/Ff+e0oUJrTEgLHVTst2uqevGVQPdvvfrtK1I3HaTpGoq5osjt7AuRTc9IEC60MTSDUnQkuVbVsslYVef86Ljnx5X0hpNUWTM54eEUdi5lO3pZIkQt8KK2x9vuxqrFmMsjW5YrBbUdUUQBpjWuIorzyNJEqRwMmbf91GehxSKOI4JQ+fX8Hwf20JTa9brDU1du8++KEBAnmVk2y11U+P7AU1dUZYldVVhjKGsKle/FUWn4cFg4LwPo+GIpq6dWLu7f5Ikp24FPwjYbNZIpViulmy3W/zAx/M9dOc2GKRDqqokjmMXwhjDarlECLoJg4bRaMQgTSmK/PQ6aeqGqnbBxY2nn2K5dILnsshZLhf8Rdnvt/nDX+Uj/+0v8et/9JJOfbPh2v/xOHPg8hvvfU3O7c/mSX7zF3+OX/zlT/HkSwZH9MGn+dxXgOm93NeHCP9+zIZrTzxJfOmNfYjQ09PT8x8JvSOhp6enp6enp6enp+dlSaIQCwTereoZTatbprMZeZaRpgOMMSwWC7ejX3QL6Z5HUZZU1YamcYvucSemtcbi+c5bsF6uTyW0YRDQtprpdOokyl1dURRFCOHEqXmeE0YxSZyQ5zl1UxMEIXmWo5QizzJ021LXFXGcdOGCwXZi3VZrPN87FTDXVYWxhtl0xnazptGaIAiI44TNZkMQuk585XkoqfA8H9PV57S6oe0EzFJKN4kgFH4U4vseRemCB2sNWjcI4e57q7pJKeedCMOIoixcrU3bAvXpgrK1TgVshMQTyu1+7+p0bkmem8bQtsaJr7uKICmE+/EUTV1j6ITKukG32k04cFsdEgKhlOvqtxKMky+3rcZa4aYXhERKUMI5E9xDb62oSpAe1rhwCYQLVoSkrmoXREUxja5pTYuU4gWpdeBjrCHwPTzl09QNIJ0Q2VqqumYyGVEUBVprIqUYTGds1isXSkhJXdfkRc7ObAdrLEmSYEzLZrMhSdzUi/MwSBC4oMJalosVylOEYch2u8XzPFpr3PUaBOhWI4TtPi+JZyTg3v8gCAh8H2MMeV5w5syIMAwpyvz0HFarFU1do3XbScOdc+OWHNxTisVizh13nO+qvtT3/Dv9emD4tndy+bcfY/+3/jG/+AXnYoCCg+v7HNYQ3/te3vPA623Z4l4efHDE1c99nl/7hS9z6U2XmIWg50/y1ac2aDnjoZ/40RdcAD3fnpOrfG71dj7wk5de6zPp6enp6XmFvN7+Ru7p6enp6enp6enpeR2ipES3muFwSNsaBPa0h36QpmR5TmsMaZq6ndu+D1JS5fnpTvAwctU0g8GAoiiI45iqdDvIx5MxTdNQFDlR5KqT5vM5k+52gLIsnDvBWqI4AWC73XY7vGuiKCIdDFzNTBCwPj7GYgkCfSpbrquK1rREUUzburCg0Q2DwZCmqQmjiKqqnQcAaLXGtC1l03TSXYkXKiI/xPc8skyh24ZsuyVKRqfTBlEUMRwO3U5zBAKJkBYh3UJ0q02nIQYpBEk6RHeiXdkt6t/qyb+1yG8teFIxGo2Jk5ij40OsvU1yLATGWqRxYYIQAt/zSZOUbZG9MG1grQs1jH3RdIQQAs9TSBGgm8aFDl2QoRsXOiBctZGQijDwiOOkm3O/tYPeTSsYLLrV1FWJF/qnQmHAiZB13R3OTU8IITC6ZTgconVDXVXUdYOUijgOiWWMH/jUTeOeX7gKLeekcNMoSiqapmYynrghCYGbLuhqt5xgu2K73ZIkKavlGs/33ERJFLmqKmO7SYMB6XjEYrFAt20n4HZeBCkEvu+mc5brNaOhEyp7ykPrlqOjI5QSvPnyfRwfHSKFIM8yVqsVg8EAgOefPyBNB92EgkJrzWDgqrMGgyFZ9qrZel9b4vv5wD8c8vl/9Sk+t7/PtWfczd70Eg/9+F/nkbef59VSDXwnXPqxD/Hhc5/isc9e4+DL17gB4MWcf+u7eeSv/TBXdvqllpdl9xE++Pdf65Po6enp6flO6P926+np6enp6enp6el5WawxDIcjtzvcaIIwwBpDFIWUZYm1FqkkEtlVxyjm88ULj7cW3/Mpq7JbKLdst27BPwwDWt12u+stxjjRrbUWa6GqKldTJISrphkOsBYWizltawnDFM/zUUqxWCyQUiGkYLozpSgKoiiiqV1PfZKmbme+adk9s0uWZSRpymJ+0v2uwVhLEIQ0de268+sKz/MBi5SCKIxQUlLVVSfsdZMIEoGnfNLBiChKqesKY1qUpwh8D4NbwJcIpO8hhEAKSZqmWOsWsKUQTltsLRJXkwSAAF8FTEYTxuMxN4+fB8DzPUxr3MSCFKfhg7WW0A8YDVxAcWt6wh1LvLiOCNyUhe8RhSGb9ca9HuFhhavrwZpucV7gex5REDAapVgW7lgvamoSWANKuckNLOR5xmA4om2dLDkIQsqyIBkM8FsfYy2iew/SNAHlfBdKBVRVTV1XIEApSRwn3fGG3X0kSZI4L4dxkxhJElDX1WlVURzHKCWpqpo0dc6FLMvYO7vX+Tw0vu+723b3KMqCLMsIgvC0nujk5NhNTigPsFR14yqWrO2mcFqm0ylaa9brJdvN5rRGq21bRqORm14IQuq6ctdSFLNYzAmCgCzLiOOEqqq64OUvCMN7efhvfpCHX+vz+I7wmD3wXv7eA+99rU+kp6enp6fnVaMPEnp6enp6enp6enp6XpY0HTh5chAwmYzRTYMQgmy7RTc1QeCTdR3wy+WcNE0ZDFK22wylpKsoCnyCOkAqtwNbSokANtsNGJjNZp1Y2f1+NBoDwnkMhEDgQoU4SSiKnDO7Z8gzFxRk2Za2bQnDyC1g+5KqLonCAGOMWySPYzabDRZLHMWnO8TDKOLkZI4Q6tR3oHWDVIo8z/CUYjrbYblcEPju/MuypMhzWt3iKUWaDknSMVE8Jo4HtNpQFDlg2d2dEkYB8/mKKAzxupDEGBgMhxhtWK6WLphJIudqMNaFBMZ2r8fj7ot3E/sRm+2Gqiix1hAEPlVZI4VEeZK6dqFCGieMkgFYS1as3OSCtX8qQLglffZ9j/Fkyna9wpgWqSTC3CosshgjTqXQ4/GYQRwjTI2ua3egLkgQQiCkOp10mO3skBUFSrnAQ3mSbJtRlRW7e3tIpfA9V2lkjKueqsoSzwtoW0NRFozGI5qmRipBGLqaoTByn3McxQgpXE2W8qhtxWKxoDWG8XhCGIYArLv6I+fF8KmqguFo6CqywpD1OidJYkxriLrphCAI2N3dY71ecXR0RNBVHPm+30mxA5I0Ic+2CCOodM3evW/g6PDIhT2HN524ugtxZrMdPM/n5s3nmE5nDIcjlssFYRh2Ew8W3/cRAoxp6enp6enp6el5PdEHCT09PT09PT09PT09L0uaDmjahuV8gacEsquRyfOc9WbNuTvOd5VHgiIv0LrljjvOs1ptMMYghKCuauI4pqlqfOVjbOsW7oMQKQTb7YYkSZFSUhTl6c7sJEmom5okTambbuEaQVU6WW1OzngydjU2GpQnKPKSVhu8MKIocnw/oChzWq1p25Ysz5BSkuU5UilGoyFN0xCGAXVduIohKYm6KppsswFrO7myQHpuwiAeJM43bAxCuN3qCiiqilbXnInh/Czh3F1v4EvX/h1333WewWDIeDKhKDK2q6yr62nwlObBBx/ka1//OhbDeDgmL3N2z+xireHc2Ts4fn5JNPB55uYz7I1nPPiO+/n9f/t/MZ2NuPKXv4/Pfvb3qaqWQZggBVjb8I4Hvo+D556jbBqybcHe3hlufOsAi/tcwjBiMprQti2m9hmlM6QXsLc35cxsytNPfYuqbnj6xrMIC0kYY40gzzNa4+TK2BbEC73+tW4oq5LtdovBIjtnQ1FkRGHIcDSkaSrawhBFsZNBt8a5H0xL2zaMRkPyouj8BjGt0VRV5WqHBimL+RypFG0XOrkQQzIcjWjb1rky8hzf9wgCFygkScrJ8TFRHFNVJWmaorUmTRN83yeKIo6PjphMpwRBSJZlZFlOHMdIKWnblrKqwFrSdMBqvSJNE+qqpCwKNp2bY7lcMp1OyZsGi8DzfdrWTT6AQOsWrV1VWJYVbgJEClpj8Hwf3dV59fT09PT09PS8XuiDhJ6enp6enp6enp6el2W1XJAXOXVVEUUBq/WKixfvJMtvMp3OODo6xPcCPD9gkA4QSrHZbAijAN9PmZ/MsdYyTaeUZclwOKQoC+csaDXpcMRzzz+HUl63i9ye7gw/OTlCep7bPR4E5LqlqRua2qI8Hyml8w50i8ebzZrhYNLV0mhWqyWj0RjPlwRhSOKlLJdLlCdOnQuDwYDlcsl8PicIfJQSJGlCGIScHB9jsCRp6p7D82iryol6gThJWM3nkBiSKEBrqMqckax59Icu8q0qRPgSP/SI45DxMGFnOkHMRuTjDXHss7sz5mR+wn2X7+HChV2eefaAuy7dSeBLbj5/yB3nL+L7AevFltqUeEKSRjGz6QRjagJPoquSN7zhLp765rP4ShFKy9mR5N5zQ1pd8qbL9yGUIttmfN99l1muF5zZnZDEI7JtQZ5tGAwCnn/umMPDFRcvnEeYljvPn+POe+7iN37jX9FqV83U1DVl6aqo3KhCV8HUyZqPlycuIKELZKKY7XZDmg4py4LUd8JruuqqwXBIXdduSkWJLnwC3dSnzow0TTHGUFcVT33zmyRpymQwoKlrjo+PiJOE3d1dbt68yZkzZ0jTtNvxH6B1Q55XrJZrEIIkSQnDiPn8BN/3yfOcyWTK0dERUkrKskApxXx+0gm0Db4fIKVks15z8c47aduWIAgA52nw/ICbNw+Jo5i9vXMURUZZVGzWGUopppMpRZFTFAVhGFAUOYvFnCQZ4nkKYyx+ELBerToxdE9PT09PT0/P64c+SOjp6enp6enp6enpeVmsMAyHA+zQ1fYkccJ2u+Hs3lmU8oiimCzLyXPnHMiLAkvLYDBgs9kQxzG+71MUBXXtapGqssT3fQZJ6kTJScp4NMLiRLq3RL9xHFOUJVJKBsMhRV7gJx66afDDkDwv3AJzXSKk7P7sZL2+7zNIByilAIExLbqx7ph5zrKrwQFX8dM0NbqpSdMBeZ6z3WyxnUC4LEuCIOg8BILBcEhZFFhrEJ6i1pqqrlmtcsq6psHjX//xs9z9lh3sckOeFQjhcXR4glIRnid56ptPc9fdl7h584hvPfMt3nz5zWy2G5782jc4d+YMhApdG7arAulVfOvGt7hw1znOnj3DZDLk+PCQNE4YDAcMRwO2+9/EVz4thm1RcjHe0BRb4jhlMV8yGAyoygqBII0iRKNZFUu2my3j8QAlFVEQYc2Cqqy5eXBAnCQcHx0jEQRBjNYN2zzDdn4Ih+h6kFwFklCKptWnwuOqKjtXgO5cBSVtq5FKnU4LpEmCkIKqKggCn6bWJGmMQBDFMaZtO3+G50IdrZ1I2fex1lKVJScnJwBUVY3nlSSJu+60bgjDCGsrhHB+C6XcNIbve3hKURQ5o9EIEKfej1thQV1XeJ6H53kMOzdDVdXOvSEV4/EUrCHLc0yWUVcVk+mY7TYnCULKoiBJEsqywPNcWFZVFaPRmLa1+H7A/OQErZ2X41SM3dPT09PT09PzOqEPEnp6enp6enp6enp6XpbBcNBJfWFVrLsamJiyKJHS7dwOfNf1XlWucsjzfAaDBCkly+WKonAVLrPZDCUlElitVgxHI7TWpy6Euq4YjyZss4wsc/3+t/rji6Kgqd0u9Ut33c3Nw5t4nsetBWzTtniejxACpdRp/7zbFR+w3ea0XW99GEVUZYlS0gUXxjBIB+hWo7U+FRhLoci2W4LQCZhnsx02t4l0pZQMByOKoma+XFJrQ4vBAN/aBDz3xP/rNuxbj9///ON4SnF29ya1rlhu1jzxpX+HacFawyc+8b9hjAWh+L+/8P/wlre8keVJwfPPfIPnj5/jZD5nsV4gLeSbDYuTOWVVcfDM85wcLTg8XDIYuLBlm2f88ULzlcOvcOb8WbabG4RBQFmXWGPQVc0b3nQP8/mG7WbDzpkxUZhwcjJnvliz3m5YzRdul/wmRwpF4PksV3OKsiCSXa3RSxBKOWeDUniBxO/CHU95ZNkGz3N1VatVTRgFTjoch2zWa4ajIa1psdYjjEKU59M2BqNbBsOULMvwfEWzqvE8jyzLGA5HKM8DaxFAGIRYa5zMOYlPQ6yyrABB07hrbX5yRJKkWE8xGA6JW0OeZ9x99z0cHx9jrSWOE5IkZmdnh+eeOyCKYoIuBNC6RUjJ8zefZzweMxqNWG/WKCRJHDObzQjDgLPn7uDk+JjFYuFk4EqxWq0ASJKEwcCFVkmaonXNZrthOpm+at/tV8L+J36RX/9CAfGDfODn38dl+fKPeS0ex9Fn+JVf/jSHb30//+hvXnmFD/pO0Myf+ARfiB/l3W+5/eY51/7lF4h/6t1c/h48a09PT09Pz+uBPkjo6enp6enp6enp6XlZiqIgjmKCIGB+MicMw273eIUQiuFgSBxHbqd23WBMSxKnVEWFpzyiMGI4GJDnBev1migMiOMIay1aa4IgJApDlJTMplPm8zlKCiYT191fN266IAh8tpsNQRCy2ayRUlJXJWEUIwBjDIHv4/mKyXTC/GR+6nOQ0q1G5nlG4AcUZQHAIB1SNxVCAsK6Sh3dUtcNylPopiGMY3zPQwBlVWKsochzkiRltVqxt3sOrU033dC5hy34Ei5euoPBaMjTTz1POkiQWNLRgHpZc8+9d3LzuSPqpqVtDHde2kN5HoeHc47mC6ov/TvuvueNHB4csN6uabEsVxuEEEghYLXGWlhvC5RUDNIBZVWQZRlt2+AFAUbBarOlqRuWmw3Wakxrscby9SefZr0tCH2JFwkOnr1JXlQ0dYPIwLSavCgpy5xBPKYoCgyaKI6IVYtSt10kQoB1UmxPKgaDIfUmd9VAxiCkJE1dlVQQhoxGE4w1CKBtnS/AtIYwCDHWYnTjAgLhHtsa47wZxgVDUkl8z0cqJ8hWSpHECXVdMxyOqOsKIVxNUpZtASdrbpoapZxMWUhJ04nDnWg7Yr1edZ4OF3zVdU2rNcPhiLIs2W4zwjAgDENWqxVRFAG4MC1wMm0/8Fmv1y5kOzlGKclms3aBiuf+NzyKYowxVFXZ1WlJtHavZTbb+d5/qV8p5jpXnyjcFE9xlT+89l4uP/AKlhJe7ce9Csw/+6t89HcOuPK3Hr39Vj7zqx/l0wdXeP9PvWan1tPT09PT8z3nleb6PT09PT09PT09PT1/gUmTlKIoyPOM0XjIYOBCgiiOiOKQMAjAWpSnnLx3PMEay2KxYLVeY6xGeYI7L12krms8zwckTaMJggBfKSbjCZ7nsV6taeqaosjRrWY222E4GHByfIQ1rm7m6OiQuq6QQjAajbCmxfd8JuMJum6YTias1ytMtzM9z3PW6xWt1gwGQ+gW4l3/fstoOCYMY7RuybYZWjdMpiOUdDvrA99HKYWxBmMMvud3vf5usfrWovGtOiasxRMt50Yes0TxxjfdxXA84Pz5c5w5s8PszJi3P/iX+cEfeIAf/is/wIP/yfczSEN+6Ice5K/96F/hnnvu4OKl87zxvnu4cOceo2nAaBpx553n0Lql0S21bqlqTd1oGt1igKZp2Gw2NFojrCUJ4aH/9B38Z3/1nXz/938fe3tj9vZ22NmZMhilZGWFtS1ndme896//GJOdIb4v8QPJYBBz6c6LxJHPAw/cTxR5CGHYOTPh3nsvcPHiHUhuJQnCuRKE6EIUQ7bdUpVOmt227emi/s6ZM4ClaWo8TxEEblEegbt+oogwCAnDCCyuTspaiiIHLKqrGPI9jyDoJhqiCCUlSZqilGK1XAJuKqUocjzPY7NZkyQJuqlPwwzP81BSURQFnqfI84zFYkHViaJvVWyFUXTqLYijCM/zybKsCwZ8BoMBu7t7xLELtBCC7XZLURQUhavEKsuCMAio65qqKpFSoLVG6watXZhRlhWDTvD9ekFfu8p1A5fe+RDngf0vfRH9Onzcq4E23+5MNPRu7J6enp6evwC8PmL9np6enp6enp6enp7XNcUtF4AQRFGI5ylk4hZXN5stUgknrJ1OOT5ZILsd3oN0gBGw2ayI44jtZs2dly7QVBVxHCOVoNUtWZ6RJAmmNUipqKua6c4OQgiOjw+pqtoJmoscIQRJkpAkCXnm/j0IAtfFX5akaUoQ+phWY4wmjNz0g9YG3/cBi5SSOEkAge97robH9yirguFoiJTS1eh4AVEcYY0LEJpGU5ZLojAiyzLSNAUhaBtD05QEfoKSCgtING+96FOmAYEXIZAoCcKTnJlNGAwjTNMiDWTZBmEFEklTNlw4d45GG0bjFN8XvPXKfRwfzTFIvvGNb2GsJR0MKMuSVmssFt22rLPO6SAtSgjeMPMY2pzd2V00ZcneOx4gKwqkcAv2BwfP8Y1vPIMUEonlvstv4oG3paxXK1arBePRhHvfeJELFy4Shx5e4DMcDcEann/qBn7pdvVD210pAiElyWBIGEXEqNOpk7Io8IPg9Jx933dhAdBq93gnPs6YTnew1lLXFUopbG1pdMNgMKQsS6IoJk5CJ2uuKzwvwA8Cijw/dRkoJU/Fxmmacv78eaw1jCcTpFSs1ysGgxArJUJIWt0SBiF5nhPHibsupGSz2SCAyXSK3wm28zzH9308z6Ou61MPSNPUBF5AXdVY41wcSZKwWCwxrcHzfZTnUZbl6TV9K1gry5KdnR0Xpq3Xr/p3/Nuz4fE/3Acucd8PPoTe/wwH+4/z+OpBHh6/nh7X09PT09PT872mDxJ6enp6enp6enp6el6Wc3fcwXK5IApDDg8PiaKQM2d2Wa9XTCYTV+vTtui2RSrFZr3C8xTj8RhjDWmakucFs1mMaTVxEjAcuGmA7SZjOp1QlAVSKQQK5fkUec5kNmOz3eB5yvX61w1CCu6++26eeeYZdKNpmoYkSYiHQ3Srmc/nlEXJbLZDa1p8L2A+nyMEhGGA1po4jlivVkRxTBRFeL7C1x6+fxYhBCfHcwaDIZv1upPyBhwdHqO6/v8sywAnhRZCoKSP8lQXtoCU0JiA3/2TFW948y5yvCaNB8RRjJIC3Wh86cTLi8Waum5pWsvR0YrID1ktNgwGKaaxNBi265wyK0hHYzylaNoWKRXT6YzF/AStNaZtuWUtEIDEYpqS9WLOXmtIowTlW8qyJgwDsC1trSm3OWoQc3y0JAoTkihGVzVh4GONIEgjrDXsnd2lbVuyLCOOEkzTMhiOEOKFQXcBCOm5aiJjWK+WjKdTTOMqn4wxpzVZAE3dkGVbRuMxEnm6y1/rBmOMq0WyEIQBTdN0wUDIcrlAeaKbcrDkWdYFGjAajWi767CuK4LAZ7PZnE4+OMGyj9YTmqZBKYm1hrqpqesa5Sl83ydNB86BoaQLarQG3KSBkzgH5HmOAJq6dvLwIMBqS11V+J5HLRVR5Cq8xpNJ99p09160ncw5pGka2rZFKUXbtqzXq1fpm/0yrK7xxWeAi2/lynAID1ziU8/c4PE/OODhHzv/+nnct6F46jM89r9+hv2FBi/m/Fse4T3/+cPcO3zJHfWca//6MT7zJwccZu6z8dI9zr/1ER798fuZeQCHfOaXf4VPH7mHXP/YR/gIcOW97+bwk5/m0N3Kxz/yEeAK7/9H7+eWoUGfXONTv/Fprt6Yow0QzLj0wLtvO3bHlz/ORz52nSt/48Ncvv5P+eSfbNDBjMvv+n42/+azHOy+mw/9g0fYe+npP/Hr/Ny/2Of8j/8sH/yhl764np6enp6ePz/JHN1uAAAgAElEQVT6IKGnp6enp6enp6en52XZbjdgLUVRMpvN8DzP1fhYwWa9JhkMaa3BNjWTyYiqKplOx05k3DT4NkAKied5tAKiMEQIhZISIQVe4CG1oshLrIE4iQmDgCLb4inlapN8HxuAbjXHR0coKWmsIYxC0jRls9ngdRLooihpW02e50RRRBgGGFOcVhEJLNOdMcaAbhvCyKco6q4Tv3Gd+55H26Z4yqOptasyqiqUcgvlYRCw2WxIBwPquiaOUjwVYq0AYzHSUiJ48unnOFqWzKY7PPX0QbfILDizM+XGjWco64ZKt0gp+Oz/+TjT6ZQwDNh+/Qa60WjTorV2C9aNpq5rEIKqLBkNhkzHM1abFbqpaTvhMEKirWH/SPBsccBTJ3/gZL5Nw2qzReuaMAo5Plmy2W7Ji4I/+PxV6rrm3Lk7kEJxfPQ8rda0bYNSHrrVWAx1rZ14uy74vnu32NS60lzhrhUhJFhQns9oPEE3GqU8Wq3dwn/bUlVlV23kEwTOjdE0miiMSNIEYwxlUTj/gKCrwsKJkwOfnZ0dmqbBWoijGBNayqJwMu44RimFEBZrBVXl5Nzb7Za2bfF9n7bVeF1g4Pse221GWZR4vk9ZFGAtQeAzPzkhjhO0dov+Ugqm02knBa/RTcN0NqPIMyxg2xZPKVotGAwH3KpXsta696CtsNa9R4PhkKgLNhaLhZvY2W4RQnxbifVrwcEfPM4BcOmB+xkCvP2dXP7XN9i/+jj7f+3PliC/2o/7Uzz/GX7tfz7gcHiJKw/MaJ69zv6ffIpf+8bXefSDH+D+W9MNxXU+/t9/nOsZeGcvc//lGKo5T+7f4MYfPcZHny/42b/7EENiLly5n8v7++wfFMzuvp9LM7hr5wJ7D1zmq1/Z56CYcemBS8y4i9mtw3/543z0Y9cp8BjefYV7Zx7Fs9fZ/6PH+OiXv8r7P/QoV+KXvAf/+z/j+ibm8gP3wrOHXHjTOxl+5bN88qkvcPXgEd7zojxF88Uv7QOXeegdfYjQ09PT0/O9pQ8Senp6enp6enp6enpeluFgwGq1oijKrjImZ7PRxHGC6HboZ3nmKmU8xWQyJR2kSGkxW7d73/c9gsBHa8lm4+5bFiWj0RBtNFVVIaVCehJrLY3WSCFo6po4irFY7rp0icPjI5aL5eku8SAI8H0PIQVlWSCFRNc1cZIShiGe8pBS4SnvVHZrrcFTkiwvUIGPwNUjWWMpixXD4YgwjNBNSxi6uhvPd5Jf07oJi2y7IU5isK7CJo4ixqMzLJYbTF0hhMW0hqKsqZtjhFBMJmMMioNnn+WZZ57DCmhti7Zud/02L8irhrNn95BBzHYzZ7tdu/cC53VwKgLnGCiLgtlsF8/3mc+PaOvKfWAWtBVk2lAsM07WT3N27w6SKOH4aEuWr2namtYYDJYCwWZTIITg6HjDHefuQLeCo8O5kzxbg7BuedtalxmEUpPlWyymu0qEe2IsUkkEljAMnbOhqbHWVRfVTcN0OiPPM/IiP62lSgcpSkrA+RB83yeMIrR2UydhFJ0u4IdBiO8HWKCqKqbTKRulqJumkyaHJIkLlHw/ACzWGEajEQIoypLhcMj85IQwHLvFfmC9XnHP3W9AKoWUbvqgqmtGoxFZlhGGEVIKhJAUeU5RFgw6kXdZFFy4cJGqKNB1TRAEIAS1bty1haCudVfNldK2Bmshy7LumIL1eslkMuXChYuv5tf7z+BJHr86B3mZd769W6QOrvC2y7D/lX+fBPnVfty34egA3vVBfuFHzp8uehz+3j/hV353n8d+6xpX/vb9eMDBZ3+b6xmc/5EP8cF33bbX39zgU//dr/L5p65y9eQhHtkZcvlHH2Xq/Qr7BwXnH36UR/9Sd983T/F+eZ+D4jw//FOPnk4iUFzlsf/lOkV8iff83b/Hw2dfOPz8C7/O//iJa/zmv7zCfX/zyosWZuarXd738x/gwdsCBv2Oy3zyqX2+fO2A95y/LUnYXOXqPvCWt/G24JW9NT09PT09Pf+h9LLlnp6enp6enp6enp6XZblaAiCE6OpglOt1Lwr3UxVEUcxoNMZat8tfNzXZNiPP3WJxFEU0TUNV1RRFyWq5Issyt0vc85hMJsRJTBxHeL7vJhFwVTVhFBJFIYeHz2PbluFwQBxHTKdjhoPULWyHHsPhAKkUcZwQd5MISZLgewqlFHfccQ5rW6w1hEFA22p85ZHnGbrRWGswuqXIczcFIWXXu6/QTYNutJM8S0maDgj8oOv5bwkCjyQJURLnVGhb92Na6qZiuTwhy3OkEPiBjzaWRrfo1mK7mpu2NeRFzmq1QgjJaOQWVI01GGvc1Ee3X71tWzabLXXdMEiGzKY7yNtqhhBu0d9YMG3DdrNysuOdGWEU0dpbNUgCKwQGi7aGsqlYbzd4XsCZvT2iMEXgKoSstQh7S6zsFv3BgujSBSlAuRoqay1N07gpAt/HWnta3+MkxM5F0NQ1dVPjeR6LxRzf90jThMl0QlkUVFXdVR21KM9zky2+z3a7Pa1Bmp+c0HbTAE6G7bwXSRITBD6B7zOdzVitVqzW61MBdBhFVFXVTTDAZDLh+eefY7NZuwqnOCFNE+q6omk0i8WcNB24azYIGA6HKOWRJAnT8cSFCFoznkywWIqqYrVaoltNnmXoLuhYr9ddrVNGWRZUVcVqtWI6nbHZbFgsFq/ad/vPZP8a1wvg8tu4crpI7XH/Dz5IDOz/4eNsXg+P+3ZMH+YnbwsRAPbe9ZM8PAW+8kW+WAPMefq5Bs+7wiN/9SWFQfISd10E0JzmZN8hmy9eZd/A+Xf9rReFCACzt7+Hh3eh+JOr3bncxpuu8LaXTCl4V97GZQnzL32RG7c/x5eucoOYB3/w/n6XaE9PT0/P95z+75qenp6enp6enp6enpcl8APa1qCbBiE8ttuS6XQHrKWuawbpkM02pyhLfM8nSRLqpjqtf6mqiiRJOD4+YvfMOYSF7WbNeDKmrmuyvHE1NralajRRlBKHAaZt2WzWSCWQUrFcLCiKgjvO3cFqtWBv7yxt6/wASZJQ1w1pmiKwrFYrlBIMBwMaoKnXKOGmKzabDVq3DJIUTylEFFOUhXt9UhCGIdvthiiKqOuKIq8w1iKlk0j7foBVLSAIo5imKVGeIAgkra5dDZCx6KZx4QSGVjdIpRgNR2BbmrahbZ3EGegEAwKjW5bzBWk6gM4TYFqD7CpyrLUI4XqEqqpku14zmcwI/NDV4hgQuPtJ4dIEIyArcgZ1ySgdEkcxm2yDsaZrJBJY0c0UWMN2s2E4GJxOBZRVjhGdUFm42h03c3DrxMEKsDJABGPqyqCUR93klEVBGMUY02KMwRpDFIVUVYmnvK7+qKFpanzfI88ywig69U00TcNgMOiqkFy41HRTAG3rJlKy7ZYgDEnSlCgK8QOfOI7J84yqKqmqkgsXLrLZbNyUiufRtq0LtsoKhHAC5ziiLEsOD28ymUyYTmdYa0nTAc899yxhGHJ0dBOQJEnCeDxmuVwyGo7Zm53h2We/xXqzJs9zkiRF+T5CKm4e3uT8HecZjcd4npuMSZK0E1HXWNt2lVwFAHVVfa+/0i+D5tofXaUArrz9JYvUb7rClfgqV595nM8dPPynqnZe3cf9GdzzRv703c7zxnvg84sb3HgaHnzTjIf+zs/yEIAu2GQLDr9xyMGzX+Xr39jnyWdewfP8e3j6m27Jv7z+KR47+NO/n2uAW+fywu2zi3f96YWa4H7e+cAn2f/CF7j6tfdw6U0Ah1z94wOIH+T+y9/dufb09PT09LwS+iChp6enp6enp6enp+dlufn8MXtnzzj5rJQIod0C6miI53vURU2ZlyhPIaVESoHWLXVdE4URgR+w3WwJgoDNeoHvhSjluTojJRgOUhrdntbSqK5WxpOS6WTKZrtGSsHOmTMI6xbzZ5MpRrcICdJT1FWNbS1aV0RRRBSGKCXI8y1RmDKeTGiaGoEgCiPiOEZrNzEgJEiV8PzB84yGI+qmJo6Tzg2Q0OiGptbOVSAEUoLoxLhNU7pKJSxhIBkNI6R0Ml0hfFf9Y8EYy3J5zHPPPYvvefhBQGsMWZahdXsaEAjhKow2+caJlesarTWe79HUTVdt5O4jEOR5znKz6KTC61PR8K2pgFvHFELQ6IbZZEpVVxRF5sIRIUC4up7WaLBQkCOkJUkSLIZGNyg0g1AReiCVq3lChZRihJQK4fngTcj9XW7eXFMUJQKB7/soJV29lOcRRRF5nhOGkZNhBz5C2C4UCJFKgXUiZiElWIu1LnwwxnQBg3NriG4qIgwjdKudSNnzaJqGk5MTRqNRt1ifON+EbjhzZhcp3WRN0zTESYy1zrEQBD5hGBJFEUmSMp+fMBqNEULg+0En0pZsNhsEoLWbzinLgie/+XV8L0BKj8FwhLUQRqHzHiDxlE9ZlozH4/+PvXcPuTy/7/te39vves55Zp7ZHYmRu3YqzCpkjRWjLZETGapglWZDksZOUalNCSXQmNQFhSQLDiR/pJCaWlA3mNL8kUBkKhLbuCVK2zVWQIqt2BLSupp1tHWVSFtpLM3uzszznHN+1++lf3y+z9ld3UZB0q6cfl8w0up5zuV3OYfVfC7vFyFEHtx/gKscxoDJ2zfWOpRStF33Rn7dYfkUn/pX8o9XYuGv5h6f+M3neerHH3/jnvd1uHnj+tf8+fUbN4G7jFdbAOMLfPiD/4gPP7/Hv+pxtr/F+fWRu9+GxZB7n3uWe5/7er8dXzmWq/f+OrkRj//gE7Sf+Di3f+d5fuz7H4c7H+cTL8L5j7yTt37rh1koFAqFwkMpjYRCoVAoFAqFQqHwUDa7LcuyoLQipSiT3MtKVTtiiCg0fvVAou0aQpDC+Ha7wxmbGwiXEh9z/TqHg8TG3Lt/j+1uyziOUmy1lr7f8OUvfVkkyU3Nuq70XS/ROsA0TtRVxc2bNzkOI0oriRtSmmma8D4xTaNE27QN2iqaRoS5yzxRVY6u7UApQB5vtSb5hNJKopFsx7quBO9xzsp0+3GQ5oa1aK1IKdG2HfvLC+qqpm5qdrsO5a9LhI1T1LXDWimgh6j4xCf/FS+9eBeFwtYVddOAiizLmLcTgmwbKLjc3ydlKYFzjqZtmaeZZZkBhSwbyE5A+kJCa00K6TSNfxxGQvBZ9KtJSNNAK0VVNxJBta5YK38trJuWdZkIUbYpXr5/l6Zp6dqGy+Oeswr+0I2Os07TdhDrHWpjuWcSS7PDtDt0e86LU83zn7tNTFJ0N8YyDgNV5bDOsTs743g8Yo1lnieC91S1w1mHD55pHLFbJ2JrazFWI70O2QSZ5xm/rjgnn71hHLhx45EcV+RZFiVNmiBNn77fsN9fsj9c0vcbpml8VbOgO91PaXgYYgi0Xcc4Dpyf3xCXxzSSUiLGeHIcVFXFI4/c4O7du4zjIL8PEVdVpxgnhcIaw2az5eWXX+L69esnr8cyz7jKSgNNaaZp5nv+vbcwTSM3bjzyBn3Thf1vf4zngfbW4zz+5varHzDf5fnn7jB+8jd59s88zturN+Z5X4+7L98Hbn71z790F9hyfQtwlw///V/gmTtw/kfew3/4x97G2958nbZvsRpu/+LTfOBbbiRseddP/QxPPfatvg7w/e/kHdc/zkefu83zf/5xts8+xz1u8p4nv5kVjUKhUCgUvnVKI6FQKBQKhUKhUCg8lHVdUcpQ1w3ruuB9xFlH5SpsV9G1HcfPv4AyhpdefhnIU9YJFmaWeeL8+nVWvzLPE2e7LcsaqWuZ8u77DVoZ9vtLDvt9zru3GG04XF5QNw0xJJYQJIrfKGKKQGIYJkLw7HY71mXBOUfbNgBSvLaGcZxJCUIMGGOJMXBxeUnXScPAOoMm8pZbt5iWhWWeqeuK2lWs3hNioqoc166dcdjvWeYZbQzGaKq65vr160zjxL/53Oe49aY3UXcOpcAYDURWP+N9pKoNu2tbnHOEEFn8itIJbWSDYVlGXFVhtEZbEQvP08QwJQ5HA0phtMl3JRGjNBBijBJBNA4sXjMtA6BOEUt1I5VXbSyXh0vMcKCqakKQuCLnHD4sVJUcd4qBpBXjPOAchLgyBbh7ODB7y3WtuflIhb5xgxermvtYVOw43k/8+kc/we8/mEhKMy8Du+3VVsCKQjFNE0bLNof3HmMM8zQzM2Gy38IYy5IWlnmhbRtpGsTEssxM00jX9UzTdDr2GOMp4qqqNyzLjFL65ELw3tO/6jmHwwFjTI5HClSViJnruj5tA/T9hqqqUEozDAdpimhL1/dcXl4yTSMvvfSyNMx2ZwzDkWWa8TEyZxdCq1pI0NQ166LZX+6l8aY05zckNqmqnDTSlByLXz1f/tKXXo+v9dfhDh/5jTvAOe/48b/4daKE9nz07/23fOgLz/OR397z9j+xfQOe9w34f7/IXR7/ilbCC3z+BUDf4i1vBl68zbN3gO95ir/8k+/ita94l7vf4i24+eab8Om7PHf7Dk899pUndYcP/Xc/z8f84zz1U3+Rd37tBYqv4BZ/9AfO+ehHbnP7956k+Z178D1P8eSj39pxFgqFQqHwzVJky4VCoVAoFAqFQuGhxBRYlpXVB6yVietxHEnAdrcjIUXzeZ7R2rCuK8u8cHl5yf1793CuYhxGLi8uCD7kKfiIq2RbARQpJipXsywrIYScbT+KtHYYWP2KUlI4bpqGG4/cQCnF/vJSjjEEznZnbLoeZw3WaM7OdizLmjcVPN6L1HicJ/rNhrpppECsLM46znY7tJLImmWZsNawzBMpRdpWcvv7TY9zjr7vWfNk/DhOWGe5PAx8+nf/b569/Xt8/FO/y2/8y2f5zd/6NB/77d/lU7/zewzTQts3GKuxTqNUIkWPUomYwikSaRwHtNYsy8TqZ9Z1JhEIYcFYCEFy9VEBYxXGiC/AVhZlFEorUDFfYwOKU7yRTNYHol+JYSXFgPcLIayyrdG1aKNle4FI8AvOakYf+X8u4dMve37zcxf8049+ig995Fk++juf47d+9w7Pff4eH/6t5/i9L16wBmnabLc7ur5nu9vRth1kd8W6rnjvT58VlHol3ulV2x5Kia9iXVdSgmkcc1OL/LsKa61sZiQw1p7u89VWSgzhJDlWWjMcjyzLTFVVpyYDKHls9jdIAwGOxyOXlw/Y7/cYY6iqinmaMcailOZLv3+HEAIXlxc0bYsyBp0fB3A8HoDE4SCxXsZalmXF+5X9fs9hv6fve6yVbYh7L9/jcDjywuc//0Z8zYU7n+K5+8D1P8If/brD7lve+cMSMXTnNz7CnTfied+IF5/hl/7FvVf9wHPn136Vj15A+44fee1Gw/4e918jVPbc+bUP8syLX/2yVsss5jq+JggJHMD6mpiim+94J49puPcvfoln7rz68XD313+Jj94Hf+NtPPFNNRGEW3/8ndxi5PY//6c8fwGP//A7eUhLpVAoFAqFbxtlI6FQKBQKhUKhUCg8lMWv9P2Wl+8/oK4rzq5dJ/qVaZy4fHDBfn/AuYplXWnqlto1rMvCOA7UVY1SEEKga3tijLz44j2MMdSuZp0XxmGgqSXSRCvxHzhn0EZTVRXDMDFOI9euXSOESAiR37/zJZZloe3EqbDMC8fjkRgDTVvjnGUcRqZpwVopGoeY8POCtY6Yo2dijCit8fPKxcUFJDjbnQEQYqSqpbAeo0QPee9pu46maSRmx79SJIwJ6q5jnmfiumLz1L+rLMuyEJaZhGZZ1yxGjjn+x5BiQmkjGfltx+EgQmhrq9ygkebLuga0keK5tU7kvVqkza5yEisVxTmgjcJagw/xNP3ftC1WG4zSss2QEsaYLAFOzNNI3TT4ENDakFA0bY0PRrYhlIiVg+r50gPPYb1P186YL+25OBzBKDa7HfdevsdwPNLlhoBSCuucXGu/ymZBv8FogzEWEoSQRH5cg6sqrDUMw0BKsCwj2+2Oqg7M85wbODLJfxU51Pcb1mXOcUlSLZ6mCRTsczH/6ljglfNeFvFqjOOYt0XknjrnWBZPjJF5lmaUbIEo2RrRIsCeppmm7RjzxsONRx7hwf378jil6PsO6wzGyr12zjEMA8EHXnzxJcZxxFrLcBxpu5az6+ev35f7K3j+Nz/BPeDWH/+RryEsfgX79id54pee5/b9T/Cx33uKJ37n9X3ej33/N3hw3/LiP/1Z/ubHH+eJtzjuffYzvHDhYft2fuw/zkaBR5/g7bee4Zk7H+MX/vZnefyJW7SM3Ln9PHeXlvMbLfdevsudu0Ce+j9/803gDs//77/AB/71Td76w+/lnd9zLhsOd57nn/3PH+CzN9/Kj/yn7+TW2Tv5yR//DO//x8/z4Z//23z8+97GW88t4xdv8/yXPdhbvOc/+bdsBJy9nSe/70P8r597gVE/zrufKCWdQqFQKLx+lI2EQqFQKBQKhUKh8FA2m23eJHAy/Z1z9o+HkWVZOL9xXQqyucDbtR3WOpqmpaoqLi8eAFL4XpaVYTgCnAq7V68bYiR4T9d1uEoK6EpLkV0rw+Eg2fqXF5eMg2Tdd22btwUCTVMzTSO73Q6lNfOyZKnzwsXFBX6VqB+/rqQUWZaZruskqz8EvA8Su+MD8zSz3W7Z7XYs8wxcyXB1jtIJ8v5dz7ouzPNMXdfAleBYkxI0TUvdNAx5mp4kDQkAVzlikliipmtP2f3zPOXYm+okoLZWXA3iPJDJ+xBklFpr+atdDCE3BCJVVdHk51XOUTnHuq7UlUzca2OoaokNunbtGk3ezrCuou07UopordDZr6AUaKM5u3ZNHAsYJh+5nFYuhpnj6NG2pm078TUkkT0fDgeOhyMxppM7Q2uDUpq2banqmrqqCSGSSBhrGMcBUpJoIh/wfmVdF7pO7nXT1FkkrbP02Ev8VYx0/Ya26zHGyj1qGjabLXVd45xju9tRXzkivOdwOJx8CVqLp8MYc5IxX/3s8uICgC7fp6quePTmTZFIO8d+v6duaqq65v79+3m7oRXheH79ZV1yJJbBWZdl3bIx89JLL2GMfPauXfu3GFP/dhJv8/FPjsBjPPmDDylx6yd48odaYOT2s8+8vs/7nee/8WP//T/L+/7Se3jr9Fme/eRtXhh3PPbH3stf/xvv5YmTguEm7/5LP8VTP3CLNt7l+U8+y7P/1wvYx9/DT/y1n+Gv/ylpONz5/Kv2Hx5/Dz/2A+fY8Q63P/ksn3phLz/+0R/jieuW8Qu3efaTn+Lz8mO2P/QX+Zm/9l7e+X3n+C/c5tlPPsvzLztu/cBT/KW/8dO8+03f+DS+mi1P/geymdH+0A8/1BVRKBQKhcK3E5Wu7FyFQqFQKBQKhULhu4p79x6c/vn8/Nob+v4f+t/+IYf9gXUNbPuOZVkBqOsapRTTNOJcJYVXJQV8pTRV5TAamqbicBhAaXxuFMgk9yjT8cYQQkQbAylJsdxqpmlEa8um33D//j20MWy34kKQqfLIvMw4Z0kREhIno5TK2fc1KHnt/f4yF4BrpnGkqaVIf+36Ofv9PmfkV8QY2e/3eL/SbTbM08z9+/fp+p5lWSTj39hc2O5zA2IlRim2L8tCXTXs9wcAiRlCcvkhT7mvHq10fr0RV9X41fPgwX3qpuV4OOTrV3E47NHanPwFMUZAnzYMtIHKSRSPuCAS6+ppGkdViePBKJlclg2DLF1GnWJ45mmibqSYL9FRci/neaZu5H3ltQJnZ2dMw0BYPYFI1/UYpTFaU7ctq/dYZzkcDmilciNnytdC46xlGAaUlo2IppYGgDaa4D3NlRMhF9mrqiFET9u2xBBwlWOeJqq65fLikhgjm82GaZ7o+w3BeyCyOzsjBLlGm82Gw35PzE6CeV6o6xqtRdB9tjtjXmbGcTxFHgUfMNawLgt1I26Qum5p2iY3lhSbzYY7d+6w2Ww4Ho/0fc9LL72YPQ9GIpSMRQHn5+eM40gMka7v8N5z8eCCRx59hJdeeinHMynaruX8/Jz/+q/9rdfhW174g4b/5D/gb/7jF3jyv/xb33gro1AoFArfNbwe/5/+Mkd9ficpGwmFQqFQKBQKhULhoTRNQ9d3dG2L9555WZiXlRgjKYHRjouLB1hrCcEzTVP+XeL69XNkiUHz5S/fZdNvJQ5IwzgMhODZ7w8sy4w1IhK+yqt3tqJyDm0Ut97yFrquxa9rLqYnHlw8YF2X0/T+NI6nafIYI8u6SryM0Ww2G0yeBrfWcnZ2jc1miwbW1bMsM3XdnGJvpMg8chyONK3E3kjmvoh919Wzrq9sV0jxO3Lr1luIKeGcwzrLMi8Mw0DdNCzLzDAMNLVEHklhu8avq0QRaY0xmq7rsdaQUsyT9BZrJVbIZMmztU7ew1istVjrRBSsFM7ZVzYAYsQaQ13VtG1D5VyOOGrENaBBa0WMAWM0xsg/o0Dr7CJoGqq8bTGNIyhFu+mpqwaFIpFoNxtQinEa8aunaRqMken+tuvoN1tSjCcnwmazgZTwwbOuC23T0Pc9+qrB0LacXbvG8Xikqpr8GexRSuGqKnsPFP2mFwcEEINn9XK9l2UhxsiDBw+4uLjAWktd1cgjZZvBuRx/NE+nYwVOTYZ1XQl5s2C73QGJL//+HZqmkd+FQFVJ82maJo7Hg8RmRYmSmqeJeZlBSfRW329w+fHSPDE8ePBANnBcfv8spi4Uvgr/Ah/6tefh+jt4Z2kiFAqFQuF1pgTqFQqFQqFQKBQKhYfy0kv3pDAbAiEkvPds+g3DONFUFX3fc3n5gGma6No2T5sbtFbM88w0iYV0t9tydnbG/fsvk0KkbVuMdVzrekgQU6Lre4zRHA57XOXwITBNM9Y6QJFSRGmFq1wu+ivmaeZ4HDFag0qc37jBPE0kJD5nWRacc+wPB1KIxBB48OABrqo4HAdSLvxfORaslRig41GilLquY12l0H/lbaiqmhA8dV0TY0DlIv84jiikGJtakSUAACAASURBVL3P56C8xBMtuVFhjME6+etYXdccj0eOR5nSPx72WOuoa4fsj4uAWKEkMihGlDI0jQWlIAWC96SUsvRaYZQ0S5yzOOdIWSZbNzXTlEi5EdO0LrsLNJvtBqU0q19Y1yVHHcnzjBE/Qtu2BO/RxlI3rTRskkiux3HEe0/lHMNwZLPdgoUYxEFxFRO0rmtuhlg2my3jNGKslXu9roAi+IhzmnEYiUniroZhRCmo6wpjDPePD7DOst1suLiUbZOrbYumaU5+BaUUzonoeF29bD3kyKFxGKgb2arRWuUGgWwxuMqRloQ2mnv3X+bNb3ozCjDaiMchRQ77PSH4LI5W7Pf70zaCXDfLdrNFoRmGAWMsFw8ecP38ukRWVRXWOaZxpHI1qtJYJw6FQuGKux/5Bf7+b9zHH/eMvuXt/8V/9A19EoVCoVAofCcoGwmFQqFQKBQKhULhoVxe7DkeRoZh4t69e6SUGMaBZV4IMUqWfQikFPFBCttd26KVxmgprruq4k1vehPOOZH8vkoAXFcy8b7b7ajrGmM0dV2x+vVUeD8ejjINj0zQK63oNxumaUJpTds21E2dp7sddd1grcTYpJiynyBlce7Msq7s93umeUJrRVVVjOOA94FxHNHGoJWIgVN+3rqubLdbNpsNzjmqSt7P+4WmrambmuPxQIIcMbSetiOqqqLrRDy8LgvOWpqmoanl3K+Ove83WGdpmvbUDLDWSvPCiUui6zqMsaQYpWjuLKuXyX6Fkq0E6/L2hSERqesKa6S5A+TYoAqIGGtQWhGjZ5lnlFI0bUu/2WQ3gxx3XdV4L1sOV56Htu2ylHgmxkCMEetcvgc11tnsAljY7Xa0bZuPQ1wTdVWx2WxFchwDWmuJn5rkHjnrSCS8DyzLksXL4rggJUIMPHhwX5pLuQAvjQR5X62lqbLb7fDek4DNZiOyaufY7c4wxjBNE85VtG1zutcmfwZIcHlxcfJ3+CxjHseBeZ6YppEYI33fi4RZvXIs4zgxz9OpERby5z4lcWTcesstttutNMuck8ij7GMoFADOz3aMF3tGtjz+Z/4y7/3DZSa0UCgUCq8/5d8+hUKhUCgUCoVC4aEMw0hVOUKIuahdM08jAU/TSDSP0Uay8pUmaCORRZeXLPPEtWvXGceBvu85HPYsywIJ1sWjt5rVr6QY0UqRiBJh5C1nZw3DMGCtZVqnPPmtMVazzBPWaLbb7cmJYIwRyfI4obRk8w/DIBn604RR+iR13my2XOwvxSGgtRTK6/rkeeja9iT8Xdf1VHyeJsnRn+cJ7wN911HVDSE3IJqmJYbIunopvAeZgve5MN3meChrXZ7uV9gcueS9lw2CRbY+ZAK/xodADIG+30hsknX4daSpZPJ+nie00dRVmyf4Q96UkPilGDwxBQ5HacSgEq6S9wNEZpyjgCTmKDIcj7Rti3N5UyDHB+3OzlDAMk80WXy85HPrug4UJzn1PE+yiZGbDIlEVVfSDJhnvF+pKmkcKaUgJVSOd1JAVdWn51euYl6mLHGObLfbLG6WhsSyLHi/siwLm+1WGkw5pgpgnmZSiozDQNvUWGtQSrYIYm6MLMvMdrPl4A+s6ypxSm2XNyUghIBSirZuRJysNSo3xcS5YdgfDnjvJc6qbqidy04PGAYRO3vvWVe5F//6s5+VLYd5Yqd2WT5e/qpeeAX7gz/B3/nBN/ooCoVCofD/d8pGQqFQKBQKhUKhUHgoMQaJ/7GGpmmARIziJWjqmtWveeraviofXibb52UhJZH4xpi4uLhgnmeMtTx681FijIzjkL0IAUj47CxY14UYQ/YHKKx1+ODZbDas60pKV8JnLZPeq2c4HpnnJTcAJKJnHAbqqsqNggUfPPM603Ui8JVoI/l9Xdd0fceyLKdJ/HVd6doOBdw4v4HRBmctyzzhQ0ChmaaZGCNt25AQ8bKxIjO+alAsy0LTtLRNS9s0bLabU5HZWcnIjymCkmK+cxXOOVRKWCuC502/IcaAsxZtpIht83ZDXTdYI3FG1urTdLzOUTtyDcWxoLWSOKSU8jUkb0BUWX4dWL3PxXOyC0COo99schNBzjUE2USo65pr165hnUWRTudujUVrxTgc83s4jDX5MxElwijGHD8kWxXTNOHXlf3lZT53cSLI8eXIpiSfpybHSznnQEFVyeuGEHBOnATzsuSNkl2OsJLj3e8vToLuZZ4lvkpp+q6T5lbedLjaBrHWkkhsN1u6tsVoTVNXbLfb0zaNNDDg0UcfwRiJc5om8WNorU4OEa01fpVopPMb54zDwPF4ZBiGN+y7XigUCoVCofC1KGMOhUKhUCgUCoVC4aFobRmOA0YrbCWCWqUUF5cXNE3Nusw4WzEvK9ZaHlxestvuWL0HkvgFjOHy8pIHFxcS7Q+yleAlOz/4eNo2aJvIMnv8Kln+0yrT5UprVEwcj0ecrQDFNEpRdl1WjNEy8Y5inhfquubi4gJnHZu+Z14XmraRLYGw0jY9qe9YlvUUT2PtK9Jd8StIbNM4DszTxG67o207SBFrDV2/Yb/fA0gR3Vrq2jOEEe9lql1VFUrBNE54v2C0JkZP2/Us+TilsH3GNE1Ya1iWFaVgXRaatjvFBmmt0c6IfyBFEhGtjYiTlbgU6rqShoQGFVWWKJtTIfxqs2NdV5xzrOuC1oYqOymqqjo5MYwxGGuJMTCMUuBuGmm4SESPeCjmaWIYR6ZZXAnW2NMxN400KmIMEr2EQiuFrWqGUTwG87zQdZvTFonIn+W953liGmf6TZsdEZCS/DHGsDs7k4YH0igJwVNVsvkgfouVZZklTqquiUk2GADqumGaRLQ9zyMXlxcogJhoqpoUZFMm+oBGGjzzNKGSNF6aqpJmWd5q2G53GKUZxpEYJP7JWk2I4tOQ5oZjmsaTXPoq0uqLX/xCvk/x9fpqFwqFQqFQKHxTlEZCoVAoFAqFQqFQeCgpwrp6jvNEv+mJeVp9XVcuLi6JMdDUNZeXexJIFE+M4kZwjmmeScC6iC8AJC4pxoRzlqapCT7w0ksv0/UdCs3l5Z66bjBG4yrHOI5Y63BVxcXFJVVdUTmZkh/HiSspsQTZyBS+MZZxnKjOKkIMeB9kS6B2dE2LIrHbbvj9L92lcpXEHoV4isuZ5xljDJvtlhfv3sU5x+Gw5/z8nLZtpRj/qqL81eR80zS5+WCx1tA0LeM4UNUV67rQtm2+BkeM1VSuhsvLPPUuBfSr6fthOJKiIoSVmCLOOrTShKscf20hiXfZryvOGtq2Y11nYkSigrTIhJWSLQQA733eNLGnJgNIcVzl/44xSZRP2zIOQ24ORKZpomnqU2PDGI3JBXytZVvA+5Xr5+csizSKtNag5HMUQiCEwG63w8xGPBQxoJRsMZBWQog4J/JoaZRMOOsYp4kQwmmzAUBrLdFV1mCDRWuNtRUpyqaJUtIo2m238ulQinEYSDGyzV4O2WioJO4pJdZ5xtkNSkHbSKNEhNZJmj3aoICmlggsowzjOqK1pelkC+Nw3GONoark9VESj+SDJ8Uk19S5vKkS0EpjreV4PLxeX+1CoVAoFAqFb4rSSCgUCoVCoVAoFAoPxThDHBKuqkggUTne46oKHyPrIpPpPga8X3FVxWEY8CHQtt1JtrysKz7IloHK/2mBcRzxq0cZzTwvWcJsORwkUx6liCRW7/EhkFBM04zRlmmesudAYaxjnj3Lukpcj9a4qpJ4Iu+Z14lKyaT66gNh8ux29rTtUFuHtZb95R5jDeM0QkpYY6nrmmEYcoNgJEE+H0/TiKD38vKS7XYLSaKA2rbN0UyBvu/FPTCovD0gzYe6rghxZbvbEkOkcpVk/c8TXRYZ+zXQb3Ys8yLbHVpTVQ6TGydNLRFDh8tLAJwzeK/yVH4UQXICpVWOe2qZpomu61mWOcuRr6KLNMZYur5nOB6xzhG8uAH6viPGKPLqxctGyboSsny4rkUYHYJnHAZxCIj7GVdVxBjwPp6uyThN0mQwhmmeCTHmaf2ZRMJYQ1M3aKNRSnwEyzSdoqNCkFigpmnRSrEsC32/oaokSmpeZrp+g3OW41EaQ01dY4zEKjVtexIra21OYuvhcKRtWpZlOV2jqyilqpam1zxNHI9Hzs/PiVGaC33XE0JEoQjeY7WhcpU4LbzneDyejlmE2eJpmMZRGjZdm30NZSOhUCgUCoXCdxfFkVAoFAqFQqFQKBQeyjLPNE3N+fk5VVVlKXDFtbNreeLcsMbIsq6gpBAdQjzJmVUu8sYUsc6SAOscWivWZeXe/fssq8+Z+5JnTxbhjuMomw8PLpjmmXlZCCFijMTwxJRkC0EphmHAhyjC2xBkYt/a0++vtiXmZWG/P7A/HDgOk0T3pCSNAe9pu5amaWU6XsHxeGBZV/EyAKv3LItEEjWNFH+rqsqT8BYfxPXQtk32Dygpdufp/WVZWJYFneXPSik2mw1VVdH1PXXT4H3gmJ0C2qiTm0IB1hm6TUfdVCgUfd/Tdx3a6ByLJOLkK7G0ypPwRst2BEhsk3Xu1CggpVxgr2jaBmcddSPHfzweZVJfqZNzwPtA3bTZj5DyRoZhPV0nlZ8nzRZrZXOClFiWhaquWZdF4paMgSQNpWkc8etKXdVynF2b3Q721MBp2w6/+pPrYF0WlNaA+CzmecZai7Uub2LIhonKDSmlFDceeUTk3kl8H5CbIj5QOcdud5bvl2GaJnkPFM7KFsTqPTFEUoLLywuGccRWFX0vYu9pmliyl0Hn93/1BsWVA8P7cGpOLMvKuojH4Y3jLh/+uad5+ukPcPs7/VYvfpj3P/00T//id+adbv/i0zz99Pv58IvfgRd/7gM8/fTTvP/X734HXrxQKBQKhe8+ykZCoVAoFAqFQqFQ+CaQYmuMKcf/BOq64bA/EPzK9vqGBxeXdG0LJJpamg3jcOR4HAjeY6zBRylm11VN23VcXjw4FaIjkWmeUMD+sEcphXUOlMLHxDjN7K5d5/LiEm0MISWqaPBeptubpmFZV0IMVLUU4oMfSAmOw8g4TXR9zzTOaG0YxoGubZmnmRgTxoJfA8GLzFlpxTKtpy0ImaiPtG1HSpEQIybBsohE2RiD916iiBKnRoPEIR3Z7y8xOebGmEiMSQrMKYgo2suk+pUvoe97UEom17WWyXbnsNblaXaJfIoxEZInxUjd1Ccp81XR+upeeS+eirZpmZdZJMxao6qa5BLGWjabjdyrLFs2xqBI9JuecRwJ3qOczpsGSrZPnDt5CMRTIJJjayTm6SoyCCRmqW4knqjrWo6HA8aa13zSqrpGG/EdxBC5ePCAmBJGG1JMVI3DGMM8SwPo2rXrXFw8QAcDJJZ5IfhAfUOaICCeiXmeODvbAYp5nqmcO21DpAR1VWXRs7gXxnHAOccwHKXwnxLee+7du0dK+d6pyDSO0iRRieF4xK8ry7wCCa01h8OeTb9hnmfqqsZa8SNY68TdkI9lmiemeaHrWjab7ev1xS4UCoVCoVD4piiNhEKhUCgUCoVCofBQREyrmJeZpmmYpgtCiOIxaETMeyWRrZwlpsg0zfgQGbKkeLPdElNiGEa22x1qmvA5JshaByhilIz8EGVrwBiNrSqOw5EQA6DwYaUympQiCXPK9/fey2S9Tqfj9t6jlBT7U0pobRlHaS6oLBaomwY/joAU7YfjUQrhymTPw5SlywuuqjDWoLU0OEIIOVqn4Xg8iJB4GNFa4b0U0J2zOQ6I7C7wWKtzYybg10WaLUEm5hNJIpHyNoc1FtW2WGfYbPosPpbnGq3p+iyEzo2EEAIhBjb9BqU0xsxUVY1Scj2VgrZtSDGdmgUoaJoWY+ScYxAZsV9XXGXz5kWDAsZJPgNaSyRPlRssRmvqqmZeZrn4CmKIgHqNf0FifVqU4rTFobTOngfZ6EgRlnWhqmQbQilFVdU50kiExyFGKm1euUYKac4YgzaGw35PTBGtFcDJW9E0LdbOeB/w64qKkbZtpSFgDDEkpnEkxkDf9fh1pe83DMOReZnxq2ysrOuanRcrzsl5aKVOImv5vChSgmmaTuewLAsaTYrgKkcIA94HxmHEOJdl3fXr+O3+Sm7y7r/6d3n3G3gEhUKhUCgUvvsojYRCoVAoFAqFQqHwUK4K6SoXSiUqRnLqU4L94UAMkeN+j69rpmXO0/iWqqoJUeKKVu8B9SrXgAiBtTZMkxSg19VLBJI1OXYmZKmvYRwH6rqh73v2+z3GSGzSMAwypb4uNG3HPBzxq0TR1HWN1ooQpAh9FSvTbzY4Y3Ikj0ynD+OQBc3jKYrHOUsIgXmeiUEifbquY5rm3KRYqJyjbTuUyr4Hv6KUyvJhRdfJ9ZumSbY6YqKqpQDfdT1LFhC3TSvbD84RQjhFK8UYOR6OWfar8+S8iKFdVdG2PTEG1mVhijFvGxhSiqAUxmiaphGpMaCVwlWWcZTjS6QciSRNh6utBFLEGMN+f0FVN7JR4SzWGJRWWGcxOUoJpdBGE3wgxIhOCeccMYbsLFgwRv4KWlWVRDYpxbpKs0dpjU4pN28GXFVB/t+uEhH2VdxUSlF8BDG88t7aZImzp+97UorENTHPC1VVsdls0FpT1xUpbejalgf374vA2lUMhyM6NySuPruJlCOT0slNsdlucZWcR9M0zNNMZa+2VVpxR0DedpCopWVdRbg9jYQY2e7OGKdRYpm853A8EmJk03Un8XOhUCgUCoXCdxOlkVAoFAqFQqFQKBS+Ka4mvY/DEYVinidcXRG8P0UeRee4uLyUKJrsRggxorXG+4BCi7SWBCiatmWZZ9Z1YRwntNJoo6lrmczWyDS3tY6mbqTgrySnPoQgGw3DwDAMImTOklqjpQlRVY7DUaJp6iz7VUrJdLhzKKU4Hg70mx0pJV5++WX6XJSvmxqQKfJpmqTYPAzZERGYplEK+ykxzTNnZ2cSt2Nk6v5q+v6qWTDPMzF6uQ5ZtDxNI33f0XUdx+ORqq6xMXI4HGRzoOtQSkGSuCfnHMu8gEqkfBVN9jKkZIgh4mxAd/0pKqmqKmJKMg2/LpgUUUhxvM7NjATE4PHryqbfsCqwCbxWEj2UEilGfJQNg7ZrmKYJYwx13bAsM33fo5TcXx0CxtrccJmo6woQQXOKCWVkS8E6x+qzY2OVY13XRc4rR0VZ50gxErLYua4r5mmm32w4HA6sq8QIpRizu8NhrUEpR1WJIPtw2FNnyfIwjqfPT9f3sgWSNyqstRgtAmRjzen++fXqdS39Rq5t27Yih67k59M4Mo4jh8Oe69euU9c1Y97GCSmS8gaLUpqmzZ/9ZWXxC8ZZbF2hcoTSGytbvsuHf+79PPPiE/zE3/0JngBxGfzcM/Cj7+On//Bn+eCvPMNnvjDisbTf8zbe/ad/jHd9X/val4n3eP6f/zP+z9/8DHeOHrTl/LEnec9feIq33/gGpYjnPsDT/+g2N3/0fbzvT9785n43vsBHf+VX+fC/usPowZ49xpN/6r1879d5C//ys3zonzzDx1+4h49Adc5jP/Qe3vun3875Vx3ayAv/4pf51X+ez8NueewdT/HeP/TNXMtCoVAoFP7doTQSCoVCoVAoFAqFwkNJKqGNzjEuWTa7rijUKdpmWTzaOtK65jifwGE4sOk2tG3L/nIvgtoYqSpHjB6tJdfeWotzIscNwWOtFGeddewP++wTkLiaqq6l8B0j4ziyZLGv9wGUxO0YY0kpkBAR7qbf0NYVF/s9AH3f430gpYTJmfXOVRLtg4igfQi5WH7VGHB4H1jXQQrOxjJPI00r/oFxFLnuOBzRRhwC1jpIKccJtYBimmbmeSIESCmyv7wEZXL8z5W02FI3DUop1mVBG01VVTRZbqyAeZmxVqG0/EkhnkTYddMQQ2Cel+xRiMQQ6LqeGFaMMSeR8Oo9RhuMFalwiNJQMNaijSbFRL/ZMM+yTdE0TZZpy/Vb1xVnHZvtRgrvKZ2kzyGI82HNE/lKLadtlBQj67qgtRxL8IE5yVbKpt+IL0Mpgr/aSNG4quL+vfsiJw4iL3bOoRQSU6RkA+DBgwfyOptN3kYhC5UDFw8ecH5+zt2XX8quCUPKsunVew7jAVc5aisxUXVVy7Vv21PzKMbINE2nhsK6iGB69Z79fo+zjq7vmOeJRG6qGU3lHMPxyHEYaNqGZZ3ZnZ1JU8ValNasq+divXx9v+DfJP7OM/zCr9/m7tljvO2Hzlm/eJvnv3CbD/1Pd1n/6vt496P5gfEuH/577+eZO0B1k8d/6Bbt8Q63n/8YH/y5z3Pvv/lp3v2mb9NBjbf5wH//AW4fwb7pcd7+lpbxi7f52P/ys3xMf42HP/cBfvYf3WbEsv2+J3jruWX84m2e/5cf5Gef+ww/8b738sSpJzJy+xd/lg98enztefz2B/nZ3/42HX+hUCgUCn9AKI2EQqFQKBQKhUKh8FCqLPVd5jULeBXTOJFSpKpqyfSPY3YpSHSNsSZH1yxoLYXw43GgaXQuzBv2+z1t20rOvbWnafIY48kxEEIgpEhVaaZxBCClhFJSJdRaE2Ik5qn5lCBGkQ2v60qO589bAAvOVVlILE0Na69ilRRamVNmv1bk+KL1tIWgkK2HdVmptw2xqk+egWVZWNeVeZ5p2jZLqWUzYVmW09aGPEakusYYkfiuM8NxYLvd5Wn0lKf0V1DgV3+SKFeuQhuNq+R1U4z4dcVmF8OVCHl3tsOvnilHMmmjc9SQwb5KViwRQ/pULA8hYK2RjYwE9+7dwzrxEGCgrkQGnVKSWKZlzoX6mK93zL4H/UqTIHhxA2h9uhfOWla/0DQNw3BEKQg+yOcmN2JSSvjgMVoTY0BrxbKuADn6SqKldG7aaGMJQbYejDGM+fNS103edliJMd+DZZZ4Jm1xubEyzxPLOuMql6OUGsbsgaibOp9bYJ4mlmXOjTDwwYNSyJZHzb17L+MqR9f1WGdBa7S12ZcwAokYPPM8c2O75XA44FxFU9WMwxF4xfPx3cS9525z60ffx9951TbA3V97P+//9bt89KOf5d1//q0A3Pk//iHP3IH2B97L+/6zt7PNBf2rIv4z/+SjPPlX3sW3rpT23P6VX+b2EW796Pv46Vcf16//PO//tTuvffj4cT74i7cZ28d46r/6Kd71qmbGvU/8A/7HX3qWX/6VJ3jbf/4EFvDP/TK//OkRbr2H9/2Vd3PzqjHx5Q/z8//DM3zFqxcKhUKh8O80X6M/XygUCoVCoVAoFAqv5fLiQIqJa9fPULnGabWm7zcAGGNPGfFXDgLvPa6qT4JZpTVt11LX9Sl2x1qL1pqmafNzpGhf1zUpJS4uLqTJ4ByuqrGuoqprjocDx+PxVNCOUQq8V4XqcZxkYnz1bDZbQLHMC9euXafrOpxzjOMAJOZpzoXulXGaGEf546yjbSWT/yoGyTrLZrM5NT4AQpDC+TRNMsFeN+x2ZzgnwlxpIsA8LxwOh5PP4WpjwTmH9ysheI7Hg2wJrCsxhiyIzs0GL66Bru+BRNe2VM4RYmD1K957Vr9mEbIWl8RmQ0qJtmtxrkIh4mHn5NzmecGvXiKVrKXrWpqmwVU1bdvRdl3evjD0/QZXVczLLN4CJ5soMSaWdWGep5MHoW1l0v+qwaK1YZlnxkEcFNZajLOYfA1Tgn6zOW1AXG05KKBtWqxzGGNFcOyqfO/FCTEcjyzLIpspKdK2HU3b5usgxy3RWp7xFD90yM6NkePhQAjiJKjrht3ZGQAxJeZ5Zp5nVr9yPB7Ed9G2OGtPvgbvV0IMXFxeQBJpdd00+fVqdjt5vWWeqaqKvu+JIWC0wVnHPE4oZKNif3FByA2r70raJ3nqK+KGbr797dyEU9MGPsvHPn4P9OP82b/wShMBoP0jf5Z3f4+l3X+Rz/tvw/HEz/DscyOcvYs/95XH9Sd/nHddf+3D95/6OM9HuPUnf/I1TQSA83c8xbsehfHTH+dT0g/lM8/eZmTLu/7cq5oIAG96Nz/+J86/DSdQKBQKhcIfHMpGQqFQKBQKhUKhUHgokknfUVWWpmlIMVFfq1i9P03ipyS57leFfSJYI1sG8zwzjlJAN9bQ6ubUcLiawJecfxEIbzYbxnFgXVeMEUmwMQaUiJmPw0BKMWfvq5OY+GrifxwGUmpR2cPg15XDMHD9/Drey0aAvH+SiB8s83y1laCIIRBCxBrDuIzYtmFZV4zRxCwgDiGwrkuO+JGJfGMMCXUqXIMCFCmRp9cVxthTsV/+KJyrcNVKCOHUhKmc42oy3WbfhELJe3vPOE0obajrmmWWYr210iS4iklS2RshRX2YpwkfVkKsMNaSYsK1DXUt1zjGSF037PdHnJOooLpp6FppKMzLTNu2eB/EC5A9CSm7E0CjlGwDXPkj5P0llkhirepTk0QpuU5aaVKKdF3HPE0kJLqJBF3fEYJnXcSlEPxVw0hhrRFfRN7+qOv+JKpOyJKAc04aDct8kl8bowGLX1dCigzHI9vdjrquOez38lnMGxZVVZ2e3/cdTXPG5cVlbsTMzPMqjS4rn/Ou72V7IcdUaa05Hg6gNSl/P9Z1xfs1b/JE6hxJNQ8zXd/lrYXvQt50i5sPe8zLn+eLI3Dre3ms+spfbnnXX/k7vOvbdTwv3uFOBB77Xh77ql/e4m3f3/LRV0UQff7fvADAdPtDfPBrrBPc8wAv8MLn4cnvv8udOwDfy/d+9Ytz6/vfSvuRe9+GkygUCoVC4Q8GpZFQKBQKhUKhUCgUHkrfd+w2W5qq5sH8QAqnxnG5P7CuHpjpup6UohRvrcNYhw8yJV/X9Snbf9P3KK2YJnEKGGO4vLw85fuvqxRtr6b+Qwgsi0TSGCPxMwCbzRaFQmkNSTYDpKmxUDcNfd8zjhPzPKOUYlkkO98YkyONLN5PaK1ZV4mrqXJsT1XXEgkUI8syE2NP8Cu2aaRAjkigpVAemOeIQkn80LK8shHhkSghLwAAIABJREFUPU3TEELA5WidlOIp5kcpif2pnEyqr+sqTgStcVWdc/tXqqpGKRiHEecsy7IyDBOb7Ya+3+D9BdYavF9ZVznfaQKSgpTQGmlSpEDlKlKKeB/lPl5tKiSwtoIkXoYBEQ4rJc9dc8Nos9mwzAtVXZ2aN3XTMM/LKaZKCvYmb2NEhuPA+Y0bJxnyOA4opfCrx1hD0zYoJdP80zTm6zdKnJLitPmyLEsWSMu2R0IRQ8JUCne16ZCbPJvNFr9K8+BKtN33fY4sakUC3TQE77FGmiLruhK8zxsKKQukVW7IiCh5WVaRVltp4iglfo5HH32UYRjY7c44Hg5oo5nmmcPlnkRCGRiPEuGUYqJyDq0t4zBQuYrKKfwsmzrqu3Qhge324XFEETzAjZt8x2f2X7rLNyrlb8++9tHe+9yz3Pvc13vWyLgA3OXuy9/gxa9d/zZEMxUKhUKh8AeH0kgoFAqFQqFQKBQKD6XrWsmoV4qu61gXmaiunJOf9Z3k2Wdxr3OOw/F4mkJv6oZlWXDWsawLbdsBnMTNQN5MIGfVz9R1fYqCGYaReZ6JMXE4SPyPbDG4k3D38lIEtXVdY4ylrhtCECFzSulVzgSZ8k85LiiEGe+lEVDXNZf7S5q2ZV0XvF9p2paY0mkDQetXpu1NLkArZLvCVhLXM00jwzCw2WxfuS65gQGy4dE0DdqqvE2gTxPuWmnqqiYEcTiIK+DKO8DJhXCV13+1RaAULPNC23V5U0Ke23Wd+CSSZ7vd5sYPhCBF/eA9wziItDj/nHh1fgaQ9w25kJ4SEqHUtlib8tR/lYXVjrquOB796V5cCYevmkRKSRQWJEIMGEw+jhVrDHVVMRyHU5NiGieapiHGJK4HLVshMcrGhWweqNxwmk/bHtYatJIYrWVd8OsqguNlzRsMgZRkI6buGo7HAy+/9BJvetOb5Z5KD4au6/I1rvMWxkjTiHNBa4MxlsNhjw+Ba9euA4m6qbNQOjHPE13foxQoI5sOdVejtXgntDanIKPzG+dc7i+kgfIHFZ0LDS9Lkf872kx4RJoVX6+ZIE6V9it+uuVdP/UzPPU1tgxey01u3gC+XjNhHPlar14oFAqFwr+rFEdCoVAoFAqFQqFQeCi1c0QfICmuX7tG2zVUleXatS1nuw3XznZcPzvDWZPjhiRqxvuFlBJVntxe1oVhGJjnKUt9xZFgjMnFcEVVSR7Kuq458gb6vqfvu9PU+NUU+LIur2w8eCncWusk+ibJ1oAUlhUhhjwtH1nXwPF4zEV1mTgHWNblFIXjvc9ehz57BjqqqpbYonVltzuj6zqapqXrepwTIbPWWpoXMdLl5kCIgWmWDYZ1WU8iYa01/WaTmyEVXdtL5FBuPsh5+hzxZLDOSjSPtVjrGIeR4+GYHRGR3dnZyeEwTzN+9WijqCqHq6pXXW+L1hZyDJPW5nRMIYhnwOV4H/Et1NS1nPswHMUP4BwxBqx1uelT59gecRHIVoJ4NDabLSH4U2PHGJ1F1AZj9KlpEYJnt93y6M1HeeTGDXa7HdeuX8MYw5QbQleRQd6L18IYgzX2FRdBbhQsi3w2tNGnSCWRanNyIlRVTV3VQMJZh7WOYZSmVcqfnyv/hqvyZ3iZ8d4zDMP/x97bx9yW3Xd9n73XWvv9vD3PvXc8Y2ogU+xQjBoKCXETqJK2JA2YdyGjJFKiBMSbIpm2BAloKZBCKggSLVRKGqVEVKmQIUndIBw1tmhspZZJGJpJwaGmYXDm5d77vJxz9utaa6/dP9Z69ozt8YwbkvE4XR/p6s59nvOcs88++2jO83v5fri6ekya+HPY1A157mOQ/DaN4HBxYL8/kGU5dd2waTYkiT+eoetDA8SSCuFjomTqmwpv1o2Ez4XLX8lbS+DFEDv0aXz8ff8Vf/Yvfhc/+txr380wjJ/xtef+n3/1qV+4/xRPpcD//XE+/hmPdeZf/dz5U77y4C0PgDM/8+yraZKf50e+80/zZ7/j+/iJG4AHPPUUwCf4+Mc/89bn5z7B+TO/HIlEIpHIL1tiIyESiUQikUgkEom8LkWRI6WfqJ+dDVPuCXVVIaUgYSFJ/YbBXcG7qiqKPCdTCiUlZVn65oEQTNO05uwXReF/RvrCtp8s94V8L/ad16z5ZVnIsmyd7u+6jrZtfd5+mqwuAWOMl+Rqb00VQoYmhZ8qd7P1guhlQWU5i/NZ/uM4+cgh8I8/adq2Y5x8AdpH2aTMs8O5l7cBhJAhnidhCoVmF7LwnXMYbVYZtAsuibt/e/FyKKZLv+0wjmOYvhdsNtvwHARFUTIMA1mWoTJfyDfWrk0H35AIzzXPIGH9nnNLiIeS6zaFNSZ4J9L1tWFZkJlEZYoF3+zouh5jfGNgtj4iKBVijeG5awykwm+T3L1GVVWx3+9Ryhfpy7KkCFsK8zxTlgVS+PikBGBZEElCrhSHw8E3RYRkWfwGSSpSirxYX4e7houdHXmWr3FK1pr12p2mibIoyPLMx2uFwn+e55RlSVn6DYaFZRVZCykoy3K9joAQgWXWuK3z6cw06XXLRYh0lVufzyeKomDTbCirkqoqSYVAqQwRjjFJU1SmKIqCru0Yp5G+72j7lnl5lQr8FwxP86W/8QLcs/y9H3iWT7E9vPRBPvBTA5ZfydO/4rP8+APvYTj/zE/z3CtPw83H+LGf/LTSffpO3vWbShg+xgf+wXOf8ljX//h9fPCTn3bXv+ldvC2F6w+/jx99/lNtzw9/7H38+A3Yyy/mnUHS/M4v+1JKBj72gR/huVfe+c3HeN+HXq0ZEYlEIpHIL1++gPclI5FIJBKJRCKRyBtFnue+4Nm1NI0vbBtjadsuFG8Nm10DKRyPJ5ZlpqlKlMpwy7JO2W82vtAqpVqn0MuiYHGOLMsoy2ItfPsoIcPhcEHbntlsNkjpC8Be1Jv4uCSl6PveT9sLsUYY9UOPVBKtJ7bbLV3XASClQCpBlufIIAkWUmLNHKKHEmzI+J+GHpaFoijWCKO+74GE87kNzgaNmx3NpkYpyTAMKOkjgxagLAvAOxyESFFKkSYpbvGxQH3vJ/T9/RKcAzngs3VeFhf7Cfk0TVEqg0WT5wVlVa7Pf5pGZmsp8oI0NfRdh5IKY6z3EYTivy/bL5CAnqYQvZSyzAIpBHq25CLHhWaHmS1p4n0USeo3OKT05/puOyTPC++sSBKKELXkRcXBU5AXvlm0OK6urkhS72VI0xQpBNYY39gQkmQBawyLWzBWvyKOaaauG1TYWvGuiYRpnDidTgiZkiZ+a8JvSmT0fcc8z34zxFryZkPf96uHYHGOLPWNju12y+wcXd+x4CXXWmuyLMNozeIWxnHwr+niRdR976+ztm1RWcY8O2brmCbNNBmMNWw2G4Z+YLYzRVH6Jo6dscYgpIAJhBT0Q48LkVVfyLzt676J3/Yvv4sf/em/w3f85bfxxU9fILvnefZfPMSy4Ut+79fx9Gcba7z/pbzrV/0oP/xzP87f+vMf5x3vfAp1/Rz//Llryl/9Ni4+8amrDE//jm/gXZ/4Hn7iw3+L7/hp/1jm55/l4y9ZyrqE7hU33r2Lb/z9/5zv+rsf54N/48/zsV/1xTx9IRnC7ZFP8dt+z7tedh/8mt/FN3z5J/ie/+PH+Vvf8Qxve8fTXNjwPMqSkk+TYj/6IN/1136Uh7yTb/gr38A7f5HOZyQSiUQibwbiRkIkEolEIpFIJBJ5XfzUfLJOYM+zj4q5ExnneU7Xdz4mJ4E8zyjyDJFAkef+7yxj22y4f+8eCb5Iq5TCWIOdLT4OyReuq6pao3TAF5WPRy9KzrKM7XaHUoqqqtZtBn/7ZPUh3EXr5HlGmiYoJVFKBs9Bip40SmWhKZEG78BdxI4v5Eqp2Gy3SKl8MVpPnM9nloU18ma2dvUVpGlKVddIKUMufhJibvzkubUzWZatX18WSBIw2pBlGW6eKYqCPC+oypK6adaJd601aeIFzWmakgov+7WhOH2X+0+SkKRJiB0KDofQBMgyn93v5nndGsjyHBmaFbObvUTaOYzVIQ5K+A2QEMXk5dF2jaZyzjdI9vs91prwGimklDx69DDEUflYo7vrpWkav8URtlGKPCdNUpRUKKlI02SNgBKpf32lksx2Xl/XaRqRUoZrQeIWtzor/DaIDg0S7yEwxpLlhd+0CI2Zoe+xISrrbtPBGE1VVfRD7yXSego+hQU7zywLHA4XNI33HhhrSMP5XpyjLAvqpuZ4e1x9ClIqsrxg6L2L4s6V0fc9xvhorkz5LZOyrNZGyRcs6QO++k/8Kb75t77DF95/6hme+RfXbN/2Lt7zn3477/l1r2UW2PCub/1TvOfL38YFD/n4Tz3DP39U8MW/89v49t/9xZ85DZk9ze96r7/9dniOZ3/qGT7RPuCdv+OP8c3//mfqkDf/3jfzZ/7z9/CuX3WB/eSzPPNTz/DxK8VTv/6384e+/dv46ideeWvJ07/7T/Kn/sC7eNtm4LmfeYZnPnHmwa/77fyxb/wtUbYciUQikf9fkSx3prFIJBKJRCKRSCTypuL6+nb974uL/ef18X/kh/62l/L2/Sobds5hrWGz2aK15uHjh+x2O+bZcrk/4NzC+XwmLwpfOF2g67oQC+TIyhKtJ/Is53g60jQNzi0URcn5fKbvO7Is43C44Hi8XYvQ9+7dQ0rFw4cvhaifHmsNxrjVdXDXDPBSXIm1FikVWk+057PfisgK39BQiqHvSfCC3oWFZfGRRcPQI6XCGI3WIxcX97h6fIWUOVVTMvQ9i1uCs0AArDFMd80MKSXG3P3tmxd6mlh4WfoMkOcFJkQ62dn6yXul6NoWElb3Q9e2bHe7VcRsjaGsKrTWzLPxz2EBF5oKd/FDevKy5a7vwoZJyfH2mjRNyfKcSU+wLCyzo6gqrDVrdNNdZNRdo6XvO6w1PPnkU0zThFKSqm64ub6BZSEFsqLg4aOH5HmBUr5pkmUZmfJT/uPkxchGT+w3O+Z5XmXddp4Zhokl9Y2Wru/pOn+ui6IgDcew2WxRSmFDMb9paq6vr9cG1Ha79RseecHt7Q337z9ASknXtTg3M8+OXCmKzIu9jTEcj0eKqmKcRjZNw/Hm5QbW4kCIhHv376+RWlprhEjI84L9fh+k0xmf/Nef5Im3PEnbtpRlySf/9SfJs4xms+Hhw0e42VGUGXmRYbSFBISSaGPQWvPf/PXveePe7JFIJBKJRH7JeCM+059Op1+S+30lcSMhEolEIpFIJBKJvC5JmmCsoSzLUDBfsNaw2+3IMkXT1NS1Fw4nQJoKyrJApMILe0MuvZfN+uigTErvT1CSNElQUq3/HschRPoAIad/v99TFMV6TD7v/m6zIVtjg4RIGUJM0DzP6zZFnmcIIZEqQxuDCJn30zgCCalIqeqKZfFugmmaglfAT48LIUjThMNhT5Z7F4QQApWpdWo/y6Q/3gSs0cEdMIeNBUtZVn5yPWxfOLcACUL4JsTCwuwcVVWt0U7eqZBQVdUqmu66FmsN1hqkUuG+3LolAX67QCm1uiUI0/N3txEixVjrY52sxYbJeKH8pkMZthyAMMHv1u0DWJimib7vcG7hdDpzvL2lKkuqEOVkjaYofMSRb6x4UbS1vsFRFAWztbjZN0TuzsGdg4DUN56yEGUlhGB/2Ptr0ejgfZg5n0/rY9w5IPLcew/uZNXOzeuxvCyNHqiqCikEIn3Zt1BWlX+eUtJ2HamQGO1jopxz2Nm7NIwxNM2GJCE0XPz9lmVJUeRUTQUJodFhETIlL3KyPKMsy3CdpUBCURbUdcMU5M4uzvtFIpFIJBJ5kxEdCZFIJBKJRCKRSOR1ub66oip9jNA4DKRh4l+FIraUiqaqqeoaPQzc3txQliWwsLiFrMjpuy64ERyz8zE3Ugoypdjv9r7gDtze3jCOI3meM44jVVnCsjBNflq/77tVngy+yF0UhW8QTBN13YQNBLkWk51znM9nyqLClY6EhC5MlKchGsm52efcq8xPyhs/3W+tZZ4lWhMK+ekrGhgKgGHoyfMc5xYvAsYXrIdxWJ0EVVXR9wMmuACklJRVRdu2IVbJn2ulJH3XkWU+qqmuG6Ywvd/3PbNIGYYBSKjrGmMMRvu4prLyRfy7AroIRfKqKsPr5d0LWSZZFkeWqXV7w2jDJMY1ImmeLVmW+9idELVzOh2BnCzLaZpNiBfyTortdkOWZVijSUiY7bweg98OKUP8U0JVVgzDwOIc2+02CKCdj7jSvmmzBFF213W42fsEnHMo5X+NtcZvyOR5vjYhfIySoSjy0BgwayPoLuZpHEeKoqCqKuq65nh9w26zZV4WhnHEzpam2bBYvzUxDRPbzcY3X6RYY67unCFCSJQS4br018tms4EFHj96yDw7yrL0DYXZkqYJ292G/WGHc/4c1XXDsjiGqafvhyAej0QikUgkEnnzEDcSIpFIJBKJRCKRyOuyuIVpGum7jnEYSZOEPPOF+9lYhr5nDkVjXxi+k/rCMAzM1pIAfd9hrPXeBCHWIrpzbs2011qvxf80TSGBVKQYM3nxr/GT+FWYHE/AuwNYyPMMFTYUjNbMsw1NB99wSNOU2VrqpvYNiLL0kTXL3RaAXTcNnJupw4ZCWZYkJKtzQQQ5cFVVFEW+TrvfxewkwdUwzzN5nodGxYIMWxhJcCmkaUqWZczWMo5jKODPDMOAkCJIeX2j4ObmhnEYglOgCD4I3wxQWQZhMh58IV6pzBfuhSBJ0pDNP6+bG3fP1d9HRlEWKKWomwaAtm2pwzEuy0KWZWvE0Z2T4m5TwFpLpnIW51BSrYLtu82Ku20OWFBZFgTdmjRJ1mshCVsKS5BQSyUBR1kUiDRdRd1VVZFlGSrL/BZLlq8NI2MMbnZ0nfd1SKnWTQ7/mjrGcVhvP40TCzBNmuPxFhKYppFpGlFCkqssFPV900prjUiT9bzcxXsBHI+3WGvQwaMhpUIISXs+kybp2tjSekIIQZ5nbDbNuuXR9z0shK2f2EiIRCKRSCTy5iJ+OolEIpFIJBKJRCKvi3MOkWZM47hOdi/OMQ4jKst8TJA1GG2o6noV7NZ1xaQ1xmiElKgFpLFUlRcRZ1nGMAwURUlV++l8v4kwoZRavQNaa6SU7HZ72vYcivQWpRQJyheHhaCuK0SSkKYJs7PM44zWXjaslFqnxosip6oqmqZh0hqtCaJcH3UjhWRxS/ALeHeCMYbdfh+OT68Fbz/97jcsloU1smbSEwDWGsrSbw6kScKSphShCO8bEL4hMAzj6iFoNhuKolyjjO42QIw1FGUZHjtBqYxh6Fcpcde1XtrsFEmSrlsd1lq/LWAnpnEgSbz7YLb+HNZ1zTD03imR5ywLXFxc0Pf+vsdxpK4r0jQJTgT1iucLu92OSU/IJPUegKbGOgfWUNf16j9YloXZWs6nIyQ+osjNjkymnI4deZEz2B4hJCSw2+/JlKJpGr/lgG8IDcPA5eV9bm+vSZKEvu+QUjKNI8vCKjS+i0kSabq+lnleMM+zb2oZTZVX3B6PWDeTiNQ/16phnh1JkoJbaNuWebZh+yFld9jT9z3DMIRNlvPaDAHIckVe5MFXsWCDK8NHbBUMw4jW03oNdJ2P4sqzHKHk2hCKRCKRSCQSebMQGwmRSCQSibxBfO27/8Dn+xAikcgvkH/4/r/7+T6EzztGGxa3UBY51lrSRLCIZJ1oTxKBnibcPONmhzUGYwxZplZnwoJvCLhlYWEhTRL2+z1935EmC7lS9EmCSFOapg5Z/1BVJX3Xsj0cKIqccRxo25b9fu8fZ7bkecbsHG6eWZKEy8tDaDS8LAlO0wSVKbJMrTE1VVng3EyWNYzjCIA2Ogygv+xHGMeRqq59tNM4IkT6KVPwee4jgPp+DFsEcyje52ijGceBqqpJE9ZtAz2NGDOtBWgphBc3C8k0+QieZVnC9Lufpi+KkvQVkU7WWqZJQ2g+SOXdDtPko4aM0T4yyHoXgzEmNGGW0HDwkUrH4y1N3ZDlWZiQFyilwmPMGKMxRlEU+drUuTs2H+WzZZ4txvgtFOcWrJtxi0MKGbYBFtJU+MikPGPoB+qq4vrqimazYdJeQC2lwljfQNlst+hxRITp/ztR8t2GgzVeop2QYoxdt1j8NoaXVs/GegnyMK5RXGaaqCvf8HLOMYwjUvlGhMwyjDVM4TZumcM2iVolztdXVxjtj7Esq7DFMGFnx7IsjMNIlhW07ZnNZsP53NLUDePUU5YlXdv7Y5vn0FjwDbQk9dd/8ga+tz+dVwohI79wfqlkmpHPP/EzfSTyhUv8TP9vRow2ikQikUgkEolEIq/LbB0iFd5DoDVZlnF5eQ+lFEabkL/vRcsmfL+ua5xzZFlO27ZMeiJVAiEFCQm4haosKbIcPU2kqY/MmaYJKQRFUfrHDvFAeZbRty11VZPnOafj0fsZhMCF+Bxjrc/eXxYuLy/ZbDZo7SOTmsZvQfiivP85n5nfY4x3DNR1EwrT0Gzq1VuQpmKdrPfbGDMqFNOlVCilqMqKe/fusdvt16+Dj13quo7Hjx6Cc2xqX5xWmf9+URSUZclms0EEV0NRlAxDjzVm9S/cRUflIf5nmqYwge9YFhfO1RKinFKsMesmwjD0a7STDM0V5xYu790LDZGUVPip/bti++3tjd8YcDNVWdE0Gy4uLtnv92sDIk19E2SaRh+BxMLpfGacRrTWoekiyLMc8I0krb1DYbvdYiaNnWdubq5DFJFESum3N9KUvu+YtPZT+iyhMbKwLAvH4y2pCBFJQpCQkqbCRxlp7c+ZsSgpsdpQZJmPXlISkfitkDzLmPREVdfkufcmbLc7tDG4ZaFpGqqqZrvdhUgnxeKWtRF1dyx3voquPdP3A1obHj9+xGazxTn/3iCBoiyZppEkTSiLkqqqSBJ/jWutV+eGSMUb9t6ORCKRSCQS+VyIjYRIJBKJRCKRSCTyutwVu5XymfR3xeh5nn3G/zyz2+7WbPc7wa6UEpUphEhZFofKFEVRkCaJj3ZxDin99LuefP78pqmRUqxCYz1pqqpCT7447D0FOXXTkCnF5eU9X7RfFubZUYWC/zzbNWrGT7B7f4PWUxA7O/qhR6mMcRyQUqw+gyRN2O52/n6sWz0Bfd/5grJSzG72x6W1z8JvW8ahXx0RSZIghC+MZ5miLivSJF1dBipToSC/oPVEXhTkeUZRlAjhp9JVlvmYHyAvitUn4dzi5cXOeVEvPs5nGke0NuR5hg3n/+6P9yP4hkhR5CGv33sKhPDRTfP8stciTf0584LshWHo14aRlApzdx4XXwifJu8bcME98TILcxBZJ+GxlFQUwW2glG/E9F0XIn809+7fJ8szsixn0hPG2iBqFuv5qKqK3S4Ii41FKoWdZ/K89L4BwM4zfd/T9x3OOX/8QmKNxUzaS6vT1F+jSlKG5pWQMmyW+DgmIcV6vVvrI46stXRdi9Z6dUV4EXeynhe/seNf3zQVSOGPMcE3JfK8YJomsiwLEU0DIvgjIpFIJBKJRN5MxGijSCQSiUQ+D8SVykjkzU+MLvhUpmlEKsE4Dex3e9ziuLp6DMtCWXr57d0U+e3tDcbaEG9kKavSF/H3O6T0BeOmrrm+njmdjiiVsSwJ53PrI3+0Zn9xQAjlZcyzI01ShmGgqi45nU9kWQ7LgpQCa42PPNKaKi8Yhp6m2XgJ7rJw2B8YxoFxGJj0RMLLjZGbmxuUykhDIX0cR5qmRuuJafRbCvOatW9RKqOqqrVRYIxB65FxkPR9x2az5XQ6kiRJiL0psdawqRsvEwiyYb9hMFPkuS+QJ4Jh6IN82fsHdvs9kFCWBdbO6zl2zoVIIbM2CTLlBdBucRht/BZBVYY4oRQVXAFl6f0AeZavcUsAV48fk+UZaSpDgbwLTRBFksBmu0EIwcOHL3FxcenjoPKcaZooinyNj6rrmqosccuCNpq+68mVQipF255RSrI45+OZnFsdEUopzsuZ2c10Xcf+cGAWjlN7Js8L6rqmbVs2mw23t0fGYVyvS4BUCKYQTTXpiSzPsXZmtpYiy8iU/3Mnc5ZK+mbFseClRw8Bfx33Q0+WZRyPR5bZcdj7ZlLfdb5h4RbMZKg3DUmScnl5LzQCvNR5djNlcFhIqdhsNzz+l48weua43FLVJX0/kJDQtmcuLi9Wsfidw8Fag57MG/8mD8RInkjkcyd+po9E3vzEz/S/eMSNhEgkEolEIpFIJPK6CCHY73co+fIU/TRNGGNJhSANGfZC+InxO3Fx0zTM1otmvWfBsd1uGccB8BJbn+k/0bYt5/MJYzRWG0SSUpUVUkpurq/DRoTfGhiGATvbIBj2Re+yKLHGkGc5brbkKmNxXma7yo+XBaUUZZ6jtfHT9UquBWlfRPXPbZ59LNB+7zcMdrsdZVmSpinjONH3A+M4ASl2ntHaMLs5TL5bqrKCxbHb7QiLEaFRkK0NDmMt1lr2hx2bzQalFGmarDFPaZpgrfVFbGsoCp/9L4SPvnHOkecZeZHTda3fpiBBhiaAc45xnMJGRso8O6ZpZHYz4zBgjKYsCpSU67bHNE2osEXRNM3qN5imCSl9c2cJmU93DgkhxLqN0vU+Rmmz2VCWJUVZYueZp556KzZcC3dbBW3bUhQFUkrq2kdWVXWFsYayLJFpSrJAmkDTNJxPZyAJMUiCLMvIMt+kGIYhbFZ4N4WU3lWhjSVNfeHeGkvf90ipuLq5RkhB0zRA4qOkwuuxLAvDONANA6rIyYqcBYfR/nxZY7hrPvhrf/GbD13PsnhHRJIk3NzcAH6DxV9nfqvGx2RZxnFctzL8todinpc1qioSiUQikUjkzUJsJEQikUgkEolEIpHX5d69e77Ayssy2bqq2e33lGXp5ccHXxjfbLdr8Xue57VB0HcdbdvSdx1d1/nYmslH+tRNE6J1fPzONE1BwpzQdy1ZnnE+n+i6juNU22+0AAAgAElEQVTpuBZ9265lnmeapmLTNJRlweJm8iwLcTMp4zgyzzNunimL0kcGKS/ObZrNy3FNUjKOI8fjkb7rQmRRSpKwZtfnYQp/HIawzSCDyyEhz/O1MaKUYhh72q7l5trn/1dliQwSY6MNN7c3HI+36+MCnE9H7wUYxxAztDDPFq0nrL07PynG+DiczaZBSsl2uyVJUvoubDXkvsBurUUKwb37D8iyDGvNKmleADc7jscjRVFwuT8wGwMLvrmx33N7cx2K2r5xUJblGn80jsO6lTEMg5/c7/v13845qrqCsK3gtzRShJCkYQr/Lm7IWkte5Gx3WzabjT8258jzHBZY3EKmlBd1LwtlVdF33Xpci3NkeYZIBUZrxmGg6zqGYWIcR8qy9j4Fo6nrmsPFBQB6mgCCC8I3XbquX0XP0zQxjAPTNJLnOVmW0TSbtZl2c33NPDuyLGO725Gm3ocBySsaC4tv9uReVJ0kiW/G4F0LSZquMWDXV4/8Jk0kEolEIpHIm4zYSIhEIpFIJBKJRCKvy13xeRgGmmYTptt9o8BoQ900a6774hzjOFIUJUkCeV4gpWKeLWVR0LbnMPk+kiQJXduSioRm21DV9Vp4tdYwDn24jwyl/IS5SAW73R4hBNoYHjx4AqsNaZJ4cbMxDOOItRatNbPzheok9b/+5LmP08lUxl0h+uLigsPhgLWGaRpRWUZd1WQhhqjrWpRSbDYbnJt9bFFRfMokfl4Ua+yR31oYVifAbH1T4G6yvwwOgc3GN12maaKuK+7fv09VVogwbZ+mKdM4eqfAnadCSi4vLsnzbHVPtG2LtRYhBZvtFjf7qJyyLDHG0Ics/2mcUEGYnaYJY2iK5HnG0PfMdsYtPn7JGENeFIB3INS1j0Eqy2qNI1JKrn4FH82TrFsHd7eZ55mqqtFBgFyW5SpjrqqS3XYXhNATx+OR2TmGcWQYBsZxZNNsSPBFf7X6Hhw2NCDumiNG+2MAKMqCebakqSDLcvqwJWGMIUlS9DShjaENDa2q8psvvkk2UBSlj3VKU4RUWOeo6oZlgdPxuMqmHz58iEgFzjlub27xUVTlGlN1fXXNMIxrI2W72zEMA8Ya9vsDeV4wDsMaUbXb79GT5nw+vzFv7EgkEolEIpHPkehIiEQikUgkEolEIq+LtRYSL/a9ubliHEeqqvIFXqPJs8zH3CwLp9MJqXysTtM09P1AUeRAwqT1OqHeNA1uWRjHEf34McYaNpsty+JIkiQ4ESr2+70vtiqFFAopLefziU2zYbPZ0A8tu2aLNZa6rrjkkmVeuL29ZZ4tdbPhNJ/Y7w9kwXWQZTnJMGInS6Yy+r4DCJE9flpea599L0RKU9cMQcy82Wy5ubkhz3KqsuTm9ogJUTd3UT/WGmTYeiCB2TleeukhRVkwjCNSKlTmfQvn8zk0DRJSkZIXBQu+6C2lRCrlY5k0sCwYazHWkqZpOE894Kf9Ly4uvUA4PJc0TemHngUvJ/bH58XAVVVxc3OLC2LqdpxIhGAaB+o10siFpogv7CdJEppEOReHS7TRYfvEcTgcGMeRLGyDFEWBUorb21vSJGW73fpIKmsQQjAOY2g++K2MYZp8nJNMOV4fEUJgJ83YDjz1bz2FkJJ5gaurKx9lVZZrw0KIjDFsQbTtmQXHfr+HJSHP/G2dc5zPJ+Z55vb2liWBLMux1tA0G4Ygyh6GgaIomCZ/jY/jAEphZ8tms+H66oqqrhnHiaIo/JaK9lsvRVFgrUUpvw2y3e6oG++zGMcepXLGcaQ9n0PDzAu0jTFBhN1wfXUVtlwikUgkEolE3jzEjYRIJBKJRCKRSCTyuggp6bueLkT+GKM5n0+kIqU9nzFGM1vHMIwYY7h37x7GGM5ti3NzmMhOabsOrQ1CKrTxmwx5UZCkKU8++Vac81P7x+M5iIAThmHEOoexhrqu120APU1U4W+tNVJKpnFiGkeccySJlypneYZSir7vGcch3P8Jay1FUWCMZtM0NHXNbC1lWVDXFUmaYIxGCYmSktPtETNpZuPdCXVVYc1E09Rkmd8YAO9B8NsYCZuN395QWUZZl0xaczqfMGGK/m5q31rLo0ePucv/L4rSb3sYg9GaqqrY7XYIKRGhgQCskUh+Q8SuET3qFXFJTbPxETpAVfkCtdG+AZDnGSSQpIIFGKeRJPG/Jrbn8+piAEL0lKOqKtJUIJXCGEPbtmEzQwX5tA4xQDld16FUxul0ZhhGNpstZVVBkjLPC+MwMY4T17e3CCkwIb7p4nDhN0zynHpT+/MQ/AZCSJRSa3xVnhchIighSROquoEFHzGULCQipZ8GCK9nN3Rr8ytJQGuDMSb4FjIePHiASFOauqHvO7QxjNPE7Ba6vicvCrQ12HlG5VnYllF+02L0mxbTNGKMZn/YM4SYpSQRoWHlNz68Z8Q7EnzTJ/HNi7D5EYlEIpFIJPJmIjYSIpFIJBKJRCKRyOsyDgNCKEQq0NpQ182aFd80GyZtOLfnIFjerFPsp+ORum54+PAR4zjSnVuKouR0PNGefQHaaIOSGX0/kKYpdb0JsmPfgJBSYe3MdrvDWk3CAsvCk08+hZtn0iRh6Hu01gzDyNhPaD2R5wVFUfL48WNkkAfXdUOe5+QhNshai1v8JsXQ9+y2O+qqRinFNE0ERzJ5nnNxcUFZFuR5xqZpgIWyqn0RO0zqSylXoa/VviieZd6v4COZdhRlybIsa86+ED7GaJp8A6TvuzUaKs99XJK1lq7rMEajtWZZltUnUZYVUggW51Aqo6pKhnFYvQWbzcYLp4VYo3822y1Ns8EYS1GWqFz5eKf9gbppcM5RNxuU8tFOd8c7z5aqqklTwaNHD+m6bm0gtG1L13akqWAYRq6vrzHGP97lvXtrlFWZ++bP0PdIpVggRP74+CFrZsqqoshzkjRBa03bdtzcXjP0PcvimMaR/X5PnmV0XevvG9+U2W43/ufDdsB2u/PxVH1PluXUTYPKM8ZpZBhHYOH6+oqh75mmkWXx0VzjNLLb7dhtt+R5zksvvoA11l9XeUFZlWt00zAMXF9f4dwSop0UVVUzTRPn88k3w+wM+MZO0/hmR/IKfwT4xpdz8xv4zo5EIpFIJBL53IiNhEgkEolEIpFIJPK6CJGGgq6P95HSi29PxyNpmsDiJ+nv4nwylWG0ZRpH2ralLKtQHC/WAqpzC30/4pYlFMd9rn9d+7z6vu/JwtR4lmXMxtC2Z/Is4/LiAIvDhKK6c44F0HpEBBdCVVXkec52u/U+Bzuj9eQbCM7Ll6X08uPj8Uie595nMM8sbqGqKjabbRAnD8BC254py5Iiz5DCT5j7qJ40TO87kmShKHIOhwvSNCHLctzisEFSrDLls/jHMRTl07Vp4ovZE03TUFW1l/QWBVL6eJ779x8gQpZ/URRkWQZAUZaheO7z/pumAWC2lvP57LcejF7jkJxzvPTSi8zzjFKKIi/o2g6SBOdmtDZYa9hut3Rty7Is6GkKEU6souS7aCEpJJvNBpXlwftgwgbIGDZYTIjw0Tx69Ji+88+zKAq01vSjjyW6vLwEQOuJ7XZLXTckaRKOM2O327JpGva7LbAwTiNGa5RSLMF3MY4jaerdFItzdF1Ls9milCQVgqvHjxnGkdm50AhwPHjwgDGIl6dpwi0z0+SvFa01fdeHBpkIboiMPMuxxvsg9vs9WZYDMAzDuilh55myrNCT5ub6mizLOd4ecbNj0uPL0U9puoqn77ZUIpFIJBKJRN5MREdCJBKJRCKRSCQSeV2MMes0ttZ6naTe7Q5+InscYIGb62vsbHniiSd46qm3IqSgKAtefOEF2tZvI/iCqePy3iULcHl5idaG8/kUCuMJl5eXDP2AUhmTnjDa4GZDVdYcDjv6rqPvulX4m5KypAvb3ZaEhHnxjgTnHA/e8hacmxFC+SgkrVmcI8+yELOTcGWMn5avSi/gzTOUyri+vqIovJw5TQVNk7EsjrIsmaYJrX1E0Xa7JUn8hsWy+Mz7YRzY7bZYO5OmKWkqsLNdBcy+iHwDeJ/BsixcXF7ywgvPc319HeTOzdrgeOXWw13EU5r66CffeKhI05Su64GFzWZLURaA317Y7nbM84zWfqthHHouLu+RZRm3tyfvBdCapmk4n1+gripfEC8KVJaRbja0bcs4eh/A6XiiqmsSIMszPvnJTyKE5Pb2ll1oAvR9j5QZmcrYPfVWuq5FKEW93ZGXFZPxzozz+by6KvxEv6DXBjf77YRhHBBCUOQF4zhwPp/Z7Xfe9VDXjMPEuT2HiCuFlIq+u129EC+9+IKXYIuUw+YC62ZOpyNKFUBCFTZL0tQ3h3wsU8vxeERKH221aTY0dY3VhrEfyTJFmed+88BM5HlOQooxmmmaEOH1drNbI5/OZ3+Mh4uDj3/Kc9I0wRjDbr9bb9sP3eftvR6JRCKRSCTyasSNhEgkEolEIpFIJPK6tG3HwsJm4yfdrZ1D1I5ZC+XO+Uz/aZpozy1S+a2Chw8fYqylKHJSkTJby263Y3Yzfd+R5znD0JPnOdYYzqcjQ9/D4ljcTFXk1FVBWVY+1mbSGON9ALCw2W7opz5IjCXjNNL3Azq4BdrzCSkUaYLPpBcpZVmipCDPFLmSFHnui899z+XFBWVeUBaFdzaEjQmVKZRSjNNE27aYeaaqK6wx3NzcoJTEuTlEDkmKwh+zj8tZmBe3ZuOnqQjf9y6Foihomg0iTanKCiHSIHzW65S6lBKtNWnqC+930/557l0EbdsyDH6qvuv61StgrSPPc+bZcX19zTRNTJMmLwrK0jdWsiwjSRNgoapqisJvODx+/Ij2fGYK2whlWa3HJKTCuZm68TFXQgr6vvcNj2n00VBhw6EfOtr2DMA8O8ZxwM4zqZBM2jCN07oNApAKwaQ1kzH0w4CUPgJJKu/WKMqKR48f49wSNiEkZeEbLtM0Yo1hs92/Qjg9ME0aleXY8Bptt7vVY3F9fYVSGbCsUU533g1rDFIK5tlwPp+ZjEZKgTGGNJX83M/9q9Ackmw2DU888QTWWm5ubklIWFhQSgZxt0BI4a+HIOb+NW9/O5vtBj1p/97Y72k2mzf4HR6JRCKRSCTy2sRGQiQSiUQikUgkEnldtlsf8ZNlEqUy5tlireX5n3+ex48eY7VlnmfquiZNEtr2zNXVY/q+54Xnn0dPE0mSstk0LIvj8vKCoe/Z7w/c3t4yTROHi0ukFGy3fuvg/oP7ZErx+NEjyrJkcc4XYlOBUhmHwwVFWfLwpYdYY8lkxul4ZLYWIQWHwwXOLWRZwWwNee69B2mScjzesiwLfd+xLI48L7yrQHl3wna7o6oqLi8vSZOUvutgcSglKcNtZ2MY+p7tdstuu2Ua74r4LXmeobXmdDr5vP1xxBi7ug2sNaEQnZJlGfv9nrquadszSZLQti3zbP1Uu7XhWHtUlrHZ7Hwkj7WcTqfVleAfw0/kV2UVGgkmSJLnELOUhQbEhDEWrX3jx1rDMAwcj7c8evSQPM+5unrsHQdJQp7n3Lt3P1wNfnsiy/z5XMJ5ybOcZrPhdDpR5MX6WMviyLK783HGWsNl2ISYQ5zPdrdnWQiC6RljLFIpkjSlKEsfmyUlw+g9GtpolsVHXgmRIqVgs9nylre8he12R1EWDEOPkD666OLikrIqyYuc0+mEEJK29W4FrX3Dw1rL6XTmfG7pu566bnBuQaksRCcBCZRlgcoEZVV6wXPiPQ4JcH1zw6NHD8myHCFS6qZBCMFmu+Xe/fvhPeSdEkWRkyRwPp2YhpHT6USSplxfXWGs+Ty90yORSCQSiURenRhtFIlEIpFIJBKJRF4XX/BWnM9nDodLTqcjaZrSLj4GaMHR9z23t7c0TYMxhsPhwPl8ZlkWpmnyOfRDT7OpGYcBqSRJ4nPtHzzxBEPfB8+Az/D3Wfcph8PFOjWvtebm5gZjNEVZheJ+RpJY8ixHSomxlslMZEWJlJLFObZ1TZKmdG2LkooyL3Dz7N0PU4iiEWnYrkjC1P7kZb5ty73Le+x3ex49fMh2t+fho4cURYk2E3VVcT6fyfMMISVKXtJ1HUII6rpeC/lCpIzDyOXlPa6uHq9uBynlevtl8RsQZVlSVRWzm2nbFikleZ4jhWAKWf5CSjabLUIInHNByjzz+PGjtQA+z775crdFAL74nucFXdeSpmL99/l8JM/9ZsTxeGSeZ3a70su0p5Fh8M6KttXrY+52vgHS9z1jaBaVZcmkNc45hiDQLkvvm5gmv0Uwjndi6X6dvrdWkyYK4zQPX3qJqq6RUnI6HTkcLpjnmbIoQ3MoR2U5t7c3yBA7NE2aJEmp63qVdAshWRa/QbMsC13XUxS+yeDFxl54bYzfikiTFDMbZufIktQ3WIyhrirSJMEtPj6rPZ8xxpDnOX3f89JLL+HsDAuQQFKETYerK87teX1tt9vtGnOU5bnf1MlzzueWJEl48YUXyIvSC8AjkUgkEolE3kTEjYRIJBKJRCKRSCTyusyzZXYz2+2W0+k2eAA0ea7Ic8WTTz3BU089xeFw4HC4QAiJtT5C5nA48ODBA+bZUlYFQvjJ+KIo6LuesixJk9Rn0p9OPHr4iJ//5PNYYymLkoXFF9KDqDlNvSvg+upx2GTwUuM7wW4qBAsLZVHQtWeS2bDfNFhr+aIvepoiRNccDgcWtzBNI+ALz+fzCRe2BtI0xWiD0Zqh70iThO1uxzgMKCnRemK2M7D4x01Tuq7jeDqy2+2RUoYifYYI0l47z0yTL6Ifj8d1W+F8PnN1dUWRF+ggIZZCMo4jSQL37z9YY5DyvGCz2SBS4f8W4uWJ/+MJIPgTfDzSy+LjAWM02+2OPM+p64bHjx9zOp04n09M40RVVgx9j7WWe/fukyQpp9OR4/HIMIz0fc+9e/fCloFCSoHWBikkeprWuKU5iKXzoqDvB7qu49GjK8ZxwhjN8Xik7zucm0mAuq7Z7w7UTcM4jlxcXpIkcH11xTw7jrdHrq6u1s2K3W4XNhEk0ziRheaQTMXqlDgdbzne3nJ7exsaWvjXwM7Ms+Phw5c4Ho+rCFpISdudac/nVVjd9z0sME6TFz8nCbfHI2kqGIaevu9J04S6qhBKcLg8kOUFp9PReyimgcvLSzbbLcuycDqdKEvvCTFaI9KUzWa7fi1NJVlekOfF5+29/tr8JC/+22/lX3/LD3L+fB9KJBKJRCKRN5S4kRCJRCKRSORNyLP8zXf/Bd7/GrfIDg/4d77s3bznPV/Dl9z7//azK+/4Fv7Hv/o1vAXg4Qd477d8L/8MIPtK/tz/9G18xWvUcf7Z930z7/37HfB2/vj3/iXe/eBVbvTwWd7/v7yff/i/P8snbkw47l/Nv/tbv5rf9zu/hi/5tJ/RP/E3+P3/9YfRv/HbeN+f/0qa1zr28aN859f/NT5UvJu//v3fyK8Vv8DnHYl8jgjhY2yur69IU4lzDpaEsirI84z/69l/xtvf8XaKouDFF1/k8vKS8/kUMusnNtstwzAwTvhYmf4x1hp22x394KXKRVkw9C2bzZZ793LsbKnqiqurx+RVzc31LZkSKJXz4EFOkqQMw8D11WOMtZzOLWVZMg4jmVTocQqy3ZmXrq7ouo7F+SaBlIL9Yc/pdEIKSde3bLY79ocDx+ORuqqoyhJIvFS3LLm5uaHvBy8eTlOSJKFpNmQqY8kcp64NX2s4nY7hvEmUyhFCMmlNnvu4n+3WNwCkVMyzxQTZc9f3bLbb1Zvw+OqKsiw5n8/r7Xa7PWnqNzeMMYzjiBCCMhzvnadBa4vRmmbTUIaoH/BZ/uM4YK3FuYWLiwPH4y3bzYaqKHjx4UukQuDczDiO5HkOJGg9+XihoSdNU+bZS7OXBcZxQCkFgArbE8MwsN1uub29wVqL1jpsCCwURcYwDAjhN0j8ZobghedfAOD5519gu9mQFznjOCFrSVmU9F2PnkYKmbE/7Bm7gW5qmSaNng1FnnO8OZOmKb/6i57mueeeI8syskwxjj1pKsJx+ubUk08+GeKWZiAly7wr404obu28uikcCcZYqtILnJt6wzAMHA4XnLsTC+BYKEsv5F4cuBm0NuRZxrHv2e33QRDu/xhreemlF9Fac//BfX7+55/ndDpSb17z/wBvLPOJ4z/6Efr3/SDzxz7iI57+0Z/g9it/gNOX/4eo9/we9r/pAdnncFf9Jz7I+fv/AebHfozlxYfA20h+/Vcgv/4PUr/7N7LJfzGP+yHXP/iDjP/rjzB/+Cf9197yFaRf/nXkf/T3sn16+zkd8xt+3JHILyee+V6+9s994DVuoDg8+Q6+7N2/l2/6undyEK/83hfqZ3rDR77rm/iLHzJ86Z/8Pv7iV9Wveeh3n/+z3/WXeN+3vv1zOGcv82v/8H/HX3/VA45EfmmIjYRIJBKJRCJvYt7Kl777nZ9Z8NYP+ac/8SzPfOB7eeZDP84f/+9f7UO/4vDkgdf83f6+evXv64/y4X9i+Ip3qVf/ufln+fD/1r3GHXd84u//Nd77fc+iUTQP3sFXvfutNBhe/D8/yj/94e/lYz/8/Tz9nv+S7/z6t68Ng+zLvpZ3bz/M3/vJD/KRm6/kaw6f/RH0P/4oH9LQ/I7fzK/9lF+6/g2edyTyGgiRcjgcUCpjHH2m/vX1NY1sKIoSqfw0/3a3JcskNzc37HYHhBC07RkpUm7HnmVZeMtbnqK/ukII4TPvE8HN9WP2uz1PPfVWkiRlmib2hz1te0YbQ/v4MYfDAas1YFBK0fcdXdex2W4pywqRCsZxws0zeV1htKbve+4/eMDpdKTZbEiShO12y/F44nQ8kaaCrmsxWnM63iKlgmXxE/Zak6mcsiwxxk/1O7dgrWWYRoSU6POZNEmo64br4y0AUkh626P1xDgO3N7ekGUZTdOglKIoSl588QXSNGVZHHVd0zQNbdvS9X5Do+/7ddtAa43RhqapmeeZq8ePWEiABIA0hf1+v4qOkyQlzyV5XvqIpnEiyxSQMPReaj0OA1me4ZxlmibKsqRrW5qqxjmHW1w4nyNCyDVayRi9Pp8kSXHOuxu0nnjw4AmGYSDPc47HW8qy8p6CEIPk3IIQXni93+9Dk+nlyCpjEsrKux1ma7l3/x5d51/j2Tl039PTU+aFj706nrDGUJcV575jSXzRvq5rnJs5n89kmaLrWqZJ0jQNzrlwDfjHf+H55xFSYYyPt5LSP9dziC7KlGK73dF1LVePH3nvwzCyaRpuTzf8ire9jReefx4pJHM6swSB8m67xTloElbnxZNPvZW2PQd/gpdhSylpzx3zbHn86DEpCZvdlmEaPz9v9E9j/Nkf4Prr/zPmm1f55osfwf3QR5h+6C/w0n/yV9l85x9kX32WO5pPPP4r38rwfR/5tG88x/LTz2H+9A9w+xe+gva//R+4/x9s/40LFZ/1uMMxDz/0Zxhe75g/D8cdifyy5Vf8Bt79Gz6z4K1fepaPPPMsH/juZ/nQh7+F7/7OVxt0+UL7TK/4iq/9WpoPvZ+PffCj3HzVV/PZP9IbPvbhD6OpefdvefunfqvY85bDa7c7L8rPtR0aifziEP8/F4lEIpFI5E3MO/l9f/hb+JJX+9Yf7fjYd7+XP/cPfpbv+Tsf5Wv+5G/+tMnCr+bbv/uz/Oxrsa1pTh0f+vBP8d53ffp9Bj7+UT5wqmm2He3pM7/94vv/Mu/9vp+FB1/Nt//lP8JXfcrvTX8EHv4T/uZ3/FXe/z//Wf5Q91/wt//wO/3jiLfzlV9V8/d++Fk+9JO3fM1/tP8sB3nLhz7wYeCt/MH/+NN+6fiFPu9I5HWYppFlySirknTysTl3xWA7zxRFTtu2lGVBXuRrpr3Wdo3kKfICO1v63heGy9KPCPrM+wytR4RIYVnQ2nA+n6jqmjzP2Wx3FHnBSWuM0YzT6CfeN1vqqkYb7Yv8s5983253/L/svXmwZFd95/k5d99ye+/VIiSXGstAiBBuiU3gKoZR2RMFdBRGEm1D0GC6aWF7TKtNmLCw3ZansWlbPTiMGbyBMZg2IYyR1XaNBbKbkoEq00KANCMNBNgyRqio9b1c7n7PuffOH+e+LC21CCGVJOt+IhSRqcy8eW6+TCnz9zu/72e6sc5oNCIvcmzLxrRMsjSlKAqUqhFC0DYtvh/oAnQQUsmSYddwMA0dX2QYgrbzFliWzfETJxAYNHWDYZlIKUnimMEgQpgW6+snsCyLIPBJU+030Dv4a1xX5/KvrKyS51rom+d6TVGkpzbqutbTCCdOLHfIKyWRSuomQ5pqf4ProlTN2toKs9kM0zQRQpClqY4wGk1omgbP97rYHIMgDPH9QE9ntLB16zZkt/teGgZZrhsZpmWiaqWlzrXela/XGHYTCTpOybL0pEoU6ego7WlQBEFIVVVEUYRlWkxnMwxDJ+sahkkcayFzXZ90QDiOQ9M0lEWB53mkaUpVlcvzEkBZVoyGI4qypMgLXNdBqppaSRxfT8fkhXY1FEXeCbRtqqqkbXUTaLO5lWUpo/GYLMsJwwjT1JM2J04c764bPOO8Z3D4yGFc1+fokSOMRyNWtq/QKIXtOvrv0EmTm6ahbhqausF3A4oiZTqdsmXLFooi5/jxYxiGYD6fURQFQRBQVRV5nhMEulk1Go9wXIdKlk/gp12j7r+Z9de+gybr/sXFr8f+iWfRvPNd1M/7SZyXL5B/dCNtBnzqHcSlh/l7VzIwH3qkko33/BvyD3dTAWyF3Vfi7P1hrMkc9Te3UN18M2QHUW95OUd/4y/Y9todj7pY8bB1T3ZjvuEqnBduhSP3UH38I9R33afX/I3jNDdfy8opmwnndt09Pf+s+cG9/MxbLznlTW9f3Mnv/MdfZ99XP8off2E31z2s6P8U/E7/nMvZM9zHTXcd4IvT3affHDT9PPs+B1x4FXue89DTvpaP/PSpX7OenieK3pHQ0+0IlCUAACAASURBVNPT09PT89TEDHnR1VdzMVAdvIevPlbHPW83e14AfO527jjNhtCv/d1+kuFu9rz4FDd+68+5/gPfoFrbw7ve99AfHB1bL+Nn/ssvsHcNpvvexx9//eRNF7/iKnYAd336do6cbo3HbufTdwGX7mX3Bd/FufX0fA+MxmOCMGA63SDLM8qywDBM2qYlXsRMJitasltWhEFEXSuatmEymRAEPgh9jOFwhFI1pmEghAFC4Lou559/Pjt27GA8HuN5PqPxWEfLSEnd1CAEs/kMKXXR27EdbEsXudfXT1CVFYvFjKosMQyD6cb6Mr4nyzLqpkZWFRsb6wAoJamqsnM1+Gzfvg0pSwwh2LK2hiEEbdvgeR4rK6t4nteJhhNs28Z1PYRhdOLckqIsSLOMEyeOI6uK7dvP4/zzv480TbqCv44lSpKEjY0N0jRhMBjQNg3z+QIhdHHb8zykVJimjRC6gG5ZVlesH+C6LqPxmLquO+9BQZqmFEXOxvo6G+sbFEVBnmtXQVmWy6aJZVlIKTtfQEO6KQGmxbJ1IR9DT560rd5Jv2XL1mVkUVWWtE3LoFuH0XkfwjBkNBp1Uxsptm3heR6rq6sATGdTBoMBa2trnY9CRz6labr0GUgpUaqLi3AcLNsiXixomrabGJFs2bIN27HZmG7oyQ7fAyGoqgrbcWmahqqqlk4Gy7JRUmHZ9jKOqmlayrLqJNQWjuOysrJCWZbUdQMIPM/H9318z2c6m+oIJ1WztraFum5Jk4T5fI5pmkynG0ynG0uRsue4tE1LS0slK8yu0RQNBpimxdYt2/D9gLIsWF9fJ8sy8jzHsnV81pYtW3Achwsu+L5z/yF/EMfY+JW3dcX4rRjX/y2r//09bH/tC3URYeV5BD/7HrZ/5hNYF3UP2f8u4r9+eCUu/u8/R/rBrhgf7MT+k89y3geuZ9venazuehXb/vP7OW95nGM073wb6197lMsu7+HEW952sonwyvcz+p//jWf87JWs7drJ2mt/kmd88m8ZXH+lvv3eG0h/aT+n2o98Ttfd0/N0ZngZV1/1bEBy8O6vn/Xuj5gn8ju9+Wz2XH0+cA+fPnDstEs8cmA/dwGXvuZl7PiuTq6n54mhbyT09PT09PT0PHVZ3aq/dFeP5UG3suvllwEHOPAl+fCb63vY/6mU6Ecu50Wn2Np01y03cR9w6Ruu5tIzRaKGl/ATb9mFw4x9f3X7yVO44GVcfSnw9U9z8P5TP/S+A5/ma8AVe152hlHpnp7HlizPyfMC1/Gpa4XreORZ1olqa2zbpm0FaZp3UTeKthU4ji44u66LZerGg2VZuLZNrRRhEJKmKfFiwfqJDTbW10mzlNl0gzhOSNMM13Ep8oyVlRXg5HSA49i64Jxof4BhaJ+BlCVlVSGVQtUK19F5/EqprohbYpqWnkgAlJRYtkOSpDRNy2w21zv0u8J41p1nVVYopWibFtUopFI4toNUCmEYJElGWVZIpWN1/umfvsm2bc/AMIzu9aF7XmMp/c2LHNf1qGu9U35z978WMmvhs2Xp6Y+maVkstA+gadqlv8DzApRqsCwH17MJo7CLMqLzJrQIYXbPr/P/PS/AdhyU0lMHUkrqpkFKSVlVusnRaqm153lUVYXr+czmc1TdLN0BRZHjOE431VFh2w5xnNC2dCJife66uaFdGINBpCXUnocQ4Psujq33cZumwLJN8kzHYOn3joffTXc4jkPbthxfP9E1kdaRskQ1etojL3QjqW0abNvGMAw8z0PJmrLUEU9VVS3/fdkJoofDEVmWIkTL6uqKlokrxT/8/T+Q5xmWZSLLAsc0SeK080KUGMJgNBwBMI8XIASWYS4l4p7n4nou4/EE0zBJ04yqrAjDCN/3WVtbY7Ki/0uepAmqVpimgSyf4ImEez9D9dnu8ivfzfhNzyJ42KQBWFt2Mvnla7trx6g/+ZkHS5jre8jee3N3ZSvmDX/I9pc8PALI2rKTLb/7ni6s68tUv3vLKYv7ZyP9648g7+2uXHQ9g/deyfBh63YZv+k38d/QVQX33UBy90Puco7X3dPzdGf7M/TOmKp+LI/6xH6n33HFXi4Fvnbr7dx3ygce4uCt3wB2sXfX6aaQe3qeXPSNhJ6enp6enp6nLNXdX+EgwHMueEzFwZOX7uYK4LYvfOXhPYq7b+fWKmTPDz00UgjgG9xxQAKXsefFZ/9BEL3wcnbSTVQsfziNefHLLwEOcesXD53iUYc4+OlD4Oxi1wtPk/fa0/M4ICtJ28CJEyewLFtHCxU5pmng+z6LxRyn212uVI3n+bRNy/r6Cb0LfqFltEZ3f8/3qZuaqix0cbcsOXr0MGVZkqXJsoicpim24zAYDJeF6cFgiGmaWmRs2YzHE9pWS5Q3C8BB4DMejQnDiCAIsbr7CyF0BE1dU8kKIWARx5R5wXAwQrQC0zDxg5Dzd1yI5/lUZYVlOfhBQBAEIEAq7WlIswyrayYYhkkUDR6w678lSWKCIKBtW5qmJs9T8jzH83zmm04FSwuAF4t5tzO+Ztu2bQyHg2VDQCnJsWNHSNNUTzAAruthGNonMRgMcV2XMIyWO/rrWmFZFqZp6TipWvsYdESTSRCEBEGA7/usrKx0TQsL27ZRSpEkMWVZkCS6NBwEAXXdUJYlYRh2HochaZqyWMwZjUbYtr2cMNAyZl3Al1JHTgl0lNVmfJNhmIxGI4bDIVJWxPGCIs+xHZswijAMo3NJtNi2TVkWWLbNYDgky3N8P8ALAoqiII7jZcTQcDTC930GwwGykghDUJYli8Wctm068bOJ7wdsrJ/g0P3fpq4VtKCU6uKoBH7gL4XYURQhlWI+n+n3TFVRScnh7xwmSRJmsxlFkVOUBYZpcOTIYRCQpDFJklCUOVmuJzZWVlYJwxClFHWtm3Gu63L//d8mzwuyLH9iPugd2Tfu0VJlwHj5CzlTDc176Y9gTV6AeN7rsZ43Wj4OgG8cpNpsil/680SvHJ72ONZFV+G9obvyqRtJvvXdrnpBtv/G7vJWrF9+M+NTND80Lmtv+vmuAXAP1c0HedCG5XO67p6epzuSu754OwAXX/DYioOf0O/0k+dzxaXAt/Zzx6k2B33rdvZ9C5wrLudFZ5BB9/Q8mejj+3p6enp6enqeetSS++6+id99960kjNn7b3adopFwK+/ce+sZD7P3Vz/Bz5wqcNV7Prv+F7jtc7dzx3+4nJ0P+HJ/1xf2U513NXueAxv7H/K4xTHuWwBsZXL6msMDnueZ/MD3w23/+E2+vQ6Xdr+dJrv2cMXv3cNtn76d+6666sGjzl/dz02HIfrRVzxoXSf5Hs67p+cMlFVJ0zS4rruMtVnbskbT1CzmC2zbxRAGq6trVFVJlmUkSYwQgvF41IlsbZqmwbaFjiBCdLvUbQzTxPMCWqDoJgZsy6JpIS9KbMumbRsMYzMGR3XC5QzbcSjyjNF4TJokeJ5HnukM+hMnTuB7Hrat8/c3/QCOo6NkiqKkaequMWAxSxPKqmKysoJhmaSds8AsDR2xhACxKToWWKaNUjVFl5VflhW27dK2grKsMAyLPC+7Ynq13JEfxwmWaYALVVXRNDpqpygKfD/g8OEj1LXCtq1lgZ9WT0m0TcN4MkEptYwGytKUpm0xTLoopUA3c9qWPCtBCB1j1LYIYeD77rIBsBldpIXIjZ66aFvaVouJDcNcRhFtegb0mmyyLCeKIoqipMgzVtdWWcznVJXEdRz92pkmQhjd/QrtLegmA9q21dJh2+okyTpOqmka2rahbcGxHVStQECtahzHRUqJaKFpFSvRiEWSLL0NVaXjp6bTKYMoouhk0oYhCLqmQ9tCXTf6b+K4RIOhnhDJU/wgXDZoNqdFmk6ibNsW467popQkiiLSNEEYBn4YYpgWDQVlWeEFAaZpghA0NARhiG3ZVLKirCo8z6Vt265RUesmFbCY66bcE0mdnoziEOFZKlzmCzjvjr885U3x//elk8d59U7O/L9Gl+Albyb/2EeA/ag7j8GF301R8e+p921evhL7RWd5DS96HvYF6IbBJ79Mdv1ONs/03K67p+dpTHGIu276ENffksLaHn5i96k+O0/V7/RjrnjVLn7nrgPsO3CIq193/oMe8rW/2ccRQq5+xWn8Dbe8i1fccqYn3cNv7Ou9aD3nlr6R0NPT09PT0/Mk5iw/HLxncvX/8Qtcc8p5Y5vJeRPOVEaITvmtXT/2RS/dBZ87wIEv/TQ7d3U7/4vbufV/SLb/68vZAWw89GFFSgLf1YSEc6qhAu9yXv3KkNv+Yh+3fvUqrnnuyZu+9nf7STifa15xqt1Teu2P/rx7ek7P6uoas+kUQwjSLCUMAupasXXrVsqiZGNjiu8H2LbNYDBkNptjmhaWZVKWFa7r4gc+cRwjpSSMQvI8h7bF8wOUlEi7ogWiMGJtyxZU3TBZXSPLcpqmpipLyrzoCtoNUTSgrmvS6Qa+HzCfaYntZLJCWeod6pvy36oq8TyPrVu34Xoe8SImjhesrKzhOA6z2RTLsTFsiyJNyMtC76pvG/Ki6CS9giCIdCHcMHSmvhCUVUUQBBiGwWw2I4oGNI2O/lGqRlYxGxsbjEZDHclk24RBCLTEcdxNEuiIJ70b3iGepxiWgeua5HnexTDpSCfdDNCTFY7jkKZ6yiGKIs7bfh73fftblEVBUzfYjoMwBGEYahFzlhKGIVJKPM8ljmPqumY+nyGEjqBKk4QWsG0Hx3EpioIwjJjP5ziOg1KS2WyG67qAXocQAsuxQMBgOOL48eO0TUPd1Fp4nRfLRlRVlUuJMkAcJ7iuQ9O0DAZD5vMZSimEEHpypCwJglDLqrsmQ1EUbFlboyhL5vGim84QVJVcRim1bbOcRJhMxjRNjZIKz/NJkgTT1NMOk8kEKaWO37IGKFVTVWXnldANLMfWTRGEQDY1om2gbanbhiAIdV+paZnNZ9SVIlgNUK2FZdsIodewurKKaZgUec5wNKIqS4QhKIqc1dU1HMdlff04hqHdGE8kZniymFffex+KSx5V8UDef7Igbz777AngwZZtrHeXm69/G/guCvLHj7Ic7nvJ8zh7L2Yr4iLgfiC7G3UENv/nfU7X3dPzdOAsRXHnWXv51V9842kihJ663+mdF7+CvcMD3LRvP1/712/k4s0pqfobHLgthQvfyJ7nPvxxAHhjtk/O9KU9PONr0tPzeNA3Enp6enp6enqexJzPi/ZesvwCXx29h9u+eIgqfCZ73/ZzXPPSrTinjS3YzXUfePS7dJwXXs4VHOC2L3yFt+/SO4WqO2/nYHU+P7Hr/FM/aDM08vAxpvCIfnhUp4hsBbj4h3YT/cU+bv27b3DNc7umQXE7f/mpFC68ihedVrL8vZ13T8/pmM02qCpJ27Ssrq1gWRa1ajh69Dh13TIYRGRpzmAw4NChQ3ieh2kaXb5+iWGYxIuEIAxYzOe6UG3ZOuKoK9CapkVDi+e6xEnCYDikrEriJGY0HFLmWZfLr+OQlNLyYt/3cVyPqixYWd2CkvqDZdsWpmks44J0fn9MWenpgSJvlwVtvStfYFsm2sMAaa7jZVoEwrA6J4PdRRN5mKaFUgrHcVksFloibZo0dU3dNERRSJJ0MU1dUbyuazKZ6emMtl0W09MkoZKyiwpKcH0Hx3Eoy4JaSVZWV5GVpCwKnAdMhZimSdM0jEYjVK34x29+kygaIIRFUWQ4AkzT0GchBK7r4LoueZ5R13QRPrqgLoSWEVeVpGnbZRNGNwxagsBfNjDapu2ikvyli6CqDJI4w7bspWDaMPT7xLL066ajr3SskGVZ+rmamiAIUdWc6cYG48kEKXWEkOcF2LZe7/JvaljUbY2qdRyQnqLIKIqqi1wqaNuiu6yFzrpxYC7jiiaTMaZp6rglAfFiwXgyoSiKLtqpxjAsbKtFyorhYEiRZQjDoMoyPM+jbVqSONbTCq042TgS2p/RNi1ZUVArhet6ZGlKrWqEMPjOoe/g+R6WZTIe6+eVUjKZrGCaJkmSnPPP+AMJnnsJG6Bjit77i5x4yZ+x/YWPomRVPmCy4butPtx7lASIHun96wd4Jb7rpX6J5gGNhHO67p6epwMXXMbeyzYbbJIjd36eO+6XRN+/h7e/803sPO9McZ1P4e/05rPZdUXITX+xnwNffyMXd02D6oufZt8Cdlz9/NNLlndfy0d++pJH8Mw9PeeO3pHQ09PT09PT8yTmEq5+61v4me6ft//yb/GXv/dGLpbfZN9vvYsP3v04Kg2957PrChs+dzt3FACSO75wO9WFu09fxF97Js8dAov7ObJ4BM9RfJN/+EeAC9i++pDbnrub118Iyac+z13dFkv9owcufc3LTv+jo6fncaIoSizLYjgcYNsGQrREUUi8mHcZ9mi5sdK/pA3D6FwEirIsKAr9T5blpFmKZdlEg0FXXG+I45hFHFOrmmgwRBgGizhext9Mp1OSNEUYMJ6MGI91Hv9wOCKKhrRNu4yjAdFF75hUVUkURdR1TVHkxIuE2XROmmYEYch0OmU2myEMA7PzCYRhiGXZmN052LaNEDreKY5j8jzn+PHjpGmClBWz2ZQkTsjzTAuTm4YkXjCfzwjDgDAMGE8mCCFQShfAKym72CBDux0Ax3HIsow4XlBVJUrpIrswdASU63kYpkHbNksJcpZl2nMQBMhKkuc5ZVli2zae5+E4Dl05GCklUur7WJbNeDRmMBh0UmAf13HxPR8/CDBNfe5pmizjjspOAByGEbJb22bUkeO4VKX+27ueg2kILFM3KVp0w8J1HYoiJ0kSlFIEgZ5gsW3dMMnznCIvmM8XrK+foG0hCHwGg+ikE8N28TwPz/M7J0ZL0zQ6+gl9uapK8ixfXnddt3vtFXmeU1W64RDHMdPpBmVZ4bg6LqksK/Jcxy8FgU8ltaDZcR1aWlRdE4Z6GkcqSVVLRqMRURSR5TlSSRzXJc0zWlqqUjeqalV30ytaBr1YLKhKvU7LsqjrWguoXY+iyNi2fcu5/og/mAv/Fe7ezaLfl5Gv+1859P79zKfFGR/2UOx/8arl5eb42f/HmB0/evJKXT7Yt3A2tuw4WeC49xhnd7Yeo7335GXUyVvO6bp7ep4O/ODe5ff5n3nrT/Grv/cxPvDvn031j7dyw3/6KHc9npbyJ/g7/cWvuIodpOz77D3dv+men0u4+orTNDJ6ep6k9I2Enp6enp6enqcWF+zlV395D5PqGPt+9dfZd/jxeiKbF730chwOcOBLEoqvcOA2yY7dZ9g5hN51BHdy6xdnZ32G6s7bOQg4V1zGv3zYZMX57H7NJVDt59YvSmDGbbccoHJ2sXfX2aVvPT2PNXr3u8FwOKBtWpqmJc/zpQvBdV2CMGSxWCxFvJ7nUXb59L7vo2qFaVmoutHS3kIXbZVSgGA0GtMi+M7hw6RphpSSLMt1hr5pEQZ6j2/e7QzfLGwbpoEwBI7ropTsBMMmdV3j+wFVJbEsm8UiRhgGjuPSNC1lVdHQUsqKLNNVDKlUl+NvYHS75geDiKbzI5RlSdu2OI6DaVrISlKVFcPhkCiKMAy9Yx8hdLSQ7SCElgWH4QDPc7WkOU2AlsFgsBQcTyYrNE3LZDJZuhE2myVVVS4F1EIYnaS3RkqJaZqsr69T1/UyVkl2jYqiKBgOR0ipNZOWZXVRSbCIFyilkFKymM8xTIO80FMYUTRgOBziuh5xHDOfzzvPgEGWpbQttG2rJ07KkjzV8USe62JbFtu3bWM8mVDXCsdxlg2N4XBAGIa4rkuW6QkTy7JomoZt27ZhWhZSSoJARzFtvj88zyUIfMqyQHXuiDzXLoKiKLoJDZM0TXXzx7FpW13O3RQ+V1WFbWsfwWKxwOjeC2WhY5fKssJ1dNPBtm2UrPR9XI+8KMiKkrprnuhmk4mUijhNkFIyHIywLJvA8zERKKkIPJ9a1gi6iRRVd40cE9t2iKKoc2Tov1meZTRNy3z+SCpXjydDtrz7D7Ev2rx+H81738jiRT+GBLj3M2T77mGxKB9Yf38Y/oU/sLxc33E3Z25DlOR3nDEQ/MyYWzBf0l2+/wDl2aTH37obeSoBKud43T09T1N2/Ogv8K5XjamO3cr177qVI2fv/j1KnuDv9Be8jKsvhep/7OdgAUw/z77bJM4Ve7hi8r2cV0/PuadvJPT09PT09PQ85YgufQvXXzWG6hv8zrv/nPsepx8ezmWXs9OB277wFaZfup3beDZ7TzcC3XHxq1/HxcBdH7vpzLur0nv44AcOUDFm7786tWRt8oJdXIrk4Be+QjX9CrfdBdErTydZ7ul5fFFKMR6Pu93xJceOHuPIkaOAYLKygh/4FF2Wf1mW1EqRJDGOY2N3cUCBHyyL8JZtMZ1OdRE7jqkqSV1rHwEIKimpKsnxY8fw/QApJbP5rIuygflsQRAEOI6j3Qh5Tp6lOLaNbVsEQbCU2B4+fLjLzne6XfkVvu9TNwpV15RVRVGWLJKYsiwRAubzOVLqXfee5y+fy3G0tFkX1DOKUu8wp4sQKstyKfV1XZ3nn+dZF5cjWSxi4iQhyzLKsmIw0IV/IQTz+WIZVzQZTyi7mJ221W6EqqyIogGO4ywjhvTj5ggBqlYMBpEuwHdFetCTCJsTIpsTBEVREMcLiqLUjRrLIooiHMehbeliiXQjJQwjDMNEKYXv+6RpuoxIOn78eNdYaHFsC891cB2bKArxPLc7XkPZTSI4jkMY6hBsWVXdc5vkWUaSJDR1jZQVa2tr3SSJ6iTZvo4Taluqqlo2IJI4wTTt7jUQ2iHRNMsd/lE0IEs3Rcx6SkPHOZnLqQghxLLZE4RBJwyvtAskDCnLku8cPrKMotp8jwth6CmQoqRpW6bTDZq6IUsSHMtBNC1pkiJlpcXRTUscL1BK4roevu9RyYqqKqlVTZZlHD9+nHiRMF0/e+HqcSd4AWt/9re4P77z4bfdfzPV2/cwf/73c/i1v8TRA8eoTnEI67JdWEF35aO/z/zeU9ypQ91/C8VHj53+DmdlB94rd3eX91P90cEzNABK1v/kI6edHDi36+7peboSculb38HVa1B99UNc/2eHHrdnemK/04958csvgep2DtwpmX75AHcRsvd0kuWenicxfSOhp6enp6en5ynJxW/SPzz41sf5tcfrh4f3fHbttOFzt3LDrQfgOS/jRWfzJ27dw3VvfTbOiVu5/trf57ZT1RaO3cnv/OKvs+8ETF51La9/zmmONXkZe6+wqQ7ezq2f0z869vzQ6STLPT2PL3qHtuwkxQlBEOH7PsPhgLpWqFqh2pr5YoHsdnLXdYMQ4Ae+jvIxTZI4wbYtaqVwXAevay6YjgWmoG5qbNfBti08z2M4GuEHHg0tUTQgXqTUqummGNBxPwZYlokQBo7jUBQFR44cRamGpmmXOfqmaTLbFPkimIwn2I5NJSW242AYekd+EOjd5isrK1iW3UUNSYqiWDoFmqahyCts22EwiIAWy7IIglBPJCCoKsV0OqOqFLJSSKmjdQSikxjnHDt2jKqSKKV3ui+L3LX2LWixMtpv4OlYn7qul40M0zQpi4ymqXFdB9M0uwK+TdnFHxV53r1e7fLxUkrG44kWNts2gyjCtuwHRQXF8aLzH2hvRFFUywmGzWkJHSFlI5WkrKpOpCyJk4w0TXEct9t9bzMajljMF8upDqkkda2WEyWVqgijECEgTRPKskRK1UUspdoXUddUVcWxo8dQ3W21UmRZjuO4BEGIYZhUlSRNM7IsRxh6e+jm5ENVVcSxblqUeYFhmst1lmVJliZdnJX+uRyGIZ7rUXQxRVVVaVE4grbRTRJVVoSej2UY1LXSjR3V4Htarh34Pr7v4Tjusqk0m88QQFVJhCGIoojhaIgwxBMuW97EGj6Lre/+BNvu+Fv8696Msf0U/xO86yNUb76MY+/cT/zQxr67k+AdDyju/++/xPFTTAqoxZc58Za30XyP6x1e+VMnGwAfexvrv38P2Sk2Gyz+9OfIPnzPw294gtbd0/O0xXw217xzLxPgvo+9hxvPNkn0aHmCv9NPdu3hCkdy8Av72f/Ze2C4m12n+/7f0/Mkppct9/T09PT09Dw16X547H/HPv3D46W/xesvfOAd9nPDW+88i2/xmbz+v/wce9ZOd3s3Cn3bAe66Cy79j5c/Itna9r2/xvv93+S6397PDW/5PL9z4SXs/MGtOEiO/L+38/98K6XC5qLX/Ro3vOHZZxAy2ux8xSuIbvs0H/yohAvfyJ7nnu3ZH4vz7ul5OLZlIwxI07RzIrT4fkBR5DiOx8b6VE8gWHa3q96irCoc19d5/OMxZVWhaoVv66gYLZd1MSwdQ7QpmDWEwPV8ZCX1DvgkA/Qu/yLLMQzR+QMa4njByspql32vM+5By4v1rn2H4XCIUkrLcGuFg0OSJbi+i0AQ+AEI0e3W1xMLOlZH7+pfX18niiKSZIGUsovHUYRRgO97+v6N6Ir+RichjnAdF6kqFos5eSEJw5AwDFFKi4S3bt3a+QUcyrJidXWV+++/n9HoGTRNw5atW5jNZtBC07TYtqN345smqtYC3zzPCcKQttXiXy1GhiDUngPHcZcuBdDFdM/zGAwGGIYAWjY21rsi/5ysyAHtYUjTFN8Plo0LIQRVpac5XMehaXVDJ/B9bMchSRIGUaTjqCqJaVkYtoCmwXMckjSlaRs821tOWjiOA61+X0VRhGVZOI7DbDbD8/yltHsxT5lXElU3OI6L6zhL6bVUaunHGI9HjCeTpYfBsR2CIFhOMdi2RZbluK6Hkg1+4JPlBU2jRdjz+Zy2bbrGgkWapkwmEwbDiGq9xOkaTotFSaMkURiSZymmYTIcDjhy9KieerBtBoOI8XjMbD6jLPXz6/dqxnCk46bKSsdibU7QbGysMxgMlo2yJwvO5FmsXfNuuOYqjvzAq5HPezP2D86R5IOS9gAAIABJREFUN98M+q1F+8k3Mv8Xt+L/1CUPKjSM3vBuygM/Srn/GNz7EYof3s+hN/wk9sufhenMUX9zC1V3HHHNdRgfvOER+A1OQ7CTyR9dx4nX3UDLMZr37GH9r17P4nW7sS8c0R65h+rjH6G+6z4IrsT+8RL54VPHEp3Tdff0PJ15zhu5/qrP8/Y/P8Qf/59/zs7fvoodD4oH+mfwnd67nFe/MuS2T32UP65gx7/dzcUPizV9CPvfx5vvPMvMwkVX8VvX7aZPSOo5V/SNhJ6enp6enp6nLmf84SGZHj5b1MCY6izbCJ0X72aPc4B91SVc8YJH7ibY8SM/x40v+Aa33nQTf/m5e7h1n5aQOpNn8i9/dDdXv3oPl55tJxTAcy5nz3AfNy0eqWT5sTnvnp6HoqcMhpx//vkcPnwE13VJ00Tn8g8ETdvg+wGmEEgp8f0AYRjEcUIltaNgs9BuWjYqy1B1g6obykoX/zcz7auqolYNUlVd4TrE7TLvwyikKguaRk8FZGm6LO5uFl8dx2EwHLK2toU0TToxr45aGg6GIIQufMcptmmhDNU1EbRjYLPpIKWOW7JtG9O0AL1LPIoi2ramrCRCgGXZ5Ll2QkipS4lNU1OWBZ7v4XmeLijPZhiGSa1KwiBEKYnve6Rpiuf5tG2L6zrLCCAhBKZpkRda/rspZkboiQYh9G5533eJ45jVtbWlG0J09wHI0hTX85jNptR1TdM0NE1N04DrepiGgef5JHFC2GX2W5atY4I6sbNei56C8H09YZJlGW3bYDsnPRBt2yIA3/cQwujcDuD7PgCWtJdTHaJr3mRZ2u3Ud1jM5wAYpt01bSymGzPCKKJexNi2ufRGZHm2FEsLBJZlcfz4cWzboWlqRqMVDEN7IlZWVpCyXMY6GYbAcz081yPLc9IkJYx008R1fYouVkq/9xVtqxtBdd1gmhaW5SArySCKiOczWpqlDHs0mmAIQVlVOiKrqijLUjemuokGHWnVUJUVdhe5tLGxTpombN26/UnXSHgYKy8k/M9XMrj+ek78xtvIP3wQgPY9H2H64+9hywOrWuYOtr73Exy97k1Un7oPuI/mY79E+bEHHnArxjv+G5NrShYfRBfkhyPOVmc7Fd4Lr2X8oZzZf3gfbQZ87Ubkr9yo3Q6bXPRmvA+8G++Oa9AhUpcgwocc6Byvu6fn6czFb3oHV3/uP3HTtz7Or/3Z5XzgdQ+MHfrn8Z3+4h/aTfQX+0geqWS5mHHkbC64oaQ8+5F6eh4zRLv5bb2np6enp6fnceUVe39sefnT+z7xBK6kp6fnkfBk+MxubJzMSV9ZOfeS7Qc+/5/f+PukSca2bVtYLPTkgI448jCEgVQSWTcoWdE2LdFgyGKho3Fc16VSkqIo8T0PP/A5ceI4UtYEgY+qa4bDIUePHiHwA/wgII4TlJTkecpgMMLzPJpaMQhDyjInCAMEBvO53rmu6ppa6fggwzC6DHqftmkxTIFSCqUkpmnTihaEwcaxdSarEwzToKjKpaBYVhKlpJYytw22Zet4nc474Hkuvu8ymy+YjCZIpciyjLpulrE3k8mEIAiX+fij0ZjZbEqW5RiGgWEYnfzXoqqqZVRQURR4XkCe512WvkNVlchKsmXrdqSU3X20yHrbtm3keUpZlgwGA4qioChy8rzQWf9lycbGBmtb1sjznLpumM/nTCZjoiiiaVos0yAKI2azOX7gMZ1NGQyGywijjY0ZURSSJPHSMdC2LevrJ9i+/TyGwyGe53Ho0CGgwRCCrWtbaTsh93w+YzAccsEF30ecJORlQZqmyxglpRRCCLIspSorWsB1/c6DYOL7nj6vvCBJUiYrK8vXU0rZNagEa2trFIV+fYtOoKwbGgKlHhwHZZn6b+D7Pkmads0BS08LDEccP34MaHVUVd1imMbSjdG2LVmaEfk+URSyvn4C1/P0cW2bRjXQQtvqaC3D0JMcUsmTvpDA05FQlUTVatlYmc9mPOMZz8BxXX7++hvO+Wf+7HxZTyS8/P2MP3QlAwAWHH/7yyn26UKf8Z47Of81p66qJV+6meSPbkQeOKgnGbbvxPjhK/GuuYrRBS7W8Vs49NJrdFTQNX/J9133gke9UrW4j9mf/gHlJ/fT3HsfsAOxazfW1a9n8KpLCE3YeO9lpO8/BrwK98AH2XqaLcrnct09T36eDN8Penp6HjlPhs/sufhOv1gsHpfjPpB+IqGnp6enp6enp6en56z4nk+RFxw9eowwDCkKHfPiui6u67FYzKmkQgiDNIvxw4CizDEtk0Uadzu5TYQhul3hFV7nLgDIsgzX9WiBtmkYDgYsFnNMwyAKAz19UOREQYBtO4RBgKobXFdnzusGgonj6Fz7JEkwDZOWljIpCIIAwzSxXXuZu2/ZFkII7QyoKgzTJM9zbMsmDEKSJGE4HpFnGbZl47ketmNjGIK6bjAQ5EWOUnoKwbYtTNPEcXTx3zRNBoPBUj696TsAluLgzaaArKpl/I7nuZSl3hHfNE3XmBmglCTt8vvbtiYMA/I86xo6/vK1FMLE90PyXEcTmZaJlDVCmBiG6CYszOXzGaZJVuTUbU2cxLQtlGVJFEXd39kC2m5KQr++4/EYJSVSKhaLBUmS4LseqpbYloVjOeRFTt0JmnX0UEGaxNSw3HFvmiaj0ajzT5gURdnFPXkYhsCytL8gTVMM06RuapSUy/VtRhi1bUOSJEgp2bJllcViTtM0SCkZDkdUlcRxnG66ALasrjKbz8iyXL+/fQ+laoqipKpO6GmKssAduxR5geu63eSEhykMaqn0OQiBqmucFhAGbd1oRwJ00uqapqk7H0S9/MdyHCzDxDQtirygkiWe5zMcjnBdnyDcDPp/Iliw8bEbKQ9+hvqOXQR3XMvKGe8/ZPCaKyn2/QEAzde/DZy6kRC98EqiF155+kMd+oelb8B4zvc9irWfxBru6OKYTnePY6ivdrucg+dhnSHn5Fyuu6enp6en58lKL1vu6enp6enp6enp6TkrizhG1Q2LOMayLYajkW4IlCWVrGgaLc9NsxTbdaik1MVyWtI0xXVdfN9nES/I8gzbtojCUBfwDdHt3q51Zr4QCEPQ0mKYFhgCwzKpZMUijnWW/WKBYZi0rUBK7RkwTYvBYLjMwod2uVseIZjN5uRFQZqlpFmK57k0TU2WpeRFgWEYDKIBw8GAwA+IwpDRYIjnukxnG/iBz2AwwPd9mq64D2CaBsPhENt2uuaKjtbZ9Dg0TcNsPmNzFtwwBJ7nIoT2PozHY+pa0TYNQgiSRLsOoihiZWWFbdu3s7q6ulxvWRbIqlquve1cBZueCb2eAVUlMU2TMAyxLAvXdbXQ2dRTEJvXleok0EIQBCHQUtc1ZVkCLWEY4XnadeG6et2WZRENBlqcXdeYpkE0iPA9nzAI8QMdJwUC3w+oZMV0NiNOE9oWgkAXyuu6JsuybiLDYWVlhdXVte69YC8L+LpJ5BBFEapWZGnSCbQNwjAEBEJAU+vpkE3XRV3XpGmKknIZV0Wr5dVNXeN7LiaCI4e/Q1VVJHGyfD2atqUqK8xuMsKyrKX7IQoDhCGIkxg/CBCmgZRaOC1lRZZnJEmsGx91jRCQ5Rk1DXGWUNcNLeA4NlJWuK7HcKTfu5Zt4bhnTgN/fJkhP/ku1F8fpJ0eQN579kd44WOzu3L2P/+qu7QT63mPJP/ve2BxD2p/d/nKF/C9tG7O6bp7enp6enqeIPpGQk9PT09PT09PT0/PWdEj2dotUFZSNw9EQyklR44eRdZ6d7ZhGDSNrpjbjoPn+fi+TxzHy6ijPM9xXQepKuq6Qakat5tOkFIy3dhgPp/pPH8asjxjHi+wbAfTsimKClpBvIhJkoTZTAtyy7KgLItlvr3tOJ1jIaCpazzPYzqdUtcNcRxTyQrVOQds20ZJRZIk3Tk01HVNWzcYhknT6IZImqbkedEV7puuiK6jfizLXE4S+H4ACKbTDUBPICRJDOjd+EVeIAQEgU9ZFgRhyGA4JIoi7K5wXdeKpnuOLMuWWf++r6OcNl0OpmlgWRZFUYBAi67LCs/ziOO4y+IvaZoGx3FwXIe6ixNyXVd7F7p11U3T+Qps7aqoa8pSC661h0I7FpJE+zFs2yYMI5RqWCzm1EphIIjjWEcjmTqyybIsDCEwhEGWpaRpgu/7Okqqi1DK85yyrKiqEsexKcuCula6EaRnVToPhSLNMpRSNE27nKzI8wLP95dRUWEY6dgtWS0bLZOJDu9P05S2aaEB3w8wDBNo8QPtcgiDkNFoTBQNuufXUzNSSZI4pqokddMAAsd1aQHTtnRckVJgCIJBhO3YOJ6DH4Q0tNR1g+/rJovd/c2GoyHRQE9XYAgaWoqyODcf7FOyA/slm8Xwg6g7z5ZNDvE/3b28bFz0gB35x/dz+Mof4/5dl/HtXznIGc+qvofy4/foyxf8MO5F3/XCmX74jdx/5av59g/8GEfP0gBJP3vLUo5svuR5eA+88Ryvu6enp6en56lA30jo6enp6enp6enp6Tkrm82B0WiMbbsYlkXbQiUlhmkilcJ1HEzL0jEuTYNhmjRtSxiGOqKnbTFNc5lpnyQJrUDv5C7K5Y7x+XxO2+qirut5qM49YFoWddvSAlmmBblxnJClKUEQYnTCXyG0lLhtdUG2bmqKUk8c1E2DVArbcYnTVBekO6FyXddIKUmThDRJMIXO0Xcch8FgSFmWzOdzyrKkRUuhlVKYpoHrul0skcdoNCIIAqIoxHEcLMtaio9BYBpmNzVhMxgM8X2f4XCod/WHIX4QLGXLSZroHfvdWvTURITnunieh+M4S0m1dgIEWI5NXujIniRJkVLhBz5VVVLXSsdBOQ5xnCCEbkIgtKS6yHMcR5/LphOgLLU/wnVdlJJkWU4cJ7Rti2071HVDEOgCPmjhclUVOI67FGEPowGu4+DYDrZlUSuF57qYprVsKJRliWVpTe3ma2OaFlVV4vvaxaGkLsDLqiJJ4uXUx+ZES9VFRJmmjefp9w8IHYtU1/iej+NYqFoxHk8oywJocR0HJRVBEOC6Dp7vL2OfiqIgjuPl+WDAxnSDpmm7aRdwXQfDECRZguU4TFZXWVlZBUNQVCV0HoowDBiPRtRKYZomQRB07/sKBMwXc/Ii102FJ5Bg5+uWl5v3f5j17Ax3ru8j+/gt3ZWdWJc9YEf+lq0Y04O0R47BzZ8hOcNx4k/+NtX9+rK45pU8mhkHd/sO2ru/DBxEHryP0yqrsy+z+M0b9eXgWtzdwwfffo7X3dPT09PT81SgbyT09PT09PT09PT09JyVMPBoG0VV6GL0Yr6gRfsOLNvBsm2KSkcc2Y5D3dQkacKxo0eWu+Jt26YsCsIgpKwqhGFS1zpZvG6aLr++ZWV1leFgiG1aCASu4+A6LoYwqJUEQ5BlBUIYy3ieNM0690IJQJ7pyQSAvMhpAYSO0mka7RdwPQ8pJaZpMJ8vMEyTwPeRXQyOFuzWuI7DIIrwfS1wtiwTx7a7Xe7tUvBs285SHtx0u9VdV/sOtOjZ1B4FS0t5N+/fNA002rnQ1DWClqLIcR0H3/eYTMYEvkfg+7iOS9g1KNq2paxKomiA73usrq7Sto2eCjAEpmnpBouhzwO0/LhtWpTSTYc01RMYhjAwLXPpeCjyfNl0cF1Xr71rfkCrJzhUw4kTJ3QRHD2BgjBoaJGyxu6kzLoBYqKUwvM9LVD29M5/z9N/Pym1w0C/pqr7u1jQtihV07bouKvueJZtEQQBpmliGAae5+LYlp50kXr6oCjK5dRF0zRkWc5sOsV3XVQlMTb9GFIiuoaR5538G0upmE43dFPMMBFCIITBfLbAchxUo2iBPC+wLJt4EaOUjjKaTmdszKY6CqoViLbF9VxMQzshmm6iJE1T8izTkyeqJujiv6SS5/Tz/VC8l74e59Luyv3vI7vuZhb1Ke5YLzjx7rdR3dVd3/tTRA/akX8J/jW79cXsDyj+ry+TneI4yf4bmP9S14y46DqC1+54VOsOdr8Kq8soat/zX9n41sPvoxZ/z9Gf/feo+wG2Yrzr37L6sCSpc7vunp6enp6epwK9bLmnp6enp6enp6en56yYpoFpGtR1Q55nlGVBGEakacJwOESpmjzPtWB4OMS2tcy3bdqlw8AQAqlqaBoCz2Mep3rywA8IAy3kbWodv1OWJYYA13awTBMphM6TL6subsigrLTwGSCJY6LBgCzL2NxhXhYF4SDCMk/+7BkOh130jRYhbxb9gyDAMi1aUWN3hWchYDqdYlgmhqEL1qZp0jbtcie/bZ/cm7UpUo7jeDmtsDl5oCOWfOq6JgxDTNNcxhW1bYNp6KbIYjHH6grabdsSBgFt2+B5HpVUuK6HYerzKAod5aRlxdpxMIgGJEnCIIoAA98PmM/nLBZzQKCkoiiLzpngES9mGELQQlfsz2mbejl10dQNlmV3sUqrVF2TRRfn284FoRBCF94FgrwoKPMCJfWue8M3mE2nuJ6HaVvUTUsrYDabYXSNiyRJiKKILEvZ9B3E8QLDMPB9j7puuoghHY3k+wFB4DObzVCqwrICgu51nU31cTenYBzH6RpIDZatm1dt3ZAsFlimnrwYDAaYloXjOCwWi+X7oq4Vtu1oUbgQyKoiz3PttWgUx08cw7IskiTp4qR88izHtLSHQoQRjVLUUjEaDslzPSkyGo2RssI0TY4eP0YQhjRNy2g8Jity4jg+B5/qM2DuYPW97+foq95GkwGfehvzOz9D9rPP01LhjW+QfexdLH7vZpojXfTR5PV41+0mfMihhlf+LNlH9yPvhfaDr2b9wOtZ/MSrsLe7tEf+Hvl//wHqwH36zsGVuB+6lpXTKCLiT17D7J1d4f7l72f8oSsZPPAO7k6i669k9s6bIbuZ8oe/zKE3XIvzv+3AYI767H7kn95I200YiGv+kNXXnNpp8Fiuu6enp6en558DfSOhp6enp6enp6enp+esKKWwbZ80y1lZXaEFHUVjWsSLuNtB3dI0DWWREwQT2gaEyDBNvdPddd2uMG0uo2aEQEfSSJ3pv76+jud55FmF73mMRyFtC7VS2KZFa2ifgjT1LvKyLAmCAN/3lxJjy7JI00wXw9NkuXN9M2O/rmsW8xmj8bhrKggd4yMEVd3QtpKqLLFti7YVmMLAcV0awDB0Idtu9USAdhyUy6mEzSigzZ3wZVnSNg1N2zIYDFks5jpiqVad10AXlm3bwjL1pEKtFI7rYpkWg2jAbDbVRftaTzs4hrl8PbQDQCKlpKrkSb+DqjFMuomPtmtc5Lids6IocuJ4ThBqEbJtOywWMXb3d3K710l03RFdLI91g8cwOplxjWEIyrJgOp3q8ylLHNumFZCXBSuTFZJUF9mbtoVKdJJkkziLl1Jhy7IIo4g8z1CqxjRNmqbGMJwu3ignz3Ns28EQBhhi6UIwhJ422HQxOI6LqrUDoqoqqrLEsrW4OfBdPVXTNtRti+c62I6D5Tgkady9z23tQKhralVjmg15nuu/dVUSRhEt4LoeSbzA9vVkyWA4wDCMpfw6GgwQ6OZDaZpYtoVpmJRFgWlYxHGM6zoMR+PO37GBkgrLMmmb5gn4lD8Y64IrWf1kwcYb3kE9BY7cjHznzfrGu99HdfcD7nzxtfh/dB1rW05xoOAFrP3JJzj+796G+tox+NqNyHfeyMNmLi7+Sbz3X8+WC763dQ9e+5vUpUf8KzcC99F87B0UH3vovXZgXPdBJv/ukge7EZ7Adff09PT09DzZ6aONenp6enp6enp6enrOihB6wsB1PSopKcuSNEsJAh8EtG3TTR0Y0MJ8Otc7sw0TIQwcx+6ic7QHwLH1LvFltAyC2WymC955unQOhH6AbVk4XZG4pV3GGQ2GQyxLTxaYQouAlVKUZUmW59RtSwPI/5+9d4exbVvzu37jMcd8rUfV3ufcR3dbSDYQkXVIRw4QsgTCkoVkkTixSMidkZEROjKJYyILElIkSyYhJiFFfe89Z++qWmvN53gRfGPN00hu7+vGvn3A45fcferWrrXWnLOkre8b//8v+JImsNxuN1LKmHIS3fuNeZ5ESBxEIu19wFjHukr9ktKGDFhjWeaZz5+/OzwCT4dCzhld/A/P5EHTNLKcKAmIZ73Tuq6kJBU9bduyl0oopTTGWlAav/siUjZS65QVOSVuHzc+3n+SNvd9X/wACXJmLhJh7z3Lssg1S4m27YrToEEpMMZwu32wLMshyPa7+AZSTLRtS9d2xFRcE+vKskjqQeqYMt7vOCeDfnEedDSNY9t3UIpMZllXYlmkpJiwxlKCG8SSfBCfhciM21J5BEh1U3ndbdvKvZWkRwheTvwrRdf3RyXT4/Gg6zuca3CuIaV4pEuaxhJiJCvFtMxkEmRQShUnhHzOGCNay4KmH4YidPY0jTve27aukDPDeOJZYSXVUpnxNGCsLu+poetFqP14TDymSaTN+07Xir/hKZPuOpEwqwx995eOt/+gdP/h3+eP/rf/g8s//cc0/8XfQf3qL5zeH/4D1H/yX+P+yb/g8z/7S5YIBfv9f8yv/9n/yuWf/HeYP/vTv+Rn/Ld8/+/9m3jXLS//1X/PL//5/0T7D//+//M9/62/g/lv/jHjP/8X/PE//I8YzL/6J/1h33elUqlUKj9vaiKhUqlUKpVKpVKpfJOc8yE+9j5gjaV1WeqLSr/795+/435/4BpX0gEd87LQlAH6sixczmc0CmMM331+5Xa7Y7QmhoizDX3fse0bRsng/OvXrxhj2Led++1G0zje399xzjHPMylJ1VLf9cQ94pxjDx7TGFDyOiFElnVBIdVMWsPpNJZFgKHrenIWwW9KieAD2hjO1ysv1yvTsvDlyxeapuF0vpCzfB7vAylNx6l9SQZIMuF5Gr7rerSx5b/F35BS4vG4A4rr9crpdJKlRlmEDH3PND3w+86U78QY2LednBN926K1ZlnnIrTWPO53zucLGVlmgJKT/T4gk3JZHIzjWAb3nq7t2O1PAuLHNIlnwFpikgVP3/d8fNzIOWJLVU/btuXzSv2Q1gZdvAjzMh/LCu9l8H5/3Pn0+optLNu2s+47prEQI1qbY9ies2ItSw1xEShZvuTIuooo+3y+iMtCa1lMJCmtN0bTtQ5yliSGfrozEk3jpDrKWElzOEfKHvX0ZZTaqHUVz0EIkW3bD9n0sszEKNVHTdMwDCO32wfrtnK9Xugaxw8//oC1msdDxN9tJ/domh6Y8UTbOYw1rNsOGWJUWN2gtWJdVk7nE+u6Fe+EuBvmdfpr+T3/l2IuXP/s73L9s78L/O/85t//z/H/slqh3+fn/O1/wPVv/4O/8ls5/73/gfPf+/2+1/3qT/nFP/pT+Ed/5ZcT/g2870qlUqlU/v9ATSRUKpVKpVKpVCqVb5JLLZBzDdYYXGO5Xi5sy0LKUlWjgKHvDymv1oquFVFy1/UoZOgbQiB4z9D3/OL77zidRrTRjH3P95+/45ff/YJhEGPq29sbX75+IQRPipGcEuu2crvfuN1vUrG076VqpmUYR0KMaGNomoacyqn2eSl/P5NzRmlV0gnpOGmeYuJ0OuODp3ENSilc2+CcKw4Aj/eSLhA5cMM0TZKoUIrH486+b1jbyHIkRtZtJWd5zRjj4UzYtr1IgjtOpxMh+CIylqXN6XSi69qjakdBGe53DEOP9/uRRPAhkJGURdt2ZSAdcK07JMZN09C2ndRGLQvrunC9XGUJkKWSSmslnxuKX4AiNxY/wFNqfT6fS+JCrpspDgrvd7ZtxWhTkhKZaZ7xIZAyhJj4+vaGD3K9mlI31DQOayzT48E0TbLk2Hf2fcfYBmPk5/V9T9u2aGPouk6SBqU6KAPzMuNax7quKCQ58XQ57PvOukgx/rJIxVPKgFJlgeBpnSvJFV2WJo55mlEK+r470htd18tixe/4EGgay7qusvzxnq7rsLZh3ySZ0Q8j58sVbUQ6/VwYSLIisK4rXddJuqLrsWURU6lUKpVKpfJzoi4SKpVKpVKpVCqVyu+BDJGNMRitCMFLvYtSWGPpeqmkaTsRFfvds64boZxsv99ugJzaX9YNMhgl/gGrNa1rSs+/VN0MZRBtrUUpTetazufLMXz2RYa7rrLIWLeVbd9YloWcEvM8o1C0xZlwGk/Sx59l4WC0JBW8D8SSstj9TyLdxjbEFPnhhx/wfmcc+1JhJJ9hmh4opRnHE8Zo+r6naRx93xOCB6Xw3pOS1A3FKKfnY5T+f60VWityTrJwWNZScSSCYKMNZMTvoKUSquva4nOIUhmFIsbI9XIVP0JJPaQY6LqOprFHSkLqg5LUHDlH23VoY7heX1BK0fc943hCKUVMiXEcsdaUIf6A9x6tpbpp36X+SSTMUjnUti0gSQVXBvIAp7MsZmKKtF3Ly8sL1tjDvyDvKzPPE1tJbDSuQWsjw/gird62jdvt45Aey+LFYawlw7GEsdayLis+BIIPbNtKCJJA0MXVAfJ5Y4psfufj/lESCT8tYtrW8fLySuNkKfN4PI7/9d5jtCbFKMJkrY8lRM65LKgixprj2Xz7eCcXN0QM8biGxhiWeT7euzHmSK5UKpVKpVKp/Jyoi4RKpVKpVCqVSqXyTWKQATeIKyCnTPCe6+VypBSacvJ9K8PfECMxJoahZ1lm8RwYSyhyZWutnMz2HqsNSsHXr1/Yt5UQwlFR8zyJnnPGWEvfD5zOZ2KptlEo1nXl4/bBtMyknKUPP3icbehch1aacRjp+g6tDcuyykLBWLzfgYy1jfT0tx3GGrZtY1k39n2n7wfxEJCJMbAsCyHIwN4Yy7atWGuOWh9jZBCulMJYewigc87HafOndFiSD47396/knA6h87pupBjZtw1ypnUNlAoh2zQYa48lSAyBlCJ919K2jnHoaRq5ps80gVIKFDTO4Zw4Ki7Xa0kFNLLdWtLbAAAgAElEQVTQWDe24h5QSmOtxVrxD6QUaaxlWdYykId5mth3j2tcqQ5qyGTxAIRyHZrmeHbargPFkeIw2vDb3/6W++OB1oZQlh7Bh+KVyMzzwv1+5+NDBvQxBvZ9B1TxYsTDVdE0TVmCyIIhBHFVdF3P5Xwmx8gwDAzlfmpjmKaJeVkQ14F8jmdSpW27Q9S975K4eAqypTpL03Ytp/OlVDElPj4+SlWWZfee8Fw4GEvnWowWf4I2kppwzrFtW7nG8hz2/U+uiJ8Xf8qv/s//i7/xr1trVKlUKpVK5f/zVEdCpVKpVCqVSqVS+SbWiCx422S4PQw9P/74I58+f08oFT4xxiIy1vT9wLat5JyYHncupzO2nAYP3jMOI6GczO77nnAMhzNqVKBhHAdCaJjnRcS720bbdyhgHERMSwZtNE3jWPaN++PBOI68XF+BjFaKy/nKl68/ou2zoicBMmR2TqpwgKN+KAQvfw6xiHfNcZLca6kgcs5hbXPUHUE+BtDy/4l/YZ4nTqfTMRhWCvbd07bt4SyYpqkkEH6SIVtriTGQiwsgxYRSmm33hJjIUE7GW0gJ1zQYpck5SmXPsfQx4OSzAhijSKncU2uZZ6lmstbyeMzY4k14f38vFT6yUFFKZNVKKz4+PujaDq3V8ZmeVU+ucUeqInhZMMyzLF2CkvSFSJCT1Db1roinDW2pYprnhZTlPni/03Ud+7YfUmRrDafTiPdyfbquP9IcUhskz2DO6RBfa6VoXVueFyNVUEXUvZdqJG0UPshyRyvNus6AyLPFcSHXp7Edu5fnVgTPd+Z5YlnmkgRxJXFiuN/vdJ3IoFOIqJx5fXlh3VbGYeR2v7FvGzEG1mVhXlZsYw7/Q6VSqVQqlcrPhbpIqFQqlUrlr4H/9D/7L/+630KlUqn8a+GcY/MrGTnt71rH5Xo9qmmM1kcFzfXyQiYTQ2BdF9Z1pe87qcUpIlupytHYxpb6GDkp7r2ncRbnGrTW+N0WQXAs9TWqdOMbzuOJaZ5LX34mxYjSmpTS4SNY1xWvPN57Ygg0rinLAc2+TwxDf/gBUkpYKyft/e5pu477XWTH8zyjjVTXPIfyz6/P08z15VK8BbnImzM5J7z3XC4XnHMMQ8+6rmXAPR5LjX3fOJ9OkGXxQal06scWa4s3ISW2fWfzO0obtnkRj0SGlERUTZbkiDaSINinib6X19x3SUHs207X9zSNJAtAFihkeY1xuLD7jW3bjtRBSjLcl6TEUoTFiRQjp7OcS9/LiXulJQGhAGuloujt7a30/3ds24a1ukiw5b58+vRZKq+WFWPkng3DQAgii376HWKMx7Bea13eo2UYet7evtJYESrvu9yHthVXwbIsLMvC+TSitSIkxbZtdF1PWxwV7+/vxJgkxeKcJEdKJdLTi9EWofP1euX9410cDkbz/v5O0zRYaxnHE/u2sa0rv/r1r5mmiW3bxPGxB1rX0FyvtJ0kbTKZ380zzjqWdWHdVtSujmtfqVR+3tR/01cqlX+XqIuESqVSqVQqlUql8k1iijS2wYdI2zp2v5fT/BvdMGC8IUbpfG9cw/v7G+fTmcbKKfYUIygZvqeUmKYHnz9/h0mKx/1O23aMp5FlXtg2j9EG13ZHV36IUaS+CoyWaqW+70u9T2DbFk6nsywz1hWjtbw28HG7kXLCNo51loolSU10pWZIcb2+lJogX2TMmhQTzomsN6WAUtLFv66LdO4XMa/SUh1kjCWlxNvXL/TDcFQXWWvZ9415num7/qg2mks3vinyYFfqhd6+vkvdkG3Y/YICXOO43b+QciamnRRz+Vk707Thymn7pmkwRkTAKUapjbKWYRjIOeOahmVd2badeZ4Yx5PIpLUiIxJqcTiILFoSBI4QIrePD0II/PqP/lh8C0Ui/fQwaN2w7wljErsPxWUQAOg6SZAMQ48xlsfjTtM0pCLD7vqe2+1O8AprDcs80XYdLy8vxBhpW1mqvL9/JcbIPE/kTFkcFDFxqXDqOpE1xxBxrpXUwP3G2/s7WimyBClwzskCzHterle2TWqs5H0lWeb0Peu6YMpyxnvPx8f7UbUVYji+/7kEiTHgGse2iUQ5hMjjcae1jqxgXZbDvdB1PcM48FyQGb2jtJaESqVSqVQqlcrPiOpIqFQqlUqlUqlUKt+kbVtcORU+zyuPaSErRUgRHzyX65mua/n86RMxBkIQ+a9Wihgiy7KU3n2RECsNbdscUt5pmlgXqTB63B9sm2fbNjJyetyVuhjpzi+T4CIjfkp+peJIhtMK6d9/DpIb57jdH2XZoUv1kC61PVLzA9L5L0N8yzw9MFoxzxOP++OQElsrC4O+76Sep3GAOn6GnK6XHn1rm+JQ2KTupqQankmDbdtISWqRnqf2n0P8j/d3Pm535mVlmmb2fRfHRElXPJMLqtRF7ftOTjA9Hnz58cfjWm/Lyvl05uX6wvl0xvudZV1RSuPL6f3n0Py5PABYlpmUIl3X0XcdIEsP8TjIsuH97a18No334fjs27axbTv7LtVEwzAcHoOUUqnzScVDscj1LEmOZZFFx7IstG1X/AqZtnUMwwhA07THIkd8GoZ1lZ8p3grDvMzknGis5Xw+83g8WMvPfd6nfZf3aI/aq0zbtuKTQNIawzDKskWBK1JwSVwYrLGHY6JpmnLNEraxPB6TfKanQLuRiqxUHBLyPjJt2+MaEXk3Vuqhcsr/9n6ZK5VKpVKpVP4K1ERCpVKpVCp/IP6X//l//Ot+C5VKpfJX5lkjs+8707IUCfLAum2sm5yIN9rIqf5tp2t7lmVl3zfG8cT9fkMhLgNtFrSCEAN93wKwrtIN/3yNlBK3jxvWNkdNkNYaaf7JkDPbtrL5DaUy/dDx9v5OYxpyyuzrSuw6UkzSh28Mt/sDEOmwa+REeAjhOF0O0PUdt9uNvuvoWsfmd7kASuFce9Tm/ORTCCgl/ohhkITA5+++k/RB2xGKLPkpF376GNZ1OYbq3nvWdSPnhAJSqXGa5wVtLV3bHUN1hcI2Dcs+g4KcMlqrUhlksY0tn0UWGzLQ34i7Jz0rh0rKY88JX3wQ4qroWNcN73dOp9PhRtg2z7psDP1IBu63O8ZapsdDFkGZI2WRU8JYcWGQ1XFdt3UjZ/BeEgrGuqM+Sikt998ajNFsW6Drx7Ik8MfiRv5sCEFjrS4JEXEwiE8iHe+jaRzOtSgl17rrOlzrRPCMxTWOxjWs6yrfs+3ElGhb8Vs0jcPv+7FUedZhOddwOp2IKeFL2kJrg3OG15dXYozlGZF0yHPZcTqdOJ9OdG1HLM9dSpEffwzkBDkn5mliHGVRsoX1394vc6VS+X9F/Td9pVL5d5WaSKhUKpVKpVKpVCrfZNlWQgz4IIJbrQ33x73UyyRyyvjd87jf2b0vol6LNgZfToxv2wZlqN8PIzklmqYlpcjlcqZtnSQYYgIU3gfe374eA3pjLK1rUfw02PW7x9oG17bkLAuPrm3JADnjvUh6Q4o0ruF2v7FtIixOKXE6nTDGHImB0+nMskiVzfV6RSnNMIxY29A0ImZeV+nyv9/vR32PtQ1KaZz76aS8cw3j0LOXjv3nCfh1WZgmkRw/Hg+pzAmBGGNJKMjAPcFRMwSZ1nWYxpLJXC4XYpBrkFI65MUhBLQxjONIzpnGNvRdh/c7+76RYuI0nrDWYowMzKWWyRCK00JrffzcEDyP+4N5WdDKkrMipcw8T6zrwsvLKyjY9w3npIIK1OG/kAQDpRKrPYTUxmhs09C1Uh0FEFNAabi+XGnbVuTLuz/SAVJzZbHlmnQlJZFTYtvWo6ro+XmkzimVFM3M6XQipcA4DlLB1ThC9OLR8F7k3fz0WRrXMPQDIUYej8ch/G6cI5Tfg6ZxnE4j4zjig6fve7RWrMtSnuEd51ou5zOU5ZM8Q5LCWJaZEMS18byfxhj6sf+D/n5XKpVKpVKpfIu6SKhUKpVKpVKpVCrfRCtFiIFhHEudEJzPZ5RStG3LPE/c7w+896Qixc05E7wn+B1QRy3NOIxcLtdSfePZ1o1924kh8XhMGG143B9oreiHQaqDsoiJ51J/JINmEdYqFPfbA2satk0EuC8vLxhjUFoVn0ODc5KicM4eKYRhGHDOMc9zOTWfinQ3oI3m5eWKc+4QRHdtR86Uk/obbdsDUtn0eDxoGien2DOAwhiLVrJYeNbfoNRR6fQUJueUirzXcLleZMjetVLnFAOu77FFNu0axziMTNNcRL6BxjnWdcH7na5r6fqOGOLR7d80kuxY1hlrDH7byCnR9z1d1x3D9mdCYtu2snzYSTmjlUaXZQMo2rbj+1/8UpwVRip7ngJt+WyqXHNH8BG/79w+PrDWHiLk5+IhpXi4JGTBIQmPdVnZd1kExTLMDyGQoSw47kyPO41rjr/vWkeM6UgS9P1QkizqWJ4YY4oEXIb3IoWW+/msR5qniWVe8MGzbzun05lt20klASIJGXUsSkLwfHx8EIvLI8bI9HiQcsYYTdd2pCDOipgiqaRGZJnTHFVRKHFVDENdJFQqlUqlUvl5URcJlUqlUqlUKpVK5ZvYxkotjDa05eS30UbSCUoBmRg9u/fEnNm3jdvt4xhO932HsTIg7rru6MK/fXwQY2JZ5JR/irIkiEGG9pfLhX33tF3L4/4gp8S6rqQk/fpGGzKqfC3+lC4wGm0N277Tdi3WWIxRnE4nALzfGfrhkDmjIKZECBGlOJIXznWA4nw+HW4D1zhutxvruhWvQQtktNbs+/YXTrtH9iJvflbuPAf3fT/Q9wO//uWviUFEzn73kuwInm7oicU/EVJEKVVOr4t7onENKPm5tpHUwdNvkLM4IrquwxqLtU2RXEdiCKQYJbWR0rHweNZJPeuaxPtAOXVvsU2DbWzxNyRJOvQd49jTOMvpJCmHxlr85sv1kPdMzoQg7gRtNF3XytC/1GEF7+V+rlKRta5zcUIEdh+YHjMhyKLDl++11uGDpBWen+UpKH5eb2sb+n5gGAb6vmPbNs7nM/u+40NgXdcj2SDSZhFQ7/vO7X5nnmdJCsR4LMGcc2WBVGTLYT8kzce1Kq4MES9HTKlmero8Wtexe8+jCKOlektSJ02p8tpW/wf6za5UKpVKpVL5/aiOhEqlUqlUKpVKpfJN9hA4nU8oNC/XK/M8M00TzrWkGHBNh9eeTGZdV07DyDxPXM4XhrFnXRfm6cG+i3MgpYRzDm0Mru3IpZpn8xuZjDaGppG6oPf3Nxrn2KNIbp2RiiG0xuw7wyjVMss8c7mc0NqQUibGnRATTmm23dP3MmxXSgbnzjm839FK48rgXAbdfUkOSEd/jJHWNajGsu8bKKn3eZ7eF8Fz5HK58uXLj2zbStf1zMtM17aEmA6BsjGmOBAsft9ZdRFEx0Q/DFIbND2IKbEuS0kmdKiUCWS5DtuO33deX1/FC7AHmqbB2obgA/f7g0+fPrHdxJuw73vxGES0kqqpy/VKTImYIvM8FQdDy7osDONIjAHnxF8hqQgPmywnbvcbMSb23XM+n0QAHQJd61BOkRKEFLHW8PXrV15fPmG8oXENXevQxvL29Y3r9crjdgfEpWCbhr0M6bWSRAI5YK09UgbPSqumsSUNksW1UVIy+77TNA6jRZ48TVP5/pavX7/Sth0hRJzr6Dqp1dJaM88TSimGYcB7WaQE7zkNJ+ZlLtVaulwnd6Qutm2XZwXkPil1pE8y+Ug3kDJkCCFIBZOxKCh1SQsxSCLlfr9B+XqlUqlUKpXKz4maSKhUKpVKpVKpVCrfZJ4XqcTxG41tMNrQ2Eb66pVm3z2hDOmN1oQQDtdBCAHvQxHqWpZlYVkWMnIKP/ggQ+Q9oFBM88Q0Tbx/fICCbd95+3iXE/5BEg+bDyzrig+B++OBDwFjjYhvW8fud3yIKG2Yl+WorQGOgfSyLDweD+ZlPip5jNZcLpdjAL8/hbtKht1KK7ZtZRgGuq4/anj6vi+LD3WcULe2IabEMAy0pRIpxkjfD6SUmJeZe6nmUVpzOp/xIaCUFnkw0LUtCkXKskSgnMB/OhGca8tw3Ry+Bnl9zzIv5ZS/I2dIMZGS/JwQI9pogvd47wneS82OKxVIy3wsPvp+kFP2StwGSmWM1aQUud8fKCX3e55mnGv4/PmVrhPRsXMNTWM5n0/0fXdIjI0xpUIq0nUdKYloep6n8rkaeY2cUOqnuqTnYuCZIFBKXA5t27LvG/Ms9zIjAujb7SafL4RSP3XHWkOMoSwYGhTQth3WNiUtk0gpghL5dt/3bJu4I3JORz1SU1I6QLn2kiKw1nJ9eUEqr35KJoSSBokxcinX4yn/lsWNY56nI9FQqVQqlUql8nOi/gulUqlUKpVKpVKpfJO/uAB4e3tjXeUE+9vv3hj6npwybdfSWMvpNPD+9YbRhmmaWDbpn8858/lTz+12o2kabrcbCgghMqaznOjWRobv40DKUnmkjGFoW86XM9NDBMeZxLKugKJpMvfHg31b6YeRtgh9Y0xs+35UKU3TRNu6csI9HvLjnPPhCdi3DWsb1nUl58zHx51t3YgxcD6fStJB5NHjeEKpXL4Wj4F11/XEKCfy+74nxlQE1brIehsZnD+H0FpjrCV4kVn3vQyzu65jGAYZUCtFipFpmhi7HmssTjes64LSCh881koywO/S17+uKwBay0n6YehpnCORSTmzlAH3OIzkPtP3ffkMviQcLN4HYriXBEBL6zoe08exKPj4+GAcR1zTgLXlHoLfNrqxZ+gHlNZopcVlcb+hlOZ6vTJNk7xmkKqhZVmwjZz2X9dFqrD2WITZct/OpwtLuTeNFbdA1zru5bnouq64N+S+r8tC3/XH8/CsPJLn4c44nrg/7ry8vGKNQZXqppxzqc9a6br2qH5q245lWUoKRRYYTdOw71vxSngUipwDl/OFlKM4Kowlx0yKEa00TfFKBBPo24699aScePv6VlwYlUqlUqlUKj8vaiKhUqlUKpVKpVKpfBOtFGRF2D2/+e1veUwzMcnANcRA23WoDORM0zgZlGtFIpFy4na/s+8767qWr8vfm5aFmBPLurB7STUYbWmcwzaWxzwRU6Ifelzj6LsBY628ntKSgtAaYwy7l2H0+8eNbd8JRbi7rgvGaJxzTI/HIe+VBAGH2Nd7jzYG73emaWKeJ+nJX2bWdWOapmM58KyoSTEBmX3fWZb5GCw/T9kbY1lK4mHbttKVz5F06Pv+GFrv3mOtKf37HILkECLSrd9KHU7K+H1nWVfWdcOHwLatIkMug+oU5aS7D57HNJdT+JGXT5/o+h6UIoRYOvrlRP5T/GuMReqGJEGx+71U9hiaRiqnxLmQcGWgTobL+SwVUMCyLSzzStf3aK243aSyZ5lnck7s+1okzbpIizU5JZqmKfVDHq3FBbFtMqRvnePl9fWopkJpcs4l+UIRf3ds28o8TeKLQJYBTxGyaxytc2Xp0KPUT/ei7Vpc09A6hyvf86xUEkk0h9T56ZN4EmNkHEf5epKlUmMbVIbr9cp4Gvn03SdcqVOapkncEFHEy03TEEOkbTv2bTtk3JVKpVKpVCo/F+q/TiqVSqVSqVQqlco3MdrgnON8OUuVjtGknMlkULCHnRA827rx9vbGtq8Yaw6JceMajDVHVU7bdRjbEGIglJ76lBKubTHG0JYUwf3xKIPknbe3N5Z1JcUog+ec2fftSAF8/vyZtu2OIWzOmbYVDwJkck6EGHk8HoQQimi3x/udru+O4f+2bWVg3PDp0yfO5zN937Pve6m1sTjn5LVjlCG+VuV9dKyriKO1NpIYUOpIHzjXHtU4z1TCUxQ9zxN9P0hlDz9V5mz7RvCBbVnISRYEWmumx8R0f2DKSfp+GDidRoZxoB96unHA2JJ+0BofAj/8+AM/fvnC/X7H+4AxBu89j7tcZ+D4/FIdBK+vrwByf3dZhsjCQbwH1ojk2DUOpbQM3LUmhsDL+ULbWIauxTWWl+uVy+lMTolPr1dyjqQUGceB0/mEMZrgA41rGIaey+WMAklGpMj9fscYeRa11igFSivaVoTXspgwDMPAvm/HddVaM/QDtrF0fV9qlmzxITT88MPv8Psu9UrLfCxOTidJoQAltZLKIkXE1T+5DBTLIoudGFNJ2ngaa9EoTuOJTC6LEZE8W9sQQixLrFD8Dg3LshQJdqVSqVQqlcrPh7pIqFQqlUqlUqlUKt/EORHhOtcSk3Tbf/36lcZKDcu+bTStYw9eql+cI+UMSh1VNG3XiWuAXE6LZ7z3UlPjHD6Eo96naRz3x6OIcVu898QkroKtJBv6vsNaUyqKttItnxmGXnr0ffEboI4aI2MMIQRyStzvd7TWh1TYWntIkWOMtG3L6+sr1+uFrpMFxzQ98N7Tti3WWpxrGMcTIURSSuSU2Xd/nKJ/e3sjpcSyLHjv8V7SA89lwDzPeO9JKRVPg/rpdHy5Jq1r2bcNv++4knbIgG1sqQ1S7NuO0ZJm6PoO73f24AlBPAfrurH7wA+/+wHvPfO0sO/iTwhBfBGy2NBYK4uOtnWcTqeSVpBExXOQL0kJGcI3zmGMgbIwOY0jQzdwGgai95AS4zDQNg0vlwutc1xOZxpjcE1zPENt27KuUoH18vKCtZZxPMmzkuRZiUE8HCLKljqnp+w4hljuocJYeY9KqUPGvfu9LHDkmiilyDkdToJlkVSMUuJOGIZRrmfXFS+DF3cCEGNAleXX89nyPiAeh/lIOygF27pAzryXSrCu6zmV5VTbtkdCBsTr8JQ/VyqVSqVSqfycqI6ESqVSqVQqlUql8k22bZOhcWPpS13NOA787re/xZZ6G2ssIUaGcThkyrFIgYd+kCWCApTC7zt933NvLOMwlmGsDOiV1kzzjPdywr/r2tLb73jc7zJAV3IKve1apsfEtm2cTmcZ5peqoJfXV+73G9frFaBIiWVQnlPGGnV8/7IsOCeD85xF+vvx8YG1DX0vJ9HP5zOPh8iFJWEgKQTxGJgyTJfrlTO0Tmp0Qgx4vxNj4vG4H4uO50D+5eWVELz4BZSSwXZG0helPshqiyKz7Svvb+8MQw/aEJUsPbZ1w3uRFMcQmaaZ/nzifXpnW9ZjoO6a9qhLOp3O5AzBy2uLiFhcDTmLKPuZnDDGiMOgLFueA/Tz+cKyzHJP/U5jjTwrRup/vnz5wvl8IqufBvB+D6QMWRqJGMeRdRc3xTiOhBCwtuH9/Y11XUtSoSGGncf0ACj3UE7+b+smi4JdKphOp3NJIySUkrTEM4GybRtd27L7ndfXX2GMJaXI+XwpAujIMIylTiqxrgs5J5SShMtTqG2tpesGQJwZfd/hfTjSGtP0QCtFP448Hg9+85vfMJfqK+QtFSG3Zd92vN8JIXA+X0gp8fH+/gf4ra5UKpVKpVL5/amJhEqlUqlUKpVKpfJNMqXHf9tw1tK1LaakA7SSIp4QIyFGdu/xQapatNbklHHOQQYfIuta6nGc5XQ6obQ+0gLe72ijeUwPOaWvlNTkxFIDVE7zt610zXdtJwN8IOdE08iJ9KZpyul2SmWRuBteXz/Jf+fE9eXl+HwhhKNmyLmnSLfjdvvAe8+2roQ9EH0kx8z7+wc5J/q+L38/QqY4EFSpV1L4EEiljuh6vZBSFE9ESSQopWiK/Blg358JjYacE23XkpN4GJ6C33Vf5doaw7IubLvHWMvuPfvm2bYdax0xBGKIZBQoLdcdMFqWAVoZ9l0EwS8vr+iyDHBtU1IKK1r/9D1PP8CzqkmV788po4AUE/M0sy4LSsE4DPR9zzgOdF0LOaOV5vpy5TSe2NYVa2xJf3SlDkoWLNu2E0PC+8DLyye0UqSMCLSLuNs5I8sXno4HU8TZkuZ4Jiu6rhMhtHNYYw6R9jxPbNtK0zjGYTjk4Fop1nVhXTfWdWHbNvZdqrtiTIzjCe8D1kq64fX1tbyWPp7BZ8Kk63tsY9mDxxiL3zzrshxLD6UUrm3Kn0EbWXTZpp75q1QqlUql8vOiLhIqlUqlUqlUKpXKN/G7J+VEY6XjPXhPThljDMN4ous6rtcrSmvePz5YloUQY6lqMWzrzvSYSClxf9zJwPvbB58+fc88z6WaSE6zj+MIZIw1jKeRt/e3nxwKznG73Zhn6bEPwaOVwjWNLAGaluvlhfP5UhYZBlOG1esq9T0vLy+0bcf1+kJKqSwN2uPUfUoZY0Suu+87KSYa53h21ey7L3U0cnL+fr9JbVGIaGXFc7Dt7H5n33e2bWVZZkLwDMMgXf3lZL/WmvtDRNRvb2/le5djsZJiLF6CSM4Jow39MBQZdYOyBqUNWSlJGqRI4xzj+UQGtDElSdKgtcb7wO12Y/cb2pRKnSJlRimaxtH3Q6nyCccQXU7gd4efYJom9n0/Tum3TgTbj+nBx+2GMlo8B2PPMI6czxcycL8/2PedfZcBPlAWUZltE99F3/fM04wxFmsbfve737JuKzEGTqczbdvRti3X61Uqn7znd7/7bREod3jvyyLB0LYd02MCFK54Orquw1rL7Xbj8RCh9vMePj+D1op9lxRO33VcL1e0lsXBssycz2emko5YlkVSCI8Hft/l98V72tYxzTNKG07nM6fTSVI5JYkxTRO3241pmo7kR/CBaZqK86FSqVQqlUrl50NdJFQqlUqlUqlUKpVv4toWrTS2KSkCpBInhghkUs5s+yZ1Q21LW8TFRht+8d1nco641rGuIqR9+/rGNM2s63Z4EOZ5PnwCzrWcxpMIjNvuOOGdkwyuc5Ylxu12Y91WbNMQY2LdVnzwIs5VcDqNRw9+zon3t6947+n7jn3fcc5JB75SKBQxRLquwznHtq0AhBjY1pV1WwBIWWTPvgx9Y4iyYFk3Ho+J4EVGHWNAa3V4F3LmqFb6+PgoA/qG2+0mQ+QQiDGy7zs//O53IlSeJlLOKKOlk1/B7ndO5zPWWtpS07MHD1qL0OwSoD4AACAASURBVLqxpJyY51lO7wO2aRhGWRC0XUvTNIeroW0dSj1rnihLDElLPB7TUQv09EI8RcuQpXbJGsiZcRy5nC8ido6RkBOZzDzJ+/jVL39FSpnHY2IvLoAYIylGFIpcaoFcWdo0rikOh1CE2ZT774prYuPHLz+itOJ2+zierWfdkLWyiJjmWZYXm9RL3R93QAb5TdOQYpL0iqjDyTkfS56nZ2F6PNBaH7VF1lpC8IQQSCnKMsCKL8K5pqRnNkmJeE/rpB7LWktMEdc4jNbkkvJ5PO5obZgeD/ZtK79XlUqlUqlUKj8f6iKhUqlUKpVKpVKpfBOrDRrF/X5nGAa6rmc8nzmdz8UXIAPYz58/4Zw7hrF919E6RwbarmfbZNnQOEcInnWZD0+Bcw6FYpomIBNTJKUgg/xtI8ZIPwxcLheslQHwMAykGBmHkW3b2XfPssx83D7oug6Q2qK2dXz+/B3GWh6PByllPj6kh77rOkKMcnrfuaPyZhhGrperdOcn8SsMQ0/f99LznyJd62hdR4oiWk45MYwd4zjw/fff/yT87QfWdZFlSc5FvOyZ5+lYLizLwljEwLZpynWAru1o2pZpW0iItPr94515XVhWSQzEGFFagYJ5mXn7eDtkygDbupJSBmTgL9VLYIwFFF+/fiHGxDxNeB/Q2jAOwyEafg79l2XBGMP5fOb19VWqjzZJJpxOI8MwkDNMi1QCoeDr2xv3+4M//81vJNRB5vX1lRgDQ9/jSprh+nIlhMC6LuKAQFwVzjWcTie6rmdZlkNSvaw75/MV5xzjeMbapqQknve85XQaSsJFnBPGWNq2o+97TqcT27axrAufv/uOru24XC7HQmUYhvK8Ovq+Q+WMMfpY+lwuL7Rty+XyglKKZZmlmsla2q4twmXFvm6yINg3bNPQdh3aaFLO2KbBtR3aWGJMhBRJGraw/2F+sSuVSqVSqVR+T+oioVKpVCqVSqVSqXyTcRgJKbJumwiUy5+fvf1KKYL3vL+9Y4wpp7cd0zKz7p5xPPF43EXKbC3OtbRtx7Kuxwn3lDJt544EgXOOfd/pux5jDO/vb+y753Q6czqNxBRpmoZf/PKXxBTp+451ldSAtebonY8xlE8hp9lzlhPrj8ejVP4YrpcLRhtO44l5XjFGTpWHKALd6/VF6pG2la5vMUaWCk1ZkoynkWEc6DpH01iGXhYOOWcZsp/P7NtGCJ6Pj/fydXEA5AzrujEMA/f7g3Xd6Mvfd64tImuDK1VAxhimeUJpLS6DdS3+AsO8LKUKKfHd58+0TcM6z5jijnh5fTlqd7puKNcnopRBZcW+BxSyNNi9Z56mcn/FUyFi6VDqgRp5P1rz+fNncoK263i5XrFGywn/rNg2GaSTM6akBPZtJ6aIDzuXywVjbal96uhcR9e2uMailXgn9t0jyZcAZGII9ENHiB5tNOfLFWMsxthSDSWJB4WiaSyP+w1jNNYatFbMs1QnXS4i4jZK0hxaKbquPZ4frRUpZUnkGEPKia6T5+zp/di2TdIPRmqtzqcz58uVECP3240YRV5tjCEjywOlNV2paLKmYRgGtFZEMj54kvrD/n5XKpVKpVKpfItqcKpUKpVKpVKpVCrfplTfaGN5TBPrupJi4nK9Ms8T99uN8/lMypkY47FgCCEyrws552OZ8P7+zuVypWvlZLZSCuccj8cDpeByueCckxPy88zn776jud14e3tDKamxkRP8M9M08Sd/8idMk1TwPOW6fT/y/v6O94EYgwyrtWEcetbSqz8OY0kGBF7/6I/44ccfaZyj61qmaWYYBh6PG865o9ZnGAaU0oT4XtwDFtuID6BtW9ZNPAzrtjIOA65xZaAuSYCu74kx0nU9+76RUibGRM6JnCPrOpdT8455XlEgSYMM1lru9zumJCfWdcVoQzd2uNaxLDPjOB4y63kSN8D5dMaHCApcY3ncIxlIMbJ7OcG/bStk6PuBdV3L6Xlb0iaKEAJvX7/y+umVGBP7tuPallyqiZZlZZonxtPI7uXvdl3P9Hjwq1/9iltZnjRWXAC2sZxPJ5SGru9JgDUGozVGK8IeCF4cFzl5WuewjSEEcVMMo/zsbVsxZWmVYmDfY5FNSy2UOC8SPgReTqeyTLBM03Q4FYZh4OvbV5xrpIaobQ8ZctM4tuKrmOaJ8/lMjFGE0OtaKryiPEOvr+z7zuPxkORG8XqkJAsoozQhJanQilIJtu87oOjaDh8CvTuxLMtR5VSpVCqVSqXyc6EmEiqVSqVSqVQqlco3STFgtCkS3iiy4RTZ96307LcMvSQHRIIcyrBUTpQDrOuK3z2fXj9hjUEpGR4/e/dlATAwTRPWNsfyIed8SHhjDCglQ+K+H8pi4UbOGWuNDHjLyf/TacS5hsvlQs6ZrhfJ7vl0klPzJY2wLEs5lQ99+R5rNfe7LCzGcWTbVtq2w7kW55ryfntSktfNOdJ2jmEYy/dvPB4PYkqlRumDy1VOzTdNU1wInsvlIs4JJSffpcLpp5SC0hqtNPf7g9vtDmhSyqSU2XfPNC2AYprm40T8U9Tc9b14KqyhsVaE1EWenHNmXmZyEu/A0I+cTmc5xa80IEkCWXxk7vc7SssAXGuF0lpE1Cmz+4A2hmVdCUGWFK5pCN6jKc/GOKK0Emlz3zGeThgrlUkf7+/klFjnmda1NNZATnz+/PmoomqcKyLoHsgoJa9vtGHoeqL3GK2OGiLQhJCOJdX333/PvouLIOd8pGiA4rLQONeWz6fpuh5rxQeSc2Zd1yKbtpxOZ57VW9PjwTxP7Lu4KJ6VVdu6EmKgcY4/+ZO/cVQfPR4PPj4++Pj4EB8DUgG2e18SNLLc6IfxD/0rXqlUKpVKpfKvpCYSKpVKpVKpVCqVyjfx3mOswVnLtu+lEkjSBPM08Tf/5t9CK+nG//M//3OpccmZruvRWjOOIyklzuPIui6lGscyzzNkWTS4xhFKDdEzXeCcO+phnkNdrfXx84dhIKdM27aAiIJDCOze8/nzZ4ZB3AQ5icPh9vHB0EsyYNvuQOZcxMXjOB61P8Zc2bYNrTXLsrCu61GLtK4rWmu+fPnCMPSkBCmVxUlJHrimYd83liKQbrsW7/2xtHgOxJdlIWepF5IURiAlWJaZvm8JYafvB7bFo4yha1vWdcNaw755tFLknNnWlZwc+XYDKD3/6ljS3B4PvN8Ja2RbxSVhrYiDm8bhnCxUrLV0XYf3O+saeNwncs70Q0vXtXRdx8fHB9M0S0pDG0KMzMvCcDqxriuqXNMYA7bviDESQ+R6lRqhbdtYlxnvPTnDly8/Ht4LstQhDUOPUpmcMr/+o1+VU/8J7ze8Dwz9wND3rLNUWQ1dT9aKDDweP7Iu219Y0CSWZUUpTduKe2IcR/EsLAtd1xODyJljjHx8fND1HefzmaYkX2KMRdidf0oLKLjfb4ynkywDiuAbMpfLhbbruL2/8+XHH4khMJ7OuBiZ54UQAz7IAmZaFozRnIuoelkWQvB/oN/sSqVSqVQqld+PmkioVCqVSqVSqVQq3ySlTN/3KAXLsjDPE+N4Yp5nXNvx9v7O7gPzPHO9inz25eWFfZcT9ikGUghM80Qig1KgFa51NMWF8HjcWZaZEESYTDmt/aySGU8Dp5MsIrTWrOsKOfP6+kLrHJfLhev1Wvr0we8bKUVutxvDOBCCCJV9DKQsw+6UMn73TMss76Vp2DapBvJeevnbtkVrXdwKkZQywzBijHgDQgi8vLySSs3P25cvzNOELmkL1zqMMXx8fDBPMkB3zmHLaXtrDdfr9fAOpJSYJhH39qUKads3tnVl23aca1BK/r+269n2jfF0wjaWbdsPD8WyLHz69JlhGMt7T4DC2GdqIxxpkn3f0VrLwsgYSBmVQSstp/y7jhAC27qL1HrbySmV+9fw9v4OSEqlHwassbTlhH/TWNrOlesVUUofJ/dTSmUppcjFP5BzQmmN94HGWtpWPBH3+40ffvcDClmUGGNo25accvEVyEIlhCB1UMjyqGka1nUlZ2iKZ+J8PhFjoGms3FtgKuJrgMZYwu6P1IM1tiQ1ZFnlnLxu49ry+5HKsyHei6XIprW1NG2LbRy6SKpP5xPaNujGElOSpE6IZDLT9CDGSM75D/fLXalUKpVKpfJ7UBMJlUqlUqlUKpVK5ZvknHl//8AHEfC2Xce+yzDae6nL6cqwWep/5PT+58+f5QR2COgitF3X9aj/0Vqqel5eXliWmZwyIcQyKLaEEMhkjDEEL53+TdNwv9/5/vvvyTGRYkIB8zxhjOXXv/41y5F6ECFwjJFpmtBGM4wDb+9f+eM//mPa1pFSJqfEx/s72hi0lvfYdz2Uxck4jry9vZGSLBI+ff7M1y8/AtB1LW9vX7leLkQlfoSX85lpnjDW0jRWaoK6DtVrLpdLEfSKZDqnRFaUa9jSdT33+52uk9P8fefwPhJjZBxP+F2E120ryYH7/YPP333GGMP8mLm8XI7Uhi+VOc8khXNS/dP1HQBNY6ViylrWZcEUfwA58/rpE9u+HZVG8zSz74HPn79jnme0tiitGcYRHyJaG5TWbPsmyYIki6Btk1SF1pqPjxt936ONASi1ULkkP1amx8L1euZ2v2OMDNqdEUHyMIxFgB1RXhYfXetY14UUI8aKzLhpHFoFXCvi7n3bCV4SLss8g8qQ4Xy+EGPCmMSyzCglUuwff/gC5ZnLxU0RQ2RbFjIy4N/3jXE803Ud+y4LEa01nz594v3/Zu/eQi1bs8O+/79vXtd9X+p2zuluX9Rt0TLGJvaDTTcY5Ke0yUWgkDgRwiQIkxBEwAoyGAQxGNKQQLBNiFFCBMHIMQYFhciQh4YGtZMHy35Qoo7Vsqw+16p9Xbe55v378vDNOddca69Ve9c5dc6p0xq/01W197rM25rVVTXGN8aY35KmGWCpyhKUa2E0m01JNhuyNGsqRoybp5FlDEfDphLBtQurq2r/t6AQQgghxOdKKhKEEEIIIYQQ9/J8t7p+uVwRDwYEQUBZlJjadCuoXTBWsdm4hIBbWZ/wwx/+AdfX127Fdl0zHo/QWnWJAqVc9cBwMGQ0GnF2dkaapqSpW5Wvm6G1i8WCKIiIo5ggCJqgcoXne4zHY8qyYjKZoJQlS13LG8/TnJycUJYVYRiilSbwfd5+6y3mt7fN2ZnmHN1cBs/z8DwNimYgsula24RhyMnJSbeKPssy1ms31HexWLh++WXJ5eUFxhjiOKKuXTVAHA8IQ7eP4WhEXbt2SErrZjaCSxR4nte03kndPvKMOI6aJMCA2tTkWUaapiilePToMYv5kqp0n0NVVuR5Trpxq+LLqmI2mxGEAWVVUtWufdN4PML3A4q8oCiKbqB0XdcuAaE1yTohz3PCaEAYRSTJmjzPAUiShOVyxWazYTqdcnV5CdYNZy7KijTN0Mq17NHax1o3j2G9XjfDowNANa2vxgyHI9cGqTacTGfNoGJD2RxbEARdFYL7bD0U7jPYpKkb2By4YdlKKYoipyhKPN9nPJm4ezRLCYOQ1XqF73sMBi75VVU1s9kJURgxGAyYTCZopbtE1Pn5OYPhoLs2w+GomxcSBD6TyYQizymKnPF40iS3FHEzN0R7bsh0EAbunu1VZyitKIsKaxWr1cLdkVKRIIQQQog3jFQkCCGEEEIIIe5ljAukB2FAGIaMRyPXFqgsKYqS9WrFeDxqkgdrF7T3NIvFomkD5Nr4nJ2dMhqNqK0lTTPieADAcDikLEqCMCCKY+a3twwGQ9J0Q+AHFGVJlqWEoWulE0URw+GQKIy4ub7m/NE5QRAyny9Qyq20T9ONW6VuLMYa1wff0/ieRitYJwm1MYAl8MMugF/kOZ7nURR5cy6u9c9oNML3PaIo5PlHHxEEHsPBEItqBjD7RFHMerWkrFwv/DAMqavaJTnGY+aLWz768EOmsxPAslotu6RIG6TebDYURcHJySlFkTEajUnTDavVkjhy1ytqZhVo5fPs2TPCMGS9XjdJEI88z5hOJ0wmE9ZJwnK5YDgaUJY5VeWSPWVRMh5PybQi8iPWyRo/cHMKiqJguVy4VfxJSjZ2FR63N7fc3t4yGo2I4ojRaIDvB2ySDIC8yCkrjfY8qjxnOBxwcfGC9XrNs2fPiOMBSitub2+atkdB03ooJYpCzh+dozUMogEoRWUtdVVRliW+7/PkyVNubq6pmhZMeZXz5MlT3v/gfbTvU1vDaDTCWkOWpU0SQ1OVbq7FeDymNoYiSVBK4zWtjLR2A63Pzs/Q2mO93uD7Hnm6Yb1auqSN1l1CQymXAAkC9/thuVwyHI5I04wwCIhCN2w6K1zSRSnN1dU148mEs7MzlotFkyRTPH3yjLIsmc/neNpHa4/RKPrMf48LIYQQQryMVCQIIYQQQggh7lXVNVVduQHLuMBr6Ac8OjtnNBoymoy74cme55FlOZtNShC4uQN+EFCZmjTLyIqi648fhhFVVTYzFlywWDWr6pVy7V98TzMcxIzHrrWNCyg/Brf4neF4TBBEBJ5mOBgQhiHPnj4jCkOG8YDxeEQchkzGY6Io5urqiqIoCcPA7U9p1kkCgNYKZaEqCoosIwgCBoMBjx49oa4NSnkUedH00lf4gU87R6EsK9fCyfNQSqGUa2dTm4rRaORa8ijNeDJ2A521xhpLutmw2Ww4PT3rKjSUcivYXfudqplfULBJXYVAEPhdED4IPHw/cDMGBhFBGBDHA8qq5vLqiuVq2QyQ9iiLoln171oBLRdLNxDbc/MNirzADwM836coS7TvUdeG+e3CBd6DAK0UnqcJQ5+PPvyQq6srd294ujlvRRD4xFHEJkmaNkhuKPfJ6YzZyYwoclUDg8GQqnLVC6v1mixz90+ySSiLgtD3GY9G5E07oKLI8X23Hs5r9jVfLFCexljDZDJxszNQ+H5IGLpjyLIU3/PRSrFerSiK0h3jICbZJO4e9X3iKCZq5j5Udd0ldIy1RGHEuKkYmTQVDp7nUVUVdV2R5W4+w3K5dImvPG8SRKapPPHIcjczJAyDJjEVEIQh88UtnqcAN++hrboQQgghhHhTSCJBCCGEEEIIca88z8myjCxL8TzPDRa2hsXiliDwOT87I4oizk7PGAzcqvm2NY3rZe9a80Rx7GYSNEHY5XJBXTev8zTG1FxcXDAej9FKM51OXL9/3+PJk6cumJxnDIdDAt8Ha0k3KekmYRAP8LRmEA/YJAmeDlgslt0x+L5HELj2RMkmYTKZAi7QGwQhcRyzWCxRnsd4MmUwHLp2N1HEZrMhimI3K2KxYDqduKoL7XF6espqtWK1WnJzc921/hkMhxhTE4ZuWHO62XTDjfPcDf998vQZtakJQ7f/TbNSfrNJ2GwSVqtlM5i4YDIZo5Xi6dOnTYJjiKndDInhKOb8/JS3336LsswJQ7fKP8syFgs322K9XjMYDskz178/CAKiOGqC7JrRaIjFEgahqxqpKwaDuGkTVLBOVsRxhAXKsmgGYI/dsOokoSgKAIbDgasiaJIqpjZMJ1OyPCPPc5aLBVmWuaHOWN566y0eP37s5moAdV0xGo1RWjEejdBA3LRdCoKAsixQWuN5PlEck2YpJ6enGFNzc3NNFMXE8YBkvXIDlcOAp0+fggI/CJhMp8351QCMRiPCMCBJ1iwWy+ZecAmpMAzxfB/f8whCN6hZa01ZlKxWS9brNVmacn7+iPPzRwyHQ6yFMIqxwHQ666pNqtoNYaZ5PEk2zeczJwzD5nOuKIuCJFl/Zr+3hRBCCCEeQhIJQgghhBBCiHtZXHsW3w9I05T5fO5a1jQB9jCMuL25xVjjVnbHbo7BcDgkiiLSLHUDezcbNpuExWLBYjF3q78Dn+lsRhzHlGUJwHTqWvJYg2sb5LsBy4HvM4hj6rJk0LQ3cu2KXOukTZJQVRXGWuq6YjGfU1du8O5gOMIPAjzPJwxCtFJo7VbPB77HzfW1S5IYQ5qlGOsGIGvtWuC49kIrtFagII4Hbhi0tdze3jAYDJhOp021Re0SG57fzYTQXls5YLm9vaWqK1bNUGFrLe+++0PCKKIsS+q6ZDQaudZC6Qat3YwKS01VlaRpiqc14+kUMK5CIApJ04TBYMBoNCLLMizWzaZo5jy4z9JijCVNU6x1VR+PHj8Ga6mrkiRZMxqOePz4EXVVoZQiHsQuAZMkripFaaqqcq19ohCl3DyKqqq6hIIf+GxSN6chy7Nu9oTXVGz4vt9VJJRlgac1J7MTfD9guVrgphTbJgnkqhA2m42bcxEETE9mKM+jNrZLdHmeR13XzG9vqWpDlqaMx2NW6xWz2YyydPMhRqMhg0FMnhdMpzM8TzOdTCnLgvV6RVEUBIFLHFhrmUynpGlK3QwBt0AUxWitXRIlz0nTDWVZEjSDxsFyeXHRXC8oi5IwcHMh0iwjSzcuwVBVDIdDxuMxo/EYY81n+ntbCCGEEOIhZEaCEEIIIYQQ4l7WWiyma4tTNL3f48GA6+sriiInHrgV7ePxmOl0wiZxLW2iMKSsSsIgJMsyTk/PWMznDOKYqJk/kKUpo9GQLE2x1rqV/IHrPR+GPmVZMxy5IKubAZCjmuqDejIlTTcsF0sCP0A3MwLOzs6bYK9yw5s3bnhzHEd4ns/F5QVFMzg3yzJ8z6csSkpVEccxo5FbJZ5lGVr7rj1R5Z4bDCPe/eG7hEHEZuPaIvl+QBi2LWncKvQ8z1gu19R1xclsBk0AfTqZMhqPuby8oK5qlHJB8vF4jDWWs7MzrLVkmZsjYYxBKc35+SN836csK4yxaO1RVTWj0RClFMvlgiiKWa2XzE5OmkoPD2vr5n0l02aQ8Xg8ZpMkTKczrq+viKKIeFC5eRO+xyCIuM6vyYuct955i6oqCPygmxEwn992yRSAR48eA5b1esXJyQlJsiGKYwLPI89ywijk8vKKKIy6GQOXFxcYa/E8lyxw95mlrErSNGMyGhOFEZdXV6A1g6Eb+tzOhCiKktF4RF25BNRwOHQtqLTirbeeAZClGVp7XF5cuMHL4xF5nnN+fsbz5y/I8gwFzGYzlssljx49Yrl0sysmkymbTUIYhszn86YyJSKO2yHNFbOTGYvlgiePn7Bar5hMJk2Spm7ad4WuTVMUNoOrI4oip6pq0ixnMpl0VTrpxl0zrb3P8re3EEIIIcS9pCJBCCGEEEIIca/latUN891sNvhBQBjFrm++5zEej5lNZ4xHIxQQeB6eVhR5ThAELBcLirwgiiLWy4VrSZSmJOsVyXqNVoosTciauQSr9cq1kKkK1okbPpxlKZPxCK1xcxVu54DFGEMURpydnzIYxJRFwVvP3sYYQxzFhEGEUprBcMRisehW41dlyXg0IvR9fE+zXq+IorDpf2+aygIXrHeB39LNUFCKzTrh9OSU4XDIcrnG9wOKIneBcOtaQbkkRE6epSilWK3XbDYpaZoRhBFXV9dNqxuF5/s8fuzmMGjPzU5IkjVZlnUB8zwv8P2gqaIIMMbg+x7n5+ckScJ6veoeK4qC1WqJtTWepzF1SV1XXUsppRRlWTIYDhgMXWA+TVM8T4O1lGXOfH6LsZbpbIKpa+bzOVVdMRwOyPOsSyr5vs/p6akbatxUaOR5TrpJqMqSunbJn9VyiTWWzWbTjLdQ1MYSRxGnZyeuakNrirxkMBhwdnZKVVckm4ThaIDWCmsMRZ6jAa10NwRcac1gOKQoCqLAZzCIWa2WVGVJVVWsFksshiDwWa0S0jTnxcULTk9POD2dkWUpi8XS3evLJZ7WhEGArWt009qpHQ7dVq14nmYwiDk5mTEaDNlsEmbTKVp7BEFAVbkZC+v1Gs/3ybMMY01XPREPYuraVR+0Q7LTLHW/f4Lg8/mNLoQQQghxhFQkCCGEEEIIIe41Go0JAh+l3Or+vGlVM58nzKYzqqpueuBnjEdj1mVJWZaMx2OKsiCKY5I04Xx4TuAHrnWMDimKHNME7bV28wOWqxVkiixzQ4KLqur6x9dlwXAYM5udMp8vePH8OXE0YD6/4Stf+QpFXmC1xmDJCxewTdOU8WRCbQxhFJM3QeF4MOiCw0prprMZSntcX183gfoaz/MpSzcc+tH5OZs0paoqPO3WZFVVRRh6PH78FmVZ8uGHHzAeT1zwerVyCYWqYjqdUtU1WZYRRTG+7/Hk6RNurn0Urr2S1or12s16iAcRVVUxGAzQWnN9fYPWHqvVmuEwZrNJOD0969okWeuG9LqB1y5xEcUBSoO2itnJSdPWJyJJXJupwWBAEPgkyYblcslwNMQY1wpJK9DaYxCHzOe3VKYCpZhMJsznc8bjMUmy7loAXV9fo7ULrHuex3q9Ji8KfO2Dhels0lVr5MUGz3fJjNOTGRbjkjrjKVmWsVq6WQxFkaO15sXz5+ggYHpywnAwZL1eM18uAZcMCcMI33fDkqMoJEs2YC2gWCyWeL5PEEUEgasqyfPCXa8gxA8CsjRHa48kWTMcDgnDkLquub295fz8nKIsiZu2VW6QM81nX6NUzeXlFQChDkk2Gzzt8d67P2R2ckae583cBIOnRwxHo27eRrJeMxi49lc319dYaxiPJq7CxJd/qgshhBDizSIVCUIIIYQQQoh7ud7zxg3ojSKwsFwsmvkHGcZaNpuE0XBEkiScnT/CD0KquibPc25vbwmDEE97RFHkBs9mKckmdX3mNxs8L8QPQp48eUIYxVR1TW2MSw64IQ3EgyHj0ZSPPvyINE2J4xiL7dr1hFFEELoA8WaTkiQJZenmHGSZG3BclCV5UTAcjtCeRxBGLmg+GJBlrrVSXde8/fY7WGuYTqc8fvyYqq6Ioogoit0gaWspyhJjDIvFguFwSBzHrFdrbDMr4tGjx8xmM7Tn8c477xDHMVEUYYxluViilKKqqiZA7ZI0KJrWPatmPkDQtDZS+L5HnhdNID+hKPJugLPb/wBQhGHI7ZrtcwAAIABJREFU22+/jef5XUKiHTBcFDnT6QSA5XLl5hrkOVVZEUUhdVVRVYY8y92+JhOqsmI0HjMajXj7nbfdnAhsV0UwHLrWSsYYBoMBvu9jakOyTsBCFMbked5Vr5SFS85o33etfio3NHo0GqO1pq5dEsfzfL78la8wHLoEwjpZkWwSbm5umxkNIZvNpgvwW+MGKg9HIzejYzTG932WizlxHLsEUhwxHo8JgpBkneB5Lmh/fn6O7/tdxcZwOOL2djsI2RhDHMddoqGthhmNxhRFQZqmrtolSwmjGN/3OTk5dfMrwgjdVB0EQcBsNiMIQ/I8oyxLN7vD9wmjmMlkhpJ/qgshhBDiDaOsmwIlhBBC/KF0czP/vA9BCCEe5Ozs5DPfp/x/pBBCCCGEEK/Pp/V3+uVy+alst0+WOQghhBBCCCGEEEIIIYQQ4ihJJAghhBBCCCGEEEIIIYQQ4ihpbSSEEEIIIYQQQgghhBBCfEFJayMhhBBCCCGEEEIIIYQQQnyuJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoijJJEghBBCCCGEEEIIIYQQQoij/M/7AIQQQojP083N/PM+BCGEeJCzs5PPfJ/y/5FCCCGEEEK8Pp/H3+lfF6lIEEIIIYQQQgghhBBCCCHEUZJIEEIIIYQQQgghhBBCCCHEUdLaSAghxB9qX+SyQiHEj743qbWQTT50v1r3w/3UPGctqN7XtD/2tmGhe+HeE93mml8VoLptKNSBt/VeDkqBUs37to/Z7ljcM+3ztrdBpe9u3BhzeIcHqAPnZLHd43bvWhx6/e57t9fRWoO1oPrH23ytDlwUpVTzo9mWBWt6n9WBz2Vn39be/d4qjAVraoyte8+BNe74jLUoZbHW/XDHpnY+193z3l4bay11VVEbgzHGbcNYjDVgm09PNeeGQmmF1hql7PZ8NWil3eu0Wy+nm1/3r51SqrtxrLXdNemOT/Wvo+rOpbnFmmNv9o27f9xLFFrp7v0o3dt3796zdue3iGqOa/93zck7f+Kln5UQQgghvhjepL/TfxKSSBBCCCGEEEJ8Mr34sFJt8PjlAeuXbaML8vae2otv7yYW7O6LbBPg7acQ2Ht594zaP9I2uqvu7vQetvfzy5IFdwLXB6j+61Tzrr2EwjZg33/X9hjax1STUNlPEjyYsr3LpQ5ux12u9njVwUtn9z6NbdLHJQa2CRRAg7Z651SU3p6PSx6oLrDfxfe7wH97XAeSPNbuXPt+wkehDr7nrt3X3LnPbJN1OHQDCiGEEEJ8AUkiQQghhBBCCPGJtEH718nFX+9bu997vbHdqvD7jmWboHhZlNd+Oif2QA+pHNgPeG9XzO95hfM4WkWhXGWCu2r96H5zBe3BGpTuuFxuabs6f/uLQmF3Egn9H91mlO321Sz23zlfpUD3HtipJug2Y/sf/tFrc+ja7pzw3hmq/duon0Ro37W/uWa/kmMQQgghxBeFJBKEEEIIIYQQ9+u1Yel9Sy9K22lXmbcB5/sWwn+SWH0bB26D2fuR2S4hofpNj47t8W5kV9nDgfVXO8ZeFcEDt6O6xk7bd2yD0bttpVQXzd9/Xf9r1b3+UPS839anX3HQrzRoKxJU07KoTS70Kye27au2j7lr3yZm1M62+8ehlcJqjTGm2da2LqM9x7YNkNLaXaGd8ztUTaC6c9hJS7Wna1V3zu3z7f2yU9nQ3+LBrID7decW3Ba97DV1aj6LtormQRUQQgghhBCfL0kkCCGEEEIIIR7mYLuaYw70KnqI+2L997Hb3vXboO7eyv1X2d6hFetHttP1z3+tVQzbGoH+3u9UI9x7Vi9vO3Ror/1WRDvtlVCgmrkWRz6vbaWA6v3aRNXt3hVUtqsw0IBFgVFu5kJ/7kWbLzkwI0Jp78gH66oD3PwG051bu6c2A9W1bFLq8HYObru9AG16xT3U5kq2995LLrgkEYQQQgjxBSGJBCGEEEIIIcS9rAXddYaxvbjqgRX73aRf98advvqfIG56KOZ6X1B8G2DfXRN+/77UToXDTqD+YLC49+SDjuflbBM5z4uCLEuJwojA95oBwtvofRdMVxxYKb93Pv3tv2SORTtTof3cXPKhNzuiaRG0fdwlFrD9odjbYH83O2Hv3NzPLhBvsd3w5PYULbYZz7CdgdAlJti9H9rv+4mL3XkHh6sV2lPqhmPvtUbqX6/tAOv+7Ir2OLcJCPesAXSTN+lXaEjiQAghhBBfTPrzPgAhhBBCCCHEF8CBPEC/ZctLQtjNwu/XvVL/wJ72o8uvbcN7P3S7L15h9frHc3FxwT//5/+CDz96TlFWx4cYP6TKQO1//fAD3c4ccO/r2gA1jymld+YS9Nbo72+p98z+QbsByloplAatNFq7xILS22SBblobobTbr9Y7p9Ifxry//e4D7F2HLmmwN8h652trjySttg2o9nNlqn3s6HuFEEIIIb44pCJBCCGEEEIIcS+tFMr2+tUD/coEeyQm7Vaac3R+wUMdyw9sB/ke2u52pxZ7JLB990i6Ybv3xNlVf5H+9tFuf+5/d8/y3pkJFqw1FGXJ+x+8z+X1FWmeozQ8Pj8njmI8zwXR21Ns97edU7C7Qt+dV/t426Ko3zCprRrYPem2MqN/nIpmnrDdv0ZtgH53usPuKnzb7NfSjcW2LujelR3othrENgfdn9mge+2NmruxbU/UJjW66oNtxcH2yPfHEvSrBXZOfTeZcOT+2Wn51N/Anf5Xh28mN5sBrFQqCCGEEOINJ4kEIYQQQgghxL12AtTNY3bv16PvBaw6/Kou3nrg6VcKrSrXTKbfVanb90uTCK/uwVvqR+pfhbXUVcXt7Zyrm1uWqzWL5YrNZs1P/MRP8JV3vsQwjlHeoZKIQzvdTRm82vEdeK/SYA2HA/Cqa5u0nbPQ31b/693vVZN0sk2iw3VNUqijhfT2ziwG1/+oObR7g/N3328PlA7sJH4OzkZu3mvck0rbXiLD3X13iiOa/b/ue1MIIYQQ4tMiiQQhhBBCCCHEvfY74dyNt6oubLq/gn13Tfn2MazdDaHaA2HxNjFwKDZ+8CC5G6/uFr4fWnV/N5q+nTtwbOf3HQi78wP2Kx4ORO/3V7/Xdc3l1SVJsqE2hqqqWCxX/MEf/AGmrDh/dM50MmUQD5q5CbuHvN3ufkujdu7By09rJ3jee/F2oPS2GsHtw53rdn/NfnbSTnfLUtrzbgPtrhChuWZdcP/4ubXnpFDHPoqd9x5KBPSTCAdnGNwb52/OfVsesrcPi23mR2znJWxTXdL1SAghhBBfBJJIEEIIIYQQQnxix1u/KKw1L3tj77Xb7/vh54es1+5aER0IBB8dcPuGLQRvg+rWWqqq5vLimmSdUFU1AEVR8MEHH3B7e4u1hj/9p/8MX/1jP0Ycxy5dYS3GtDMLDrXw6fbU+/pIWcJe2cl2KHLzvdbN7ABzp+6g2+Z+6Ur3zaEKiTvR/W5v2yTL3bZLxz/bl3242/0fTR4cdORYe8fTtlhyr7bddcM23+1Vb3y8khUhhBBCiM+eJBKEEEIIIYQQ9+st6d6uZD8YKT7w1qZWwfaCwneWhTfrtNVum6NDodb+PIb+Avn2WJQ61gqnfUWvMuFIy6V7l+zvbK2XQnmFuPCdgb649ji1MWzSnN/5nf+PF1cXjCZjoigEayiAsqrxPJ9/+k//L4qs4Etf+hKT0YgoivA8H8/Te/vBdfzpqhFUtz/30agDiSDV/dINDXbZiub97dMKq5S7jMru7q+pSmjfZw/eL7tlJNvKF3unEuFYS6G2ImE3nXG4hOVQkcmhdkZ9O+mDrtpGdfM5dj57xYEHt/vvJ0UUL0lyCSGEEEK8YV7+N2whhBBCCCGEeIA7Q3qb/x7wxp0F3l1RQbuQu5dg2Hms/4M2uPuQKH67WpyjcxserHdMd9j9F7og8n7Q2lURmO5XY10bo+cvnnN9c816veFf/d6/5vlHz8mLAoMlL0qqqsJY+M53v8t3f/N7/P4P3yVJNgf3cfzgH/5U1z6oO7n9ZED/QijcPzUPJCYO7OrOIn0FSml0kxDSva/vvl/tfL17zx27Jx56r+y+o/tqJ5GmesUXdvdp2s9iv7JCCCGEEOKLRyoShBBCCCGEEA9ytzpgu8p8ZzX4nS4623fuLMDufbMTZFXbYH/Xm59t1UFXhbDf9+hArLrbam8Fvu2/9iXx9DthX6VQx4Y13Nch6MAKeGt7VRrNr8YaNtmGj158xHg2IclS/Mzn9maO52smkwnaUxhTEwQBZV3y/37/+1xcXPD1H/9xvvbVrzKbThgOB4RhiNaea3W0c63aFjzb81R290K8fDzE3rXsVSC0z1vbv8AvHcZwNwml2jZKtksOWCzKbqsO+iv5XWXJzt7vbVl07LljQ5cP5oq6BILq32jNZ9meW/uQ7Y2VuLu1/v6kSkEIIYQQbyJJJAghhBBCCCE+RQ8MKN+zif4i8G6LrxBv3U+AvDSD8DodOO2dRIKxXcKkDYBfXF6QpAlPnz6mLHNMbUgSuLq8oapqZqdTTNMCaTAYUpRr/uDdd/ngww/5wb/6PX7i61/nj/2xP8rTx4+Jo6hp9dRrZ9S0dNqJlT/o42krDfozL1626v+eC3FI76NRvX0pDrVfOnKM2wj/K3nZtncrJ/arEmiqKHqZGdM+1ntJl3VpKzy2LwdecV6DEEIIIcRnSxIJQgghhBBCiIdrhuC6WG0zDrftkd/oVyccHzWwG8w/FkC1XcB1b4X4y+KtbaC+i+uq7Rvuq0TYX5F+Z5bD7ve2Hxxun7f3h8zbFkQW3DBqC7WpyfOc6+sryjzD04rHjx9RVTVKaa6ur7i6uiGMI0aDAVVdo7Ti9HTGYn5Lsk7Ii4KLqyt++P57/Kk/+RM8Pn/EdDxlNBzg+T6e1l1Jh1L92QfqpcH3bSUAvSHOzcwFurHIO5do53V7FQXH9qH6H1CvWmF30sAexd0KhQPXu33NQ4L17RwI1Z5I75h2dtz8uNOiqakywdOu2qOfTFC4ypZjFTlCCCGEEG8gSSQIIYQQQgghXlkXUG6+ty9dcN6fQnvo8Zfs557vd7emtq1kmgO0CpTaD0M/aHrDK61q39nDQ97Xa2kEYKyhrmpulwtW6zVlVQIaYw1P33qKtZCmG1arhKuLa/SzRwwGQ0BRVRWPnzzm8sUFyTqhyHNWyxXPLy549vgxX/2xr/JHvvxlZtMpo+EQ3/e70H938A8uGNkNmSvVJAfavEsvqeA+Ar39+iEZlm4f7ZfN+7vHt9UQuwmB/ntec5sgy14CqbkGan8mQ+8VbdKiS4jcPcx206/tOIUQQgghPkWSSBBCCCGEEEI8TDsjQDVtcvZXZyvAbleV768+d8HStq1P++jxyPKxfvLHYq5tccB2csP+vl/B3uuPvrvfn6YXjG9X4runti2F+m2N2ufaWQm1MVxeXZIkCW2CwNYGz/c4Oz0hTVJMbdmkGz768DnPnj1ldjJDa43neTx++oT3fvge1lqyLGe1WLFZJVxeXvHue+/x7MlTnj59wmwyIQpDhoOYMIrwtIdWu314Dn4+ql1Rv1e10VQ3YBVW2W4FvrtV+p/37hwD9r7uZh3c+ayayofdQQ97r+t/AIfumeOff9fy6cBn3lWZ7Dx6/NtD226TCTuH2TxnX6FKQgghhBDi8ySJBCGEEEIIIcSr2x883LYweunKdtV7wafTyqU7hKZzjHr4UvtP5hV2s21r1AumWyiqkqurK4yxKOVRVTlae1hjGI0GPHnyCGsMxtTM53OiICSOY5RW+L7HIB7xpS+/w8WLS+rakKwT/MBnk6XMF0t+5/vfZzad8vTpU87Pznj7rbd49vQps+mUQRR2ZSU7wfNe66Y7p6zaAP828dDOMmg3sb1F1M5wZrenu9vtakYOxNXdZ3o3kXBfW6BPLUi/M1H52GvcT3bvGKSRkRBCCCG+aCSRIIQQQgghhLiX6qoQmhXU7Wpqs61MUL0Bvi/rhe9ee2x2wla/7373vjuPHHoPXdBa7QTrd/vktwH9baVEv8/+ke33O+h0O2wrD0B3q8333tcGlO3ekOOmxVFZlVxcXrLZbKiqmqqqXBLBQl1XeF7IYBDx5OljUJaqrlkuVviBz8npCZ43oDaG8WRCXhRcX91Q1TXGGsCilYcCbm/nzJdLTmczPvjoI95+6xnPnjzh/OyM0XDEcDgk8H18z2+qFPZPZm/VvlI7q+77cw7aa+ue77WeUu7u2J+Z0LU+sgbQLhG0XyVwpzpgf0Dxw5IG/aqZ/pDknW2pnV8O7qObEbH3Nmua7bZVFMdmbgghhBBCfEFIIkEIIYQQQgjxCe1Fze9dnf9x1mNvg/X73+3UN6heSuDgqvb9wPPD9vuQY375Vg+839IlFtIs5b3336UoSuraYC3NkGXVJRSU1gyGMW+9/QxTG65vbrm8vCaMYqI4AiDPc05PTsmynDzNqSvjEkCRRXsexliqMmflrSiqksVizr/83d/lyZMnPDk/5+233+L87BHTyZRBFLlkws4V9u4/LwXYpgJhW6rQH2/Qe93uQ8YalFFoDUrp3kvVdh7D3p4/WWj+VStWentr2mhprXe2Ya37SdoVCSGEEOJHiSQShBBCCCGEEK9uf9py97DaBuvbeQVHWtConWj/gaRAPzuwtx975+ve4FvVrn6/e3z7x9r7rnljf2n53dXv++d8vIahV3mwH6du2hq1/9Wm5ub2hvV6TV3XaK0AF0SvqoowDN28BGvQWjMYDHjy9AlFVVLODVdX14RRCBY3SFkpzk7PuLVziqLAWtMNdq7qGqU0VV1DnlPkeXctnn/0Ee++/z6PHz/m/PycR2fnjAYDoigkCkP8wMfzfHzPQyt9ZPX+brujrlKhu267pSgvbUvUdQ461j7IdjeMUruvua/d0W6NxfYePH67HHqmqXlpznfn1Vrt3ceumsdVsfSqE6RSQQghhBBfEJJIEEIIIYQQQnxs/aZAH6/vez+A+rItHN7DziN6P6x/9z2HV4mr3o9Dx9V/9FDTJk07HeC+Y+zPRrDWYqylrCpubm7ZbFKU8rDWUlVVd6zGmG6gcl3XGGMZDGOePn2KQZEkG148v+Dx43Nm0ymVrfC0Jooiyqok9OMuGB+FEX7gY21FVZV4no81htVqRVVVpFnGR8+f4wc+j8/POZmdMhoNOTk9ZTabMptOOZlMiaKoqU04PNz44EXov9TStF3arxJRKKV7wf3eZ9F2CqKpBEBjbe1aP/nh3ud0+JO686lYPnEQ/1CVy6HfE5IqEEIIIcQXmSQShBBCCCGEEA/TrKC+EzreWWBt+7Hivbc3cxZ20g87r6ANs99tTWR3ft6GndsxBdvZB8d6+rtgb1sdsb9tvVchwV4wu5240BsyfaR10s57XppdUVhjSJKEJEkAdtrkKKXwfR+tNca4qgKtdTM3oWQ0HnFWnlLXhizLubq8IQxC4jikrg3xIGadrCjL0lUReB5aq2a7IZ5xK+mVr6iqElCurRIGFFxd37BYrrDWEoQh08mE87MzTk9OOD09ZTwcMhzERGGE5/l4noenNUrrO0Mi+qvz2wSKMdteR3VtKKuCJNmQ5TlaaabTCbPpDM/T2+vSVry0symU6hIJ/c/LKrv3+R26+qqZ6dA+8OqzFrr99U53Py9hu5/cF/e1PLqvmkIIIYQQ4vMgiQQhhBBCCCHEg90NcfbG1t7JHNC0Cjr0xCGHUxDqTvrgwBE8cFV5b1509z28yqL0Y7UXL6vJ2FYg7O5XYSzMFwuKosT3A+razUXwPK9JGrjqhKqqAAiCoJkV4NoUTSZjrDHc3MyZL5ZcXV1zfn7GcDjEWEvgB6RZBlh07bmqhrwgHsTdMOC2HVK7gr8qS5RSpGlKURRoT5NmKfPbWz788EP8IGA0HPDo/JzzszNOZieczGZMxlOGwyFRGLLtNNRPHrkrYazFWtNdfGNhnSQ8f/Gc5xcvWCyW+L7Pl995m5/48a8zHI1713j3uioUfhDy6nqJp6MeWG1xdOu775cuRkIIIYT4IpNEghBCCCGEEOKV9KsB2m8O1yEcbzBj7X4QV3XvuLsd7jx2aNBuvz2O+/lYYL83x+ElzWf6gf97481H2hrtHfZOssVaNx/h9uaGsip7+1TUdd3MRbBdckFrTV3XWGtdeyJj8JTi0aMzUJa6NqSbjLme43ma2ljKskQrRRCEaO1W9pdVSZEXhFFEWRSURUEYhk2rIVexUFUV2tNNFcn2eKuqAqW4urpmnSS8//4HDAYDptMZ08mU6XTKaDRkOp4wHA4ZRDFB4Hf7VsolR4wxGGMoioKb+ZwPXzznww8/ZLVeU5QlgeejgGdPnhEPhs17t/dNf/yE1rv/rG3vuF6Ka+f5fqXCfVUL/Xfd+TCba7WrrVw5/G4hhBBCiC8qSSQIIYQQQgghXp9DsflX6NSiej9/3KkLL93+wYjuwR5FD1o63oWN7cvXr1trmySB3QnMZ1nGar2mqkqqqmqSBi7Q3lYhgJuT0M5IaI/PWoNSEIUBT58+oq4sl5fXrFcJnqeJBwPKsuy2obUGBZ522ynLgqp0iQFjcpQGrbQb6uxpwjDqkhdtYsEaS5amABR5yabesFiveH5xgQI83yMeDDk/PeP89JTZdMrp6SnT6ZTJeMIgitw1wFKUJe998AHvffAeV/M5WZqxSRKWy5U756ri+uaGp0+fEgTeztVtExwKi73Tzup1OTZPA16W6LLcrXT4+LUNQgghhBBvBkkkCCGEEEIIIR6uDZAe6hHUlCjYpg+8Aqzt1xj0V/gf7i+0P5O3H7a9N72ws9yftoX+/ot29n/nOA6e0zZEvF3tvj2QbZ/9/dZFvdXxSmFMm0SwTaVBxe3tDWVVYI1LHriKg6p5venaG7kZAeB5bhhzWZbUtUsuGGPxtMejR2eUZcV8vuD2dsGZ5/65V1UVZVm4WQMqRPkKaiiLApSb+VBVBt/3KE3lEgredi5Df//Kg7Is0Nqjrt1xVmXl5iI0yY+yLMk2G168eI7neZyfnjE9mTEZjxkOhkwnY+I44na+4F///u+zShKW6zXz6zlZllEUBUorPKVZLJdNZUbo7qnu9rNNZYK+s/5/v8pgty7m0J3F3mP7disP+q2a9l+3vSm29/RDEgj9gc33zVAQQgghhPg8SCJBCCGEEEII8WBHQ5x6v/TgcLD1eLMjF3u1atskSL9k/wf3dKcq4FXWge+9dqftkXlJk6T2i3YA8N3N2v2jbSoTyqrg9vaaosipTU0QBOR5jrW2m5EArpLA9/2uzRFAWVbd88YYlFWMhgOePHlEWRRskoT57S1xHLkWQmWJ5/uE7XwCwBgLyiUJfM/HmiZd0iQ8irxo5igogiDojl8p3c1xqE2N1i7pYZpjc5UUimSzoSpLVus13ocuARKFIV96522GwxHzxZLlcsF6nXDx4pIsTYnjAZPJhOFwgO+7yomqLLHGorz+Z9V+TKqXP3oThhR3/ZcOPCd1CUIIIYT44pJEghBCCCGEEOJBdkKgqh2iSxd0vxsi7c80aF/b613fzRZo15T3Zxuo3kr/3X0frU5oYv/buHK/Fc7hc2rPoRs23Pu+vwfVVhK0587hkHA/qH2328629Y2xliTdkGQpdRPAbxMG4JIDYRhSVRWe56GUm5vQJhKCIOhmDbTnUBuD5ykm0wmrdcIqWaK1O6+2VVJVlu71Cuq6xg88NxhZKxRulkJRZE2SQm2rAJoqCIubk6C0xvN9TG3Q2kMrME3VhbEWa0xXVZHnOb7nE4QB8WBAsklZrdcsFysWiyWr5QprLY8fP2I0GjIYDhkOBmitGY1GVHVNVVeE3ja1dLeb0UsmGXcVBNuqhNcVzu9XEhx9TTMUuvvO9T5CPbB9lhBCCCHEm0ASCUIIIYQQQohP1fF14mrnl91g732ry3uB/v2ZzR9rYfr+sGTF3fTFx9lqkzzoRb0trrJgsVp0Q5aVcrMIXPKg7l7rWheZrvqg3U4QBK4FkFJdwN49bxiNh0wmI9abVTMjwbU+AijKAnCzEIw1KOXhB+6fhZ72XPsjz0MrN09Ba4+6qijqgqoqcYOgDXXpvsZaPBSe73cVCu0xauUSI77nEcUxw+GA4XBIlmfkWc7V5RXX13OiMOTZW0+ZzSYEvo/vewS+Io4GDOMBxhjKssL3A5f0OBR8f9Dn/lkF7Y+3SGrbWrkuYJJEEEIIIcQXhyQShBBCCCGEEB9LF9C12zKA/bXfblW761nUb/FjaQsG9oKp/SqClzYUUtvqhq5soW0r0z+A7TduAbjqVUK072+TCHbvPbbbT6+g4vBg366YYb/aYjto2TavMcayXq354P2PWK/WYMGYups5oJTtkgPtTIQ2UdB+XzTzDYqiII7CrmrB9wNQNZPpmIsrTVWV3ZDmunbVDVEYYgEPDxT4vsZamsHKFV5TGVEUOVioTQ1YNwfBQhAG6EphTI1CkxclqqgIfI+iLJpgv4exhsFwyHg8QmkPawzrdUKabri+umG9ShgOh5w/OmM2mxAGAVprtNYY446nTbDUtcHUBs/Xuxe9qZqwVnO4txS7cwp6n0vvE/0YtjUp2yRRO+OgV+nSPtC9y1V47E9s6B+VpBeEEEKqk51EAAAgAElEQVQI8SY61HZUCCGEEEIIIT4G/VqCoNtV5/dsrWkRc3gWQxu/3Q0u7+YAjm1/fwLDPfaLGdoHe4/1KxJMbbi5veXDDz7i6urate6pKkwbsFfb2QjW2m4+QRCErvWRUuRlCUpR1TXGWvzAx/M9wjDEWovve3haU5alm19g2rZIFq09V32gNX6TmGhXyuv2+ybYXVXu/UrrJmDvjmcwHOJ77vjKoqQsStI0o8hz6romHgyYTMZMJmOm0wna01R1TZZmvPjoBRcvLlFa8fStJ8xmE6Ioxvf9LtGjteeSIyjqys1faNs6fbb2k0yth97p++UyRzYvhBBCCPGGk4oEIYQQQgghxL0OhVEPNyFSO8/f7WXfvOdOf/h2NXd/1kKbJGhWnu+8stmO6feo781UOJoj2K4kV/2j3y+M6K0yt9YcGRvd26Ztt7bbwsja/aSEmx+wWq9YJwmL5RJrFXEcgbUYU3VJFDe0mC6A7yoLKkxddzMPwjCkrg1ZXuBpjen17A/DqGltRFfhUOQFCkUUxXieT1EUbNIcgOl0Ql272QZVVYG1VFXdVAiYpurCUNduMLQx7nzCMEArjVIQRmOUgsFggOe5dkpZVpBnOZv1htvbOev1hulsytOnjxmNB/jaw/O9bq5Cmzipa4NpqjHa+RDG+Gjdzm7YrzSxuzfbkZvg4yS77KGbmN02S9t5Cfufef9+6x2DPdw+y+5tVwghhBDiTSCJBCGEEEIIIcS9jjWD2U8m2Du96l/WvP6hLWbUS76jFzxW90aJd5/e9mPqttB1a+olBGwzMLcb6aB23r53MAfevx28bK0btLxcrcjynHSTAQvOz07xfW8bEMe1L3IBe9M87tob6V4lQRAEZFmGtrZpTVR3LY583+fk5BRjDda4pEZRliil8TyPIAxZJymXlzeURcEf/+NfYTQaEkYhVVfJ4IYpty2klFJUZdUlF5RShGHAeDzB9/0ueaK1+9yNsWw2KatVwuWLS5Jkzfmjc548fcxsNnWJA9+H5vjb9kZZloHW3faMsdS1+9VVrBz7dF/38v79u/3jB/j372KXTNDs9c16jaOghRBCCCFeH0kkCCGE+EPtva++s/vA8GuoH/tzeD/9LYb/1k8ym356+7759jskvwz8xb/Hyf/0U0xey1Z/i+df/bcpP9E2fpHR7/08Zx/jndn7v8Xyn/wflL/xzzC//VvNo0/g619D/xs/RfSzf5npj00Jj23g+a/xwTf/cwyg/+t/wTs//eSVj2H1j3+O+d/4DeBbRL/5yzx59jFORAhx114D94Ph2t44gTvPK1C9OQlK9ScgHEkUdEH17ff7rz60Ulz19nHoNNResHa7ibuBaNt7jalNN+/AdD3we5USWrm+/m0f/F7LIGsN1kLdtDEqiqIJvEOeF1zf3DKbjomiCN20JGpbG5Vl2UsogOdpTHN+7ar/9rW+71NVLtBflAWDeMBsMsP3fbzADU4uy6q7bnlRs1yuKcuCy4srBn/0S25lvdaYqiYKI7SnaQPfvu/hB64CIY6iZpaCSzqEYUCW5xRFibU1ZVFRFCXz+YJ0k2Fqw9npCU+fPiGOI+qqQmsPowx+6JIVxlpMXaM8N/iZrurAYK1r0aS1m4mw//G6e0o3H+jxhEL/0/840xLurxa4u3Xb/NflDFRbZdNPxdneb7M3K5nwif98Fw+y/TsMBP/wA579uc/zGN7Uv0d9/L/r7vzdsvd3zs/rWv9I611ffu7X+fIv/tnP+4g6b/49LsSbSxIJQgghRN/mB9jf/gHVb/8qy29/g83f/R95/Benn8sfmNXyB9x8+3v4f/uvfqyg/meqfpfLX/oFsv/1eweevIDvX2C+/z3Sf/ALpN/824z/zl/l9FNM0rwW9ZL5r/135F/9JZ7+mc/7YIT4/LmQ5/HgbBtc3TYhalfh2+1794cWN199ti3ie8mM/qMWrLJNdULvFc0qfGMtWV6QpilZnpFkadfH32t+DQKfyWjkgu+2n0gwXVVCXddc3VxTVRXD4YAwDFitEooiR2l41Mw4aIcnt1UBAGVVdtUTurcsP4oi6rpuBi9HQFsFoSirijiOGE8mRFFIXVdUdc1qtWKzSanKEs/3yfLUzVuo3f7cMWiGwxjP8/C9oGmb5KogTDNHIQhCFosFWZajU4UxUJUl63XCarkiSRLK0qA9xcl0yqPHp4xHQ8BdizBwoWfP8127prrGWksURSjVztxokzftsRn3Odq7wfYuQfWxb6pDKYbXwzS/F9x/xu1j27nrzfSj+Oe7EEJ83uTfGeILShIJQggh/lAb/so/2vne/PD/ofrur1J95wew+R7Vf/IzXP/vv87Tr3+2x7X5zt/i+r/4+7D5Rfy//Srv/BqDX/lHBAefW1D+tz9H+dsAf4XwV37qyF8EnhC9yi7rd7n4T/8d8u9cuO9PfxLv3/1L+H/ha3ih22/13e9R/m+/gr0FfvNvsv73lthf+3nOhq+yo8/Q8jt89K2/TvX8guAf/tLnfTRCvDleVo3QvaQN1Kte3sDuPM5OIL+tEWgf25u4cN/q7/3njwRl2xX4d8Yo294RNJUGVV1TVhVplrFar9hsNqyThLIoyfPcBeKTNXVVY4xtZii46oDRICaOB5xMZ5yfnTGdTQl8H9/zMMZwcXXF7/7gB1R1ie9rptMxeVFQFgXpJiMdZIzHY3xfd7MK2oRCXZumAkGhPSiKouvL37YZ6l+vxXINpsb33eyEyXhMEPj4vk8cx1irCPwlZZbjKc3Z2QnxIGY8HuNpjdaKOIrRWlHXrj1Stx9rKeuqO4aqrFjkOZs0Jc9y8qzojmc8HjCajBgNh8TxAADf99HaDZVuqyrar5VSbkh0XVM3SQ0L28oOY7G6mYex/anXFurAPbBTuXI3eXV4XHe/QmB71/TnZxyseunGf6j9B5pvrZvmoSwW02uZ9Yb5UfzzXfxo+VM/T/zXv4l+4Mv1H519qocjxIPIvzPEF5gkEoQQQvyhdv7Nb+w+8M1vwH/019j833+Hm5/5Npbfovjvf4Pk736L0Wd4XPXNe7D5OO+cMts/p84FF/9z+/VXCL75jddS6ZD8n3+/CzKon/1fOPmbP8nY23vRN78Ff+MXuf5vfobNL/8W/Ktvk3z7zzL8r75B/BqOoW/y07/M5Kc/4UY2C8zzi9dyPEL8yOgCowfSCAcmKh/rVt82J7J7If2HBFEfvka8rYjYzSpYu01suP+54+5vt6prrm9vuby8ZLlaskoSsjRjvV6hlWazSSmKgizPKMuKIs/xPK9rLdS2F5qMxpyenPL4yWPeeftt3n7rLeqq5vd+//f54KMPOZlNwUIchZydzri8vCbPS1arNcPhAN9322xnEbRVCSiF7Q0fbtsbGWPwfb8JprvV/pvNhnSTkmUpq+WaR48fc3Z+RhyHKAWz2ZTrqxuiMMIan2dvPWU8HjMajQia/ZdlSRRFLJdLTG26hEJZVVhc0qUqK+a3c1brpKumsKYmjELGk1NG4yGj0dAtwG+OH1xVRZtQaBMIQDcjwVhD3exn2yLKVSZoq5vLsRugf9Cd0rQVagP8rnvSnczD3aRT95XqkmBd3qL5/bEduLx9/nCLrabBkmrqFBSAfqOSCW/an+9C3HH2J4i/+Y3X1B5UiM+I/DtDfIFJIkEIIYQ4YPjn/yrJv/ltsn8C/JPvsVl+i5GU6h9wQfJrv+K+/NIvMToUZGh5U85/4e9R/+5fIP8u8A/+Bxb/8TeI/8hndaxCiE9EcSdZ8CDWDWB++CjlQ9vYRmtffgTHh+3aZj6DxXRhYBeorqnqiiRNWSzmzBdzFssl19c35HkGSnUJA1PXJElCXZuuEsHNE3D71Vqhtas+KMqCF1cXrDdrnr94znvvPyEIAv7g3XdZrROmsym+H1BVFePRiLKsmN8uyPOS2/mCx4/OAUtd12itqaqKIAgom9kKOgi6aoW6rrqEgmqSD1p7DKIQ6hrf86mKisV8ySZJGU1GjEdDRmOfvKwoa0OVZ8Sha5G0uF2gNBhjWC3XWGvZbDbQJCi08ijyHLSmqkvq2riZD2HAYDAgCkMGgwGerxkNh93siDzP3OwFU2OtwfNcEsEag7IWawxBELiWR76Pp/W2IsFuP0f3a7PKf3ex/8GZGTv3ARbV3ZDddIvu2d3vj91lXRpg7x6zB5MG2/f1tmzdd92x2LaN1kOO4LMgf74LIYQQYpckEoQQQoiDpnhfar++wG4ASSQc8B7mO82Xf/5rDI4FGVreV5j+7F/j8rt/H/gO1b+4gD/y6gOVhRBfME0yofmSe1eMv9TdWQ1tSLcb9Hxg89343TYgjWvNM1/Mub6+5uLy0rUxSlPW6xVZlpPnOWEQkucFeZ6DtdSmpqpq6sowGAw4OTkligKwBqzr9e95umuTpLRitV6TbFK0ViyXy+Z58Hwfz/PxfcXZ6QlVVbNcrLBYojDk9HSG1gpjbLeSPwiCbmZDGIYYY0jTjDAMm6SCG0aslGI2nTKdjAnDkDiOyfOCLMtJ04x0mLCYz1kuVtzc3OIpw2aTkqYb8rwkzzPqylBVdTdk2vd9jKmI4wF1VVGZmqKssBh83+P8/JTZbEYcx02VhuqSIO7YmsZ7ysNYS+T7mLom8H3qugZrd4Ltpq4xzcyEnZqAncKD/t1gdz/kflC//XpneHf7lv2ZGc0jO1O99++1pj1R+3MvwdFWhewcgrUodJNoULvbapMIANZVJ3z+iQT5810IIYQQuySRIIQQQhxhq/arJ6iX9Potbn/A8h//Cvmvfw/z/R+4B599A/2XforoZ/8yJz/28GHNq3/8c8z/xm/0Hvk2yVe/TQLwc7/Ol3/xz77qaXzKIhji2jD9yxfkcG8rg/jH/xSaJ5ivfw17ewG8JNBQL5n/xq+y+Qe/Sv3Pmmv7Y9/C++m/wujf/0lmB5I722v4LaLf/GWePNs+d/Ptd0h+GXctf+Exl3/rb5L92ndg8xXUN3+S4D/8k1T/2X+J6W2v/A/e4T0AfpHR7/38mz/4Wog31ScZfnt/ycLOl7YdZNt7YzuotyhK1knCfLHg8uqSTeqC5/P5grKqqKqKJFlTVTVVVZEmKVVVY43BYt2cAt9jOBq4IHldoQrAutZCked1K8sDzycIAnKvpKwqsIbxaEQ8iKmqEq08wjCkKArCMGA8HpLnBUVRcXV1y//P3psH2VXdeZ6fc/e35MtNmYjFsqex3EGP6LFLcoQdUgQVosJuROMquShsBbYbLxi7QqaoMGE5ig45SjF0WB4qyoWZ8YLLVuEmwG7GooouEeUaFEWENKYHyaYsYdrIsiG1pV7ub73bOWf+OPe9XJSZEiIBYe6HEHnzvruee17ee3+/8/19AQqFoFviCOiWUEqzskZCiNnkglJzSgRpCkXjb1Auleip9HaTIPWZOmHYJgpjwlZInKQEvk2j3iRJIqTSuI6L71oEhQKB70FWhkijCPwCUknCKKLdagPGgLnUU6JcLmFZNnEcd9UUQFcxIaVEAK7j4tg2aVaSSUqJ4zjzvBMQgigMjSeCMooFugbWxvj53G5wPs3KItmBuX3tFTPfewE6yYQLXX82sTDfSuGNTiW8dvf35vH9NB7aR/LMQfTxkWzuGsS167C2XMj9ffn7cfdev9xyssrk3kdpP/z/oI4cNvP612NddyPuR7fSt2EYb6kTlVUm9+4l/O//iDwwf13v09vov+bCn/teSy62nRcSjx5k6r49JE/vM14Y2TNu8PltDK5eZkVZY2rfI7T/76eQPzto+lJxLeL3NuL8xw9T3rp+aZXLJUTr+H7qD+0jeeop9GjWr6+5HuejW+n56MYLOofGob00Ht1H2mlDzHOn88e3UdmyluL5tvE73F/Dk4epPfZjkqfmvEcxDNesxdq0jcJ/2srAcv2M7Bp98xGSZw4tuEZbKN50Yf18LunJ/VQ//XHkcaC4Ge/h73LZtec6yL3ivjG6l1ObtufvGTlvai6F+1tOTk5OTs6lR+sw8T9n05/YQs+iD6AR04/tovHlPeeGLUYPoh4+SPvhrxF+8gH6vnxhLxpvPtbibIXkYeDI12h861rc29ct/0K0eitX/nrr+TddP8TZW+8hPrSghujxfcjd+6h9ZxvR3vsYvmrx1ZclHaH6+c/MGkgygj6wD/XH/9tFbCwnJ+ccfwQh5syea7S8IjvLdjL/V7M/Pf9nd7S4URLM1GqcPHmS6ZkajVaLeqNOEsckScJMbQaAJE2JwhCBMSiWsUQpRRKnxElIpbcXx3azcj4pzWYbpTSg8FyHnnLZJBoKBaNIECLzO7ARomOya7wYUCaoboL/0FMpo7Tm9OkqzWYKaAYGeikWi92EgcxG6HfO0bIsSqUS7XbbqCCUynwVjDLBcRz8QkCpp2i8CzRUesrUZmqkqWSsOmUSFVkwv1gqYQlBsVjEcx2CQkDgmxCy7ZgkieO4xElMFCdE7TBTHUiCot+d7ng6dI41SRKkTE2wHKNUEELgel7XB8JxHNLUZPFt2zaJhDTpnpfSqrs9U9ooKzG0iATFdL2FSoO5C8yVNczafl9Y79OL/nb+0L/ufhtmVQlzjmdOuaWV+rZcPK/B/b11lLN/ejvxgZFFPhxBHxlBHtlH7RsbaX/vB6zecG7gbiVoPfdtpj6xC7XQi2rqMOrxw0SP76J68w/ovXczPQvON3zxESZvvRs5tfi64ePfYvQjf0XvrnPXfd1YwXbWB+6numu3UeZ2yJ5xWw/fT/SXDzFw69pzk0ytw4x+5DMkLyx4hmsdQx84RnJgD1O7t9G62Oe41wNZY/yrn6H9/YMLPqjCC4+QfuURpr6+heb3Hlg0yAxA6xhnd3yC+MmF12IEfWAPyYE9THznDprf3MnQEu3wO9tf5QhjO+8m/OHC9gXTxlXUCwdpPvg1wvt+yPAfrTk3gClHGLtnO+FjhxdZ31yj2u7NhEskAhYjHTvI2PmSCCvRN3Jy3qRcqLl9Tk5OTk7OW4I0qlE79AhnPvIZ0pNAcSv+Zxc3DKw/9kXqnSRC/xbcr/6IyoEXGHz2p5S/cx/ONcNAFf39W5i6Z79RFZyHwk1/xeCzL9Czc0s2504Kz77A4LMvMPiFS02NAODT99GdWdijirrvg0y87+Oc/vpeJo5XCeXFb1ndezvxIRA33Uuw96cMPvsC/f/0I7yPZGbSU48Q3fUItYvZ+Pe3E+0Ha/sPzDV76p8Iduyk8ME/ZODZFxh84r7uQ5Lznaz9n72D8sWfTk5OTsYrH2d9ronzOR/rOUtm5XHQpjROOwqpjo3x/Au/5OjzR/nNyy9RHa8yNT1Jo9Gg3mjQaDZJkoQoik2ZGQ1pkhKHMVEcEccxaZrg+h4ztTqnR89y4uQZzlbHGa2OcXZsjLHxSc6OTfDSyyc4dWqUk6fNv9Nnxzg9WmVyeorq+CSjZ88yOlplerpGs9WmHYbESUw7DFFSUSoWGOivoFRKOwyZqTUI4xgESK2Mx4DWJEncVSGEYdgtqePYNmmSorXIEhwmKO+5rkkYICgUAnp7KwwM9NE70IvrO3ieR19/H0NDq7hs9WX09vVS6e3FdT1c1zVGzghSKUlS44vgOA5e4GM7No7rYMyGs2uhzX593wRRhCVwHBfbsgg8j4LvY9s2jm2hO2qRJCFOEpqtFmMTk5w5M8rIyVPUW02SNEUpUy5KZQoFpfW8JJbO/junY8zrLiuhQlgCwRxJgUCL+eoHlXl0LJlU053lzH9vLCt9f69SvevjWXB7GPGR+yhk9/bBZ39O5dEH8W7K7u+tgyR372HqVTxDLEX43P1M3pwFZYsbsXc8SPkpc5/v3fsg7qY1AOjHPs7MN44Szlk3PbmXiZs7Qdk1WLc/QOmcdavoH36cmfsOz1v39WMl23kf8Zd3o1trsO7qtNNPKf/1Tqx+gBHkV25h8smFT2JVqndlSYTiRpy//EG3jQef+ieCu7Jn3KlHiD79baZfg+v86omYvO9js4Hia7bhfedf6H/2BQYP/AvFv7zDqJWn9hHf+kWqJxfZhByhetcts0mETTvwH/3pue3wwrcJP30/kwsTBfwu99eIyW9sn00ibNpJ8GjWvs++QO/eH+Df3nkXGkHefT9TC5MhVKl+/g9nkwibduDvWeQatfabazR6AYfVOsz4x24hXVaJ8Cr6xtCW/D0j501PrkjIycnJyXlLc+KdVy794aadFP+POxgcWuSzlx9h5st7zfTVOyjtvZOBbvmjCsXNa+C6jbOjZB77IjPXPU3phuW1tY5fwfFBdrdVwOqvsExlpTcc55o76P3GCDNfyJIqU/uRD+yn9QC0OhLfD23E23w9pXdUCC54xNMw1r1/z9BH1szKtfs3Ur53A+PO+2g/XIXn9tI+vo3K1Rdx4J/8LoN3rc+SROso3r7OzPd8iAI67yuiUqHYfxHbz8nJAcjqxc+Ow+4oFMzUKxt33fFAEJnpgu5UhdGmNr7ojFZHo7Wg1Q45ceoEZ06fodFs0MqC9lJKoigiihLSNAEElmUj04QojkniBCk1aZrSajUolspYjk2z1WZyuka7bYyXXdftBrIty0IqiVbGu6BYDLAdB9dzsTpqglQipSTwfRzHoVAIKJeLlIoFkiTGcz0812ZgoB+pNNWzVYQwSgDHcXCEwBKmzJFt2V31QceDQAgBWmN1PBqUymr9CxOIlwrbsvB9nyAwwZFCMcBxLBzHotxTolQqYVsCpcHJDI8d26bVamXnKzLvhBSyRIY5P1PGKZUyUxeYY3Ydk8AQlmXayrLxMuWB4zgoLVFKY9sOURSTpJKpySnCMEIIQaPe5Mzlo/SUe5DKJBy0NskUlMqMrskC+ALmJRM6vexCCxotVirpQjF7Nddg7t6sOSbMekHBLRZ8J/Tsv4sxNl9hVvL+nh7Z21UBitu/y6od6+cM0qjAhi30brieiVUfovX9o3Dyx8Qv3gHXrOQZjTDzv+8251Lciv/EAwzPNYTu30Llb9dR/fwfEu2voh/YQ/0/3UeQBc0n7tqejQpfj/vof5s/kr9/C5U91zP90Bep79qLfvAzTL3vGS6/7vUdjbzy7bzwXCsUb7qDnus2MP4nHyI5XkXu+CYTm3cw2Fnk5EGS7Bjsr/+AyzfPbad1FLc/SH3odqbv2QfHv0X48ztgw0We8NPbmX7ndqbPt9x1D9D3t1vpucDNhge+TvPBLEC9+QH6vrl1zoj9CsVbd5J+4HrGPnYL6fG9RHdtZOaH2+id8x2oPXrPnGvxD/OvRdYO4QceYeLmu1HHd9PcvZ7iX84dvPQ73F+nniJ8YKn2Bfo3U7l2M/V3ZP2ER0ie2Qlz3qPCA9+f174Dd6+fo5gy1yj8t32Mf3Q3urWX6LHPkW5ft3QQtHWY0a0fIjlPOaNX1Tdsn0J//p6R8+YmVyTk5OTk5OQsxfOHSJ45RmuRkVJTT3TKGW3G+7/mJhHmYK9haOcOnCJAFfm3/3hxo+ffBPTccC/DB36Eu3ntgk8yie/u7bQ+eA1j7/l9Tu3ex/SFNMS7v0TP3CRCF5++mz6ZTR9EnYwu4ojX4X14/XnrPefk5Lw6FtaJX4mx3wIQmaOymGu22ymhk6bU6nV+/dvj/OLIEU6cOMHU9BRhFBFGIXGckCQpcZwAxhzZsizSJCWJE+IoJsyUCKlMKZRKxHHMxMQE4+NTtJotpExJk4R2u02j2aDRbDA9M02tVqNerzE1NcXoaJWzZ89y6uRpTp8e5dTJ01THxpmYmKQ6NkF1bJzR0bOMjY0zPj5BHMVoQCljalyp9NDb14tSmnarTb1WJ4kTkzSwrG5JINu2s7bOjJZtG4HIFATGi8DtlgzS3dJIUnXKBBk/CUGWpBAC13FwbAdLCJRUKKW7ZZUcy8J1TNKgEPh4roPvexQLBVzbwXc9SsUSgW8Ml5M0MSWVMn8D3/fwPPOX3Ry/CetIKZmernF2dIwwTJCpRKOJk5jTp8+QpKkpjTTnuI2h9WzJo6WD77PzzwnYvxZkuYTl+3sn4THf/Nn05bmW028sK3V/D8emsa7dCMVt+J9d6v7rM/jBG7Ppo+gLkXK+AtIjTxI/Z6bFji/ND8p2sNcwcPefIVZvRGzy0aPmGSM99PjsujsfYNWi5YB8+m79Et67AaqkD+2jvrKncF5Wup2XOlensp6+v7jD/NK6n2j/nAs/eiLT06zDHlo8MN1zwzbs/vWIazdAeKk9HVepff9+M1m8g8LXty5a9scZ2kh/pw2e+xrtn8/5UB6mtTtzK3/3ffTcvfi1CN61jfLdm80vD++hNmfU/O9yf41HZ9DXbkT0r8P7wuLtC9Bz3ZZu0FI352omatR/2LlGd1K4a/2iZdeCDXcQ3LwGce1GrHBmadVF6yhnP/WZ8yYRVqRv5OS8yckVCTk5OTk5b2mKe340f8bUCMmhgyR798LUPpI/38fkwR8g59UdPUr82FEzed2HKS43Gr64kcKfrqN+31F4bj/h6DYq5zEMe7Pird7I6u/8C3FrhOZTB4me3kfyk/3GXK9D6xjqwdupP7yR9je+y9B1yxi8/cG1LKXfcK56GxagADU2w7KGzYuyEfvfvMJVcnJyLppZz4SFZYqWDpYuplaYv77uKhG01kit0AomJid56eXfMjk1RbsdopQklZIoiYmiCCFs0jSr1S9Mrf52q2XKFyUSmSSE7ZBCqQBa0Wy2qdcbtJptNODYFkorhHZQSpEq47+gpClZIzRoW5GmMWli6vwLIbCzoLnOHHX9wMdzHKKwTbNUYHBgAGFZFIIAB0EQeAwNreLll04QhpEZ5e+aEkSe53XbQkqjcuiYLHfOybJsbMchGwiPLaxMHaK6aoA0SbrljyxLYFkCmaZIS+B5PnEcGxUC2iQFksScixD4rovnudhg9oPobjeRKZZlE4YRUqnMUDrCsW2T3HBd4jjuKiq0hsnJSSYna2hlrktvf4ViMVkS21gAACAASURBVMASAttxiKKIUjFAaoWjNNrSC/qEMpmrrhpgfvKg258WrY11cQqZudufv0VtSmR1phfp5p1lOgkHnW1HaJFlyi6NRAKszP29vHkH5c0XsLP+oW57rDTNnz+VTW3Bu37Nkss577qNqw7cNm9e49A/zq67eZFa7R3sNQQf2kj83EF4+inaY1vpWUzZ+hqxsu28Be8DS59rsOlGHL5NCshnjhDekI2m7z6jHSW++x6q9+2g8u8WKFYqm7ni2Qs50PNw7Z0EX9x0/hGy5bW4F7rN2lHSp7Ppj9xI3zKy4OB912dtUCU5cBQ2ZOrWFw+RZN8P6082zlMqLKR34xbq7Eezj+SZKvyReab9Xe6v3jXbuHLvtvMv2D/cfd6fR3SE9Mls+tY/oHdJIYXPqq/+dPl91I5xdufHjSfbskkEVqZv5OS8yckTCTk5OTk5b2kGN21cMGcj3LQNdvwZZ++6hXh/Ff3Yx6lt+Dk9N2fB6loV2al3+a4155VJB9dspM5RYB/qJPA7mkjo4BXX4N20xrQjEI4eo/XsIaInHyH9SSYFbh0k/fTHGF8otZ6DteqVJgdeCX1YufdZTs4bwPlDV51g7vIGzZ3R54IkSYjjhGarycjJka76IA7jrHxRjG1bNJtNNAKNIklSlJLEWaA7iY2hbxhGWJZg6LIharU609MztOpNlFY4toVlW9iOk9X0N0HsVPnYwpgba60yE2ET1rIsyygftFECBEGA1AJhCVzHNiP+labVConjUWqNBoEfUCoXKRQLeK7H4NAA1dGzSCkZn5iit9KD6zl4no8QgiSNEcKUITJldVRXZWAJgW3ZOI6dmT47JtCfmGMSlt0dxC8Az3W7y0kp8f3AmCZnI/8dx8ESFrZjk6QpaSIRllFAuJkHQyqlye9k5ym0yEoduTi2DUqTKonjOaCh1WozPTXD+OQEqdR4nsvAqkE83zOJCmG202g0qPSUUalCORpLg+ooU9AIy6gpTNJKzelnncD8YomrC7dJvlBM289uzyRv5qtzuuW5ukkM0f3AJBZeq1D6q2Ol7u9zSaMa8dRZwl8fI3n6IOmT+16jM49IjneMUa/FeUXPYlXin2UDSHgnVqlG65x67bM4q9cBB4G9qJcfgNcxkbAUF9fO52kn+23Y12ECq8erJGASCau34N86bEpQHt9DtHUPY8W1WB+4Aee6Gylct5ZixV+ZYNTAuwg2bbzgkkUXxG+O0hEjW2+rEE/ViJdcuBdrA3AIOHKMOuvoARq/OtJdwhrqozW1jOqichk2kALqVycwg2Peov1VRrRqZ4me/zXJCwdIHntycbeYkyOz1+jqt72KvjRC/IVb0MczU/BWgOhf5u/WCvSNnJw3O3kiIScnJycnZzGKa7ls972cfu/tSEA9sJfpm++gD6A10335sq5+23k3FZT6XsMDfQ0Y3cupTduXtnl8hXVmg9VrCW5aCzdtI546yvTuvyB67DBwmOSrP6b22LYllQevGe9724WPTMvJyXnVLFQiXNA6S4S55m5La83k5DS/OvYr2mHIdG26W+ZGS1MSqDNaXysQlkUcR6SppNFsoBKJFpo0Tmk2m/T19+P7AVLFRGELmUosS+B7BXzfRwiN7TjZvkEIC2ELHNshiWOSNCGVEiEEaSrRUpPESVaWRxLFCa7v4/s+nm28DVIpSdOUdqio15vYtk2xVKCnp4e+vj4KQUClt8LkxBS60TIBf8/B6/OxLJOwcF2ve55mX6qbXLBsyyQDMObHKlMIaK1RaUqamkSBRuPYDo5j1AwyOw8wngsqNf4EWCBUZuqcpriu21VDdPbjOC5pmmYKjLSrbPCDAmkUoZTEsmyiKGFsbJyZmTrtMMQvePQP9mPZ0A7bxHGE73mAoFabYbCvD98NcFwXYVkkKiGOIkDgei6+F2BbJpnS8c4QGKNnY6FgGS+NRRQE5+t3kK23lLoAwbysTJYUQM8mEzo5DT1PcWASCoK57iFcinmEc7iY+3s8epjpJ/6RZN8h1JHDr+PRzpjBHADXXcQzQLfM5f2033s/7QtcTY3V4PV/ylmZdj5vO/ViXZVNPnOCpDvfZ9XOv2csvXvWTLd1DPX4MeLH7ycGZlZvxb3rk5S3rqd8wd5ZrxPp7KTa9ftM7LrA9Y5Xu91Ep7NlN9PPXsPEhe57dIYWUHyL9Ne0NsL0E48Q//Nh5M8Ozlc5LcfUWPdPpP2OVzPw6Cj6OFAchlYV2Ef0lb3Uv7NEuaUV6Bs5OW928kRCTk5OTk7OUvRvwNkMcj9w8hDx6B2/82qC1xqvfx3D9z5Adez9RE8Dzx0kHNtG5fUe/ZSrEXJy3iDOHx1dXomQbUVpUilpttocPvwzfvvySxTKRcAYJCulsMVssQulMhWCTmg2myilUYlCa4jiiIIfUOm9PDNXrpPEEa7r0t/nYjs2ruPiZAoCYVlYjo1MFcK2zDlpSOMEpTWpUkYpEMfIRBIEPnGc0Gq1SdOUKIyMz0ExII7iLPhuPAiSJEFKSbsVorWg2WhSCALK5TKFYoFWKyQMI6amZnBdjyAIjBJAmLJDjmPTbrVNAsEyJYEsy0RDOgmYTokiyzJBdSWlCWVrjeM6WEIjZYoQFlEUorUpaySlMn4M2iQuoijEtm0sy0IpjdYmgREnCVoYpYhlW90kg23bqCxpopSm2WwwPj5B2A6RUlLprVAsFQDN9NQMcaYa8QOfcqGEbTn09vbhBgVSFI1Gg8mZSeI4JkliHNvFsV36Kr34nku5pwfPc3AcF9d18Rwb1zV9Qs1JRgnoKhZWDJ1pDTSzZtDZ/E7ZolmTZfNzbhKhU3brzcT57+8RUw9up7F73yJrmxrm9paNeMVDtL6y5/U78NcYU9f99UwkvEHtvLDEi72GoXt/RHjXMRo/eYTooSdRx0dmPx/dS/LlvUzt3kZr730MX8Wbn5PR0oNwLpTazBsacH49+2v9yV3M7Pg2+pzkwTBcswH7fZtx31sj/tNdr75dl6O4Efd73yU49DHq9x2Gp3dR27uews3LlIR6paxE38jJuUTIEwk5OTk5OTlLMoxzNUT7F8wu9nZf9tXxjgR5acLm9GtxcJcAVcbu2U506AQ6uo2ef8kUG+fDXkPhhi1ET+/jkpBR5+TkrCi6+78lPnul21ugZtBadxMDp06f4Te/+Q0Tk5M4NY9SqYgf+ERRhIWpxe+6LlprosxoWSNQUhNFMWmacNnlQxSCgFarTZLEKCVxPWMYXO7p6ZYFEkJgYcyZtQApTU1+pSS2ZcodxXFsDI8towLQGlqtJu12RKPRotFoEMZGtSBToyAoFAokSYzrOriug1ISsJBpirYErXaLOEmo9FZwXceYMkuFJQSDqwapuD1GPZCVFRIIrCzAb4yYTXvZto3WGsuycF2jGLAsy5ggYwLqjmMj0wQrC353zltKieu6xhNCpt3tCGFUFV2FQ2aE3Gq3jFpDzZZTEkIQRRFpkjI2Nm58J9ohWikKhQLlnnK2DY3juCRRSrPRpNFs0g6MAbYbBHjFIq1Wi+npKVqtJvV6HakknutRLBSZmpw05acwZaYcx2Vo1RCrh4YYWjVo1Anm5JgtKXSBPXNBxaG5wf75qYDOPNNfO8qO2Y3M7c/KJBv07KEIYUpDvXGs/P29/vgXZ4Pb/Vtwd2zDf+8G/KEKxblB6EMnLnhQ8isjQHTio0/PHT3/CnnfA/T91wtXZb7erGg7n7ed5oyaf+/io+aDobUEt+6EW3eSRjVaLx6g/dh+kn2PoKeAqUeI7lr/xqhTLwDnv57i8ve9mi1swf+XBy8iUXKJ99faYc5+eTfJ8ROI2/+eK29+ZaqA8Ln7mfnCt82fveJG7C/cRrB5A8FQL97cslejezm12AZKsyOC5EtV2HCxqoR1ON/5gSnD9p7/QrT3g8THq6hdX2Ny0wMMLzOA7NX3jZycNyd5IiEnJycnJ2dJqqTHF5ldGca+CuOT8OIIddYv+4DePtKpcboV6+0rf5QrzuqtXPnrrRew4DD20LGsruhTRMfvgOWMp+fSHW61ZVYWn5OT87tDp7TLSg/01karECUJp86c5qWR3xKnMSCozdRwbIvA9ykEvllWw0y9jpSKKEpI05QkSRFCMDS0ilJPEa1MyZ5ysUhPqYTGBMlLxRK265CmppaBZVnYwsJxHMIowi24xGlCnCSUikXi0CgbpDSGw3FiQj+lgklSVCoVZqanaTbbpEpjZ+V2XM/NSuZopEy6x21ZllEGYKPRxHGC49popVFSE7YiZiansYWF57tESYJt2XiB2Z7nebiOh9YmYeF5HkorlJY4jgn5CZEpBrAwlXn0nP2bQLZJOAgcx0YpkSVJpPE5cMC2XcIoxLJtwiyRYsykA5OUcRySNEFraDQaTIxN0mq2UUohgHJPD0prqmfHsG0H13MJCgGFUpFUSZqtFjMzNZqtFo1Wm3qjjue6RFGbNElpNOoEQWD8J6REFU0yI4ojk4SJU1zn1/SUy7xr7Vre9c61lIoFXMdlgS6BbpmhuQmChQbhr0ApIM75bYFZeHdSmWvQWe4NL2u00vf3o7S+vtdMXnUnxX07GFzCpDRNZ4uw6GbE4hLCI6SjLKESrSFHF5tfwf236wifOHqe9c3xjr53O+lVw4hb7+PKm9fgXDtM9HQVnjlCFG2l55JUNq50O59FLlfpJjqG7BjPvmsNhfMcneNXqFy7hcq1W2DnnZz97PuJ30h16lK8/Z1dg1/54gi8b2mj46Xoeee1TLMP2Ic8HsFVr7TDXOL9NTpL+pOD5k9VK1x8mWY4+6dsnhtyjfrf7c4+24K/b5lEy5xSQnrufq5ci435c6OOnyBleMngZuPx7Ux9s4q4fBOF++9kcF5/XoP9juzY7HX07t7B+M270a29RDu3UP/OlvnveCvQN3Jy3uyc19w+JycnJyfnLcvUIdKOGuGqDXjdB/h1eDevM5NPf5/WC8tso3WQ8DuZ4dm1G/EvlZekFaK44aPZ1EHi3XupX4geW47Q+m/ZaLl57ZqTk3OpszCIumRIVXeMZM+NiIrsvyVXXWSdToBbaTMivjo2xksvvcRMbZpSqUSz2SBsh0xOTmNZNqViCaVhYnKSZrPFzMwMYRQiZcrQ8CrWvP1tDA0P0NfbS0+5TF9vL/39/fT29tJb6aWvt5diqYBUEqU0SZKSRCZIrrWmVCyaUkeWlZXiN0ftui6+75uyPsIYKhcKBQYG+xlaNcDg4AAD/X30VSr09/cxODjAqmze8PAQg4ODDA8PMzy0iv6+XgrFAoVigO/7+L6H5zqUyyUc1yZJFTMzDSYnp2i2TGBeoxHCIs5KF1mWACFwHNeoJVKjWJBS4nkeAKmUgMCyTOkmACklSZJkygPjhxBFYaZCMF4IlhBYtkWSxN11hDBlqRzHwbYtisVipgZJmBifpHp2nHq9SRhFRHFEb38FpTW1ep2pyRnGxieoVseZmJik2W5jux6O45FKSasdcvZslaNHf8mvfvUrXvrty5wZHaXRaJIkKXGc0Gg2mZqZZnxigpMnT3Hs2K/55fO/5F+f+1f+9V9/wfO/fJ5fHPkFYxMTRhUiJTJTUXQTBnpuQuXcfx3Vxdx+uWjgf0EXN6t0LJY7hY1010fBbGauSfQby4re32tVM/gCYPMmepYIbkPEzE8e7f6mxmaWWG4G3VxqE0dIn1r8o/KGG7OpfSQHqksdBOmRgyRTx9BHDiIyn6vZ9vg28U+WMc4Fpr/1IU5suoWTW7dzdrEBKa8VK97Oe0ieXvpcmz/Zm8V5h3E2rusGcms/2cWprbdw4r33M7lUv7HXULxhS/d4LqkC8kPrcN5tJvX3nmRquWOb2s/pf/9+Tm69hZP3Hpz1IrhmPU7W/uljT7FUdwVIX/g2J//973Ny6y2cevhYd/4l3V+H1mBn56efPbro+YUnj836GLx9bsB9BPXzbHLDZoJlBhTVnv5xtySQPjM2+0FlHc512fSTB6lFC9fsboH2U3vh+EH0Sz72eWQvwbvvoPDJ7B1v/z3UHl/Q7ivRN3Jy3uTkiYScnJycnJzFkCNUd9zTfa8Rt98wT9bff9NtWYzgMPFd9zOx2DO6HGFs127SFsAw9mdvpPcVH0g2CukSJdj0SfzNmZx4/3am79rD5DLHm9aOUb1nO/FzAMNYd229sHIJbyDypaVf3nJy3sqIOT/nFIm5oHUuBqUVSZoyWj3Lb1/+DbXGjAl2o+gb6AdhESeSM6NnOXVmlJnpGrZt4/seV1xxOf/LO97O29++hr7eCqVigO952LaF73sIFK7rmfI/aJSG6Vqd6ZkZoihCSYnjGHVCGIbEcdwNpju2jQBc1yGKI9rtTrhA4zg2Wisc28KxLQYH+li9epiBgQoDA30MDQ2waqCf4eFBysUiQ4OrGOwfYKC/n55ymcGBQXrKZfp7ewl8U27JcSx6ekukaYxUMD0zw/T0DFJplNaZ0bKg3c5UAmHI+Ph41xi5Ey83Pgk2lp0pIzITacuyugFzMJ4KwhIUCgWEsLpqBpOoMImFOE4JwwjbsSkWi5RLJZRSjI+Pc2a0yuiZKhPjU8RxgspKGV1x5RUIAV7g0Nvbw9DwIIODA4Ax0D5z5gzT09OEUYRUypR60ppWq83MTJ0wikkTidKCOE6YnJxhfHyKkZFT/Pa3v+Wll19mbGwCrRSu69Lb10etUeelEyP8j2f/B8/+7BAnTp2k2WqRZNteKBjozsv+aaXnJRqW7egLkw0LmE2YddIHen4S7Q22SFjR+3uldzbwsP8A9SVq6tSe2EX7oaXvuYV3XJtNHSR57DDnjIOWNSa+3nnuOhfnPX+ElwUB1a5dVE8uspAcYfIb3zLTxTvxN5vIY/D+G/EyVYa85y84++Likcvw0P007jsMowfR9kYKF6rkWAlWqJ3nIu/5i0XbKT25l+l7HjG/XP05Cu+fHXHuyAh15CBMfZ/23pG5g8rnbHiE9pOX6qCSNZQ/fZuZPLmL5r0HaSwWMJYjVHd8EdkaQR85hn3dhllVhr+Rwp+uN9NP3sP0Q8fO7a8ArcOM37UL3TqGPuLjbFrb/ejS7q9rcTvljJ78FvVDC7YvR5h56NvZL5ux/93cCP4worOfQ/sJFzsvoPXct6nvXlhfdnYblU/cYSZP7qb19UX+HgDhoT1ET5rphe9yi+Mz+Oc7syRQFbXzbxibmvv5CvSNhYvm7xk5bzLy0kY5OTk5OW9pJg4cXDBnhvTpgySP7zG1WwGu3kHx5gXS1bdvo/erB5n+8l44vpvW9UdIdtxGYdO1uH5I8vxTtHZ/jfSF7OFw8056PnDh1V/dobdlU4dIfnKUxk1rsGx/ft3QS4JhBnb+FdWXP448Djx5D80n/4bmhi2412/AuWbYxFNGj5E+8xTJT/bTLcp7w71UbrrYmqavMf3DXemy+slTTG26Ed8Hq1IhsN/og8vJeWOZG9/MfGNBCFMLPps/L2y6XMC1E2xduOEFq3YC241mkxePvcjk1LQp/ZOm2I5FX18vjUabJE2ozdRpNptcceXlVCo9WZDcxnEc0Dob4Z6ilcQSAq0VnucjZYrreqRpSqPZJIwj4ihC2ZJyqdT1BdBamxI6UqG0Kc8j0xTHdYniGK2NcbIQxk/B+BR0/AY8XM8DCzzXNb4IWWA+dmO0VoDxXSgVC+YYYmNinMQxtmUTBD5REnHFlZdz+tRZklSiZ+p4gY/r9pCkKTKVNBoNHMcl8H2mpiZxXQfP87FtiyRJsuOaDfF1jJmNOXKSHYcijhMKBWMY7TjmvJQydf076gQwBsyuY2M7LjO1GtPT09RrdeLYGCzHkTGZ7uvrxXEdZmZmkFJmyZ6AILBJ0phSqYimRbPVpN0Ose1Zw2iUAqFASWzLwvN80kQyPTNDq50QhiFpkoCWRhFRKtFTKuI6LkpJ2mGInBhnpjbNdK3GSy+/zOWXreZd71zL4KpBbGEh0IhMadLpe/M6/iLd+ZxyR7pjqDzrm6C17jg7d72dtegUPNJzdrGY28IbwUre39fhfmKY5KEqnLyf1qdAbv8wxf/1MiymiX5+mOihr5EcGIHiMLQWD6w579mMd9Vu4pOgH/wM47UvUfzsjQSVkOT5g7S/a7Yhrl6PPn743A3Ya+j9z3NKl2ypcmbHn1G8frFnt2GsXZ9ksBMft9fRe+8Oxj9q1o23HObU7V8iuHkjhYEANXmM9pPfIvx6x+R4Pe5//vCrqvuvjhxkYomqMfMZJti0ltIKtXOXq9bByQXtxFnaTz1Ce3fHJHc97u7b6JvzbFT8wDbqV+8xtea//IeM/vxLBB/dSPGqPmDutTLHfikOKil94A6am/cR7a+iH7qFqWe30fzsbRQ2rcFhmujnBwn/eu5z/r2UN82vH9T3ia8Q7v0QyfEqatfvM7Z/B/5nbjDXIzpL+Ox+2rt2obL3DbF9B71zS6Be0v3Vp/dPPkf7oV1oDpN86uOc/tQ2vA3DMHqU+O++hewotm/93PzzYphg82aip/cD+4g+fTdnt3faNiQ5fojw4T3ETxwEhqFYZTFDj+C6z+Fv3muu0YMfYuyFnQRfvIHSVX1QG6H5xN/Mnt9i73JLUdxIZfdtTH5hD7T2EO66nuZfb6aUfbwSfSN/z8h5MyP0skMpcnJycnJyfrc58c4rl1/gmjspfG8HqxYtSRQx/fA91L/yyDIbGEZ85K/o3bWZngUPhpO7r6T5IHDdA/T97QIjtKn9nL7u48i5D86v2jCtSvXT7yF6GmAHpV/fycBFb2s+ae0Yk7vvIfrhwsTMYqzBuusBej+/nvLCh+XRvZzatB0FWF/9+dLmbcssV3/sdqa/vA/Ygn/gwXlGacu2+TxqjP35dYRPzH3JvljDvJyci2dyctasfWDg9Q+1zN2/1c6+D1nCQDMnkcBswFVny3R/apEFSs+tEa/Pl0hQRokglWR6ZpoXfvU/mRifoB22CaMY27GxM2PjmZkmZ6tjaK0oFAKuuvJK/GKALQSoTmkaCdpCKmOIbDsOYWYM3EkSJGlKMzTGyJZl42fBeCFE17A4CIJ5ZW6kUli2TRLHaKXwPA/P83AcG7TO9mdngXOLMI6wMiNj1/EAUz5JKYXruyYxYTuEYRulIE4SkjjpGkdLJdFK02pHnDp5GtsxCYtyuYRGELXb1BsNbMvBDzyEZQx8Bwb6CQoFHNs256AU/+8zP+M3L7/M0OAAW2/6D11jYCklju1g2ebCWJZNKo1BM1ikaYLre4TtEK2Ml4IJ/sc0mo3M3DpFa5NoKRYLlMplpqenmZ6pEcVJNxHkeQGmvJIxH5ZKk8QJURyTJmnWdilaK3zfx7YsXM/FdVzaYUjUbhMlCY5lUSoVCXwfxzXqiFJWXimOYxCCcrmM73uUyiXQmt5KhZ5SiVWrhrjiiisY6OvDd41aRRjXY9N/xfzgvsBcPwRdZcbCJTrLAd1lRWc7WQJOiNnEgrGlsAELSwj61rzzfF/R15wVu7+3DjP6kc+QvLBM8PqaOyk8eCPyox8kPgnc/g9cvmP9vAEU4aH7Gf/U7iyIfS7iEz+i7wOHmfrYbpZ61gmPfJuJW3ehlnQbXoP9lw8xcOtagnPW3cPEp+7pBn8XpbgZ76H/k8F3V17x4I/ZZ5hXwpzzXIF27h7DdQ9Q/sSLND99/+IFt4qb8R7+Lpdde24B/vTkfqqfzpJQSzKMdfcPGPzcunPaeXkOM/rODxkD4vM+zy3DnGdJ99FTrN6w4HM5wtjOuwnP0/fFzQ9SuXcLlcUCwK2jnP3T24kPjCyzBdMO/bevo7jINi7p/vr43Uzfvcx70IadlL93B/0Ly2zJEap3fYToyWXapX8b3kN3Yn3n/YRPsPi1liOM3bOd8LFFEocdFnmXW+5dwVCl+tkPEu03SRrnb5/h8uvm9PNX3Tfy94y3Iq/HM32ttnwps5Xg0hrUmJOTk5OT84YzDNesxfq9Lbg3baHynuFlRob49N16H8XrtzH96I9JnjqIeiGrbbp6I9b1Wwlu/zC9V12EiqB/MwOPPcDUf/k+6YHs4fiZF4klJsZwieFU1jJ8748IP3+U+tP/SPLPh1HPH5xVdRTXIq7egH3zFopbNtPb/4Ye7gVQYejeH1GtfI14377sPPaZ2sP5A37OW50suNoNhi78GNALPpodn935bf6yJqmQBVu7pepNEkIqRavd4rcjLzE5PUkiUxAC13VxPAfQ2Fpw+ZXDICCOY5IkxrJNokAr1Q1Ca62MobEy6oI0TbMR72aUPkKQpMaM2XFcHNvGEqZYiOu6RFGEZVmEYYjjOCa54DgIpWiFIQKwhPEgmDVLNttSSmXzJGmS4HouWmqaUZOgaw7dMfuFRMZYjoWNhW1beK6H7/mEUYhjOwhL4PshUkpGXj6BbbtEYYzSCq1MeaN6vU6S+gwPD6F0yvT0NH3A4OAgrusQR1E3OWLZVrdNwAT/O+WOhLCI4yibFoRhE9txSGKjXGg0G0xPTdNoNklTo2JI04RWq4Xv+1xx5VWEYYtTp04RpwlpoghDM9Q6SQXtdkwrbKOVwrbtWQWC1iRJglIYpYGAMIy6fgzGaBuUlPieT6lQQKUpVrFIoVA0paBco2gwZZyMisF1XdLUKCzaYUgUhtQbDcbHxxkcHGTNVVcxODCIY1tdpY1RYFjdvjnbhzuZtDnzhcjcEDp9v6PYyZYVC8KyAtAi+w506iid+916I1ix+3txPasf/ycm9z5K++9+PPu81L8e67obcT+6lb4Nw3hETGweJn6oamqf37WegTnxu2DDnaw+cANT39tD/Ng+1GgVWIP4wDa8T33UbOPQYZaLmwbX3sFlz25l5rFvET66/9xnt89vY3CJUjvBtbdx5TNbmNy7l/C/P4X82cFstPQaxLUbcW7dRumm9W+cGfMKtXMH57odrHrqvUzv/hbJgexcr96CffM2Sh/ZTO8SQ9idqzZzxb6fd9tpauH7DwAAIABJREFUXp+5eiPW5m0Ubt1C5WKekV8v7DUM3fsjWp/aT/2hfSTPHEQfzwLfqzdivW8L/uc/TOXqCt5S2yiu47I9P6VxaC+NR/eRPnMIPZoFjy+wHS7l/trzR/dhX7uF+jcfIXm687y8BrFpM+4n7qDnujWLJkew1zD89X9iZuuPaT70Y2TnXae41qx7823ddWsbNhM+sR+e3kd7dCs9q+dvZ+ir/0Dz1n3U/24v6YJjcP74Nipb1i5+DMsyzMDOnZzdvx1FlfQLuxl/ZierOgmRV9038veMnDcvuSIhJycnJycnJycn5xLlklQkkCUJFrxGzH2tmDWuNckAFkkizFUudKrDz44AJyshpImSkBePv8jo2bO0Wi1korCsrGyMZZYvFAL8IGBmpsnpM2doNloMDg5Q6ukBNHEYmZHjAhzL6Zb20Vpj2zZKKdI0RVgWqUxpRyFhaJIGlgbbspBK4WcGxZ7ndQPutm2jyEyLlQniW5bxXtBaUS73oJRECJNYsCybMGzjOA4qixnbtoWUCqlSHNfB9Zxu4Ny1PEBk3gdmf52ERhzHpFJxtjrO6VOnCdsxrmvCUR3j555KD5XeMuVyGZmmSGUKOptz0fx/h37Bsd/8lquuvJz/+ME/QGuFQKBUiu/7Xd+FrvpCK+IoJkklURhRq9VIkpRGo2FK8giLOInwPY9yTw9aQa1eI44jpFSEcUSazqpawjBkpl6j2WzSDkOS2KgtTPdQKGUC8DoLrlu2wLYEjmPUEo5j47oePeUyBd+nVPApV3qp9Jhz7ioGsm2YpILA9RyKxaK5tmmKbduZSbRN4HtUyj0MDw2zatUqyqUyrmN3S1bNRQgxq0joqBLmqRe6moQ5yzOrSMB4VBjXZbCFUXyAoP/ta8nJycnJycl585MrEnJycnJycnJycnJy3mK8sjFIc5MHCwsbzSdLNswxqFVKESUJIydHqFbPItMEC4HUGq00hVIBjcZ1HDzXxXIcyuUihUJAvVZnZmYa3/cJ/ADlOKRpgrCs7vbjOMbzvGw6AgRaKTR0R7ynaYrnuCZRkKZYmRJCyll3RSHMesIS2LaLlhKlVFb+SJGmSeavoHFdjySJ0ZlhryUyc+dMIaGUUS8IpVHSnJtRUWg8z8eoFQSe5xFHMZZlU3A9+vsqyDTlpd++TBRJCoWCUVmkCe12C9czyopSqUjBDYjiuNsOaSozrweR7Uua8weElWZtYZQUzVaTMDK+Dc16AymhnSkLpIJ6vU65XGJoeAi0ptlo0my2TAJIKeOlkSkslFTEUUQYGfNqDTi2DZ5F1A6RstMfVFetYgL2JoGktMQVHp7tUQyKBEFAsVikWDBG2pZtkyRJN8Df6Vt+4ON6Ab7vmTbXRr2RJAkASWQMs5vtNuMTExQLRfp6e7ni8su5bPXqzFxbd8thWVZmwtxxuRWZAqH767meB93PNGjR0SzQvSYmWZGP98vJycnJycm5tMgTCTk5OTk5OTk5OTk5F8hseHTe3KVEzudUcJktcLTsXrQmTVNGz57mxMiICbpjgda4rk2hUMRyTJ38VKZgmaB/HMekqanL32y0aBabuB3vAkwCQmKC47PlbcxI9DQ1wXMz8p5ueaOOaqFUKiEsC8eyumoA1zUli5SSaAQpKb7tIFwXyxIoLdDKGBGbhEXSDRR3yvcoZc7VdV08zyeJEmzbMscqjSeA1jJLQGgcx4UsUN0phdRb6cFzHXrKJSYmp5ianDKBd9tCSk19pkHYipmcnMbzHYIgoFQqopQijGOUBCUVYxMThGGEbbvIVGJZgjiO0EC73UYIgUwlcRxniQ+IIlNKqq+/l0pvD7btMDE+SbPRIIximu0WaHBct1vzqnN9kzglVcZw2QM8x0PKlGLgYdsOSkqyyDxaGh8KtCYoBHiug+f4uK6N77vG+8GxCXyTJLCzpFHHlwIgKBSNEqEQ4Ni2OYY0xbbmeGRkZam0VLQzn4Zmu83pM2col8usvuwyrrziSgqB2Y/nuUitsNSshwaorgFzN4mQKRBmvwvZF6TjuDzPa0ReEnbLOTk5OTk5OTlzyRMJOTk5OTk5OTk5OTkXRlamaCVinPMVCrNKhI6Z8PTMNKdPnSKKonkeA57nYVsC1/OwXRutIUkTpFREcYSTBXPjJCaKQqQsIpWk3Q6xu/4GNsViiWIhMMbFWlMICiQyJW63SVNjfJzECZZt42mF7/d0lQqu6xrzXiBJjQFxmO1bWRa95R6SJMJ2HRNkzmrZJEmCZVkEfgDCJBFc1+t6KnSmAXzfz+bbOI5AKUkUJfi+jUxlN8EhhNUtQ1Qu91AolVi1ahXNZpPTp85gWQ5aC4KCwhIQRxbNRkitVkdrTW2mBtokCiYmpmg0mljCwbYcNDILggtUx2Rba6IwJk0TpJT09vWxauhKhBCMj4/TbE51r1OnxFMUR0RxQpKmaLQ5fqURlm2shT0Lx3HQSuN5LgiNnfkapElCUAiIo9gkBRyHQhBgC7AtF9tx8H0X13MIsnJSlmWbtrFMu5GpOCwLU/opMz2WUmJbFqmU9BQKtFqtrhqm2Wplfg3mcwGEUcjk5CS/fP4F+vr62LDh9xgc6DeJh8z0WyyofdRJIsxNKHTKes0rgTRrtTDv95ycnJycnJycS4U8kZCTk5OTk5OTk5OTc160FrMDqhcqDeaUjpn/wbnLno8kTanVa/zPF39lgv6uiyUEQjhYlsDzXBzHyQyUodVoobQmSROSODYBaa2Jo4RGvU5PuUyj2aLdbpkkgOOY4LtW1BvNbmIgiiNTfic7H6VMYqKnp6erTNBaozIPB9s2wWrXdYji2Iyqd11TtkcpXM9FKoXjOqY2f1YKx6gY0kz5oLp+Bx3/A5McmG3XJImz0fJmdH2z2cR13a63QxzH+L5rgu6ppFIuItAUCj6rLxui0WhRrY4xPTVDmkiKxSJ+oUDYjgFNs9nMzkuZZEw7wnUhlGHX5yGJIxAWlhAUgoDh4SHK5TJ+4CFVShzFTE5O4vsuPT1D3WC6QJBK45/QDiNa7TbFYpF22yQWpFTZKH5lTK8F2JbxjEDTDeI7XifBIlBK4zlGVWAJO0tyKARG5VAoFvBc42Hh+T7SdbBsC9dxkcqUbVJKEesEP/Bpt9td34lOGSTjhWAUBp3lO4msVErGzo5x+tRphNC8973vpbe30n2xtoTVLXMkxKwCR3QsxzND5a4hueioELLv1xx1Qk5OTk5OTk7OpUSeSMjJycnJycnJycnJOS9i7tBpMzQ9K9OzdNRzNlBqfp9nuTzHD0GDMfVVkmarwfHfHKder6G1xvd9409giW6JGplKHNej2QpJElPjP4oilJZEWXmjOIqZmWlQLNZIpCnHo5QidV2U1qRSAdqMVLdtdKY28H2fdhSilML3A8IwRAhjTqy08VCwhBlBD6Y+vtbalO7JAtFKSWzXQUuFsBy0NAoJxzFKBtsW3eC01grP8zMT5hZaY8r6qBQTeDZ+DoWgQOIYBUKSJF11RBAEWJZZJ2yHFItFeisVkiTBdV2CoIDnObzz6n/D1NQ009MzTM/UAI3t2mbEPhZBEDA42I/nuLTabWQroVQu4HsmOdLb2wdo42MA+H5AO2xjaxclFZXeijkWYQyQLSGwLJt2O2RgoJ9ms0mj3sBxXVrtkERKUilRUmVBewekBDSua5JBVqYuEZaFLUw5KYRFoRCAVjiuKcEEAtsxhsrCNmWuHNcxfhK+SSpYtkBpugkYIQTttvF36Hg2WEJ0vRXs7KdlWeaa2+ZnkqQkUUwURZw4eYJ21Ob3fm89lw8PmwSELeYlz0S3/ytmswcs8r2Z8yHkyYScnJycnJycS448kZCTk5OTk5OTk5OT84pZ0hdhqeUX+V10kwmgNIRRxMjICPX6tBml3jUbTnC9Aq7jdv0MwjAkjiPiOCKKQpI0RaFIU1MaSClNOwxptVtgCZI0RUoTnE+lxvd11xPBDCIXBL5PmiZdVYElTHDawqLVbOK4LrGOjbky4LouSZLgWCYRASA8B8uxiJOsFI/lkiYpUirCsJ0pJkwiAUtgObYx3LU0SI3j2CAglQrXcQBNEBSypI2VeUAYn4WOz4EQFlorCsUAmSUoOqV74jimXC5TKBQICgG9/b2sjiMc26HRbPGLo79CpQqtNT2VEoXAo1goEUVtPM8jSVKU0gSBn5VRUrTbLTzfGETXGw1s26ZQKGBnSQbbcbuj+73ARylFsVikXC6TppJVQy71eg2lTQmjJDaJkU7JoTiOsISdqQBsXN8kBXpEGaUwiRrbxraFUSQoo2gQgG1ZKG0SPJZlPi+XAizbJIkcxyEMQ3zfx8uUDhYCkakIXNf0sU7pqk57d4jabdrtNpZtIyzz7/lf/pJ2u82aq9ZQKtpYShgnZQu6SgNMIk3orMyRYF4iLqt0lJOTk5OTk5NzyZInEnJycnJycnJycnJyXjGzAdCljJbPTR10xlzr7hwzV2Xmu2dGzzA+OW7K0mQKAKUVQVDIRrtbRFFMGEaE7Yg4jQFBnCREcWQSD0rjOA627dAOW8zUapQrPeaYMesrrU0AWQiU8gATgNba+D+4rpmXpilBEKC1JvBNQFxkSoxSqUSr1cr2ZZlAtiWwMxNlx3FxXZ+oHZtkhGV1S+UYj4YCKht1r7RES0UiE1zXI5ESz/exs2NIU2PS3CmNZAyEBa7rZOWNEhzHwfcDkiQliiLjNSFld59RFOJ6vgmUu2ZesRRQKBRImy1c18F1HGzLwnVtbLtolBi+T5oqnGxEvpSm5JAlLKRSZv00NebUtt1Varju/8/e28dYdt73fZ/n5Zxz750ZvizNlT1WV0pZYSVzpaxYrqtVJAWWaxkJBcgNXYMFZDRCYSAVXBVVCpmG3MZpIzhWa7UgDAWwgCoFFIR1pdRKTTemIAowncjO0uTKHEYc0WtJK3JM7lKz5M7ce16et/7xe86Z2SXFF8eOlu3zIXZ3dubec895zr0E+fs+3++3ou26fL12Ou/FfI5SUlrd9h0kWMznB5FDbpDryuXKlZXz7Yc+xw6JuFFVdhICQghUtpI11iK2+BAI3mNtdUVslPfSJ6FUdi5kASICwcvaHRYP6rrOPR1yDc9feo7BOzbmMxJw+fJlUCr3dAT+g3//FuoqnwsSc3TgPhg/AWoSDsbXUQpiRMSPQqFQKBQKhWuQIiQUCoVCoVAoFAqFv3QSY6SR/DaKCREpS/6zp5/mqae+Q4pxGvqCoZ7NiCHSd9IlsL+/ou8dxhpikqFsCImEZrXscjmxlZigCKtlz/rGdVhb4ZMnRo9WiuA9SYuw4ENgbTHHh8hsNsMFL26D5PKQ2orzIJfvjnFDWmv6vge0iAm6InhP09Rorej6nqqqJFpHaTlWXaF0IqSAVho3DDn+Sa7bBXFEWGtwvfxMawMkjK1Z5U4DrWXXvOz8l+G+c44YRXDweShe17WIB0ZKmsWpIKXGIQbZJa9G8UVeRymw1hKjDPerykCCrmtp6pmIE9kVMPZjGK2pa4s11ZTn09Q1dV3nfonIYr6OGwZiiqBgvpijkfXsui6LLeJ6qOs6xz8llBEBQSmYz+dYO+QBfKLJ0UXGyDnK60WMVlBX4uKIWejIToPRORFjZIgDfnASO9V3KG3oe3EsjPFGTdMAir7raduOkBAnCQmfC6B75zn3zW+yv1zyI8ffwsb6mrzLY3YiaHUo1uh7uQ9SFhiKmFAoFAqFQuHaowgJhUKhUCgUCoVC4WU5GG2OxbDqqmiWl446UpMX4cCPEEn44Ln03CX+7M92cM5lR0CF5N5LgXDf96gEXT/Q5cH/sl3ig7gDBucYnKNrO5pmlmN+5jz33B7eeSltNjaXGisZ/PY9iUhTNaQkpcMhBlJK1DOJwGlXKynPzde3WFsj5dLdEELuIbBTd4McX4qCQ4goNDEGKR32HoC6rvDB4fxAbWdYI/FN5GNImXOia1dYXWEr2VG/Wq2oksoDfokuIkFM0uUwDD1d10+lzOMAfBRlnHcMTgqqZ/MZTSNCAuOQO++E11pP90e6C/S0698ai/OO+XwuUVIxToKBtVKWPK7NONwf8nWTIsvlnlwjipBS7lOweOfY2Fin7wf6vptcDZPjIEZmTU3dNPleyM/H/oy6rjHaZAeGzoXaEmdlrEYjx0kp5XLnhHMeYzR919O1rXRPjCKDYnJzSD+HycXXLrs/KqpaBJMQIypG/OBY+sAT585hleZH3vIWZjNZf5VUjjVShz9I0/vqauHg5bpHCoVCoVAoFL4fFCGhUCgUCoVCoVAovCJU/v3VtSNc+fypaDnvUr98eY/vfOc8q3Zf+gGQWKCUYBg8q7bFh4BzQy7BtYQUSErRDy3Oebq2AxSrZUvXSsRR08xQ7BFi4NLuJW76gZsg9wwoFLNmxjAMOO9RWtMPHnQvhclGInKsHnfcy4Dch4DNjoRxWB+jYbHYEBEBLX0HgB8cSlu6dsVsNpO+gDwYN8ZI1I8XQUBrQySSkOE6EZSxWGtzL4GUN4Pk/qssbrgxAiokQFPXDcvlEq117iOQYb8M2xtSkvgh5xxqVkmxsD/YrV83Da7vc7eDyb0SIlR4L8XDdnRnWEuyVgQDrUkx4mJE60BdN9J5QKKuKtq2RZGwdS66ziLHMAwMccBlZ0WMYXIiADjnRCQAOf4w5HuhiNkVMnZBqEqeP/T9JBbFlOgH6aqoqorlcin3xsu5DUOka1v6rqdpGhFBYqBpZhhtsON9ilLE7JzDeSe9Cxvr1HXNMDj6fsA5n10hA1/f3qbrOt72trexvrZAK02MSVwSjKKbfglnQqFQKBQKhcK1RxESCoVCoVAoFAqFwitEpIBx9nnYjXDF1/LDQy6FdMUfACEGVl3HuT/9E4ahYzaf07UdVVWRkmIYBtqumzLoU+4CqGcSGRRCJMRE13YMw0DwidWqJaVEVdm8m16G5n0/0Hc9dVNjjMFWEkGklHQayABZnAuj46Cpa6qpbDhgTH5O3tGulJT3yvF7mrohRD91EoQQMIh44HNWv9aGEGUA3tQzUkys+hXrG+sQIIaINTY7MdwUieT8gLKGEDwKhTE2x+/M5PjOS+dDdlxUtsJog0fOJ+YC5rEfwEcRGFJMeOdRWjFrZFd/ynFFALVu6HvpLOi6NF3b4f6Aw9+bRJFxDZuGtm2xec1iiPhcoDyWMZPSNMSPOdbKZseIFFNLf8b8UI+CqeTnY5zT+NoxBOpGuhl8DLmsO03PGyOpUpQIIR88Qyd/H/qBylbUjUQjxRiIKTGva3zwpJi4fHmPlKBpKlJK9P3AMPTT5yLGKE6Wvufct75JNas5/qbjbKyvU1dV7uBQ2Z1zJcWFUCgUCoVC4VpHv/xDCoVCoVAoFAqFQoE/txPh4PlpKlde9R3fOv8t+r5FG4PSSgb3PrB76RJt10t0UC7RHSOD+m7ADZ7lckXbtrRtyzA4lqsVIcZpF3pMUgQ8dhR0fY/WMtD2TjoWFmuLqXh3NmtYLObSvRACMUSapiGlOA14h7y7XcSKCqUU8/kcpUQgEKNFou87jNGkFKbyXCnwjaQYsdpSVxV1XbOYzyWiKMgufJtjeSSiSdwRaMV8LqLBOFxfLNamHfDaGOkSUCIyVHUtxc/GYIzluuuuI4TAfD4HEsbk9UQRvJP6X63p+y4XOh+UTSvFFJPUdV3uTJDoKfm5OCHG3gFgGtrHGGmaOpcky3PGeKHRoYFSUzn0bDabOijGeKNRtJAuCokc8s5PxwA5P601s2YmAo41hBgnsWF8Xt/Le8o5h/eBFKV/os4RScAkcmhjMFozDAMxRpwb6HvHrJlz/fU30PddPl5gGBxD73BZ0BmGnlXb8o0//VPOPvool/f2ZT1SPOTGefFP08skhBUKhUKhUCh83yiOhEKhUCgUCoVCofAKGUuS05T7fuhHL/6MdOVfpNNg4MLFC1x6bvdg0OsDbduxXK6mAbBSisENaGto2zbn2lvarqPNkTRdN8gOb3WwqzulBAmqupLhfUq4wRFCJKWYy3OhspVE9iA9AlrlzoFcEhyzaDBG4yitSUBT11McUAgh78SX6xidECJaREKIuShYZUeCFC6PLoEEeegegByh5F3+Wnbtz+ZzGbaHiFY6fx+U0qSksuNBdvIvFgsAnBuw1jKbzXI5syaliNY1KoqooZXO90dRWYvRIjyMcU5A7gjQGGOmToKqqogxZVeEmcqZvZdoIvI1GaNxTqKjQBwAIUSMSXSuk3Ot0vQmGUuiQfoPYoyTeNE0zSQmKKOn4ugUIySJPTLNjMpaKq3p+p6u7yaxYXpfjG/FmLKLQ+7VbL6Y3j+z2ULcHznqyBpL27bEEKhsxWzWMAwdbuhpZvMr+heMycJRCOzuXqJvOypr+asnTrC+tkBVmrF3+eB81AsijoqgUCgUCoVC4VqjCAmFQqFQKBQKhULhFTGJCHCliPA9HpuuSjSKJFxwPP3sM/zZ0zuHxALHatXR90MeVNf0/SBZ+CGSogxm264jxDQNpNtWBssxSiFviNIZkJKm7bscVTOj29vHucBquaKqDFop1tYWpCRZ+aMrQamE0hVVXWOtIQJGG7quy1n5ATWb07ueppJYo3FQP113AmtqGfzr/I0AVVUTUpDegRgwOdpHRACL1rkg2A3ivHAdTT2TQuSkmDdzcQwYQ3A+uwEUMSaqqmYYeoIP9EMv8VAxoQxZoFCAQmuVOwg8Ifh8LlGcD4BWmhCiDP+VkULmHAtkszNk/GU0NE09FSuLUyLmHguTXQw1Wsvu/hCkdHqe12sxm0u/QYwoo6mahhQCIYYs+KTJtTEeM2WxyForf8/uCGMMtRVxxqWEyiXQVmvSVJIsRcpucMSYSFGEJkjYyuCGgNIK5wd8lCilZbvMDoyatu3lfazk2HXdHHKFiPAzDAMxjd0HiugcQz9w7k+/SYiRt936I9x0w43oKR4LrmxfltijFJUUYBcKhUKhUChcQxQhoVAoFAqFQqFQKLxy8vAzIbv+x3Fnmr4Y/xxlB4n8iSkxBM/u85d46qknpVo4D3z7vqfrOrwLpEQeHGsGJ2XI3kvU0JRL3/eEGPHO49ww7bhXSCmvMYaoZQe6rQxaK5x3pBTxXgqNu647yPj3nrqpaZoGmyOPvPME5yUmpw+0bct8PpMhctVMPQhjrM5U+qsULjlsZeldjzGKqrYE57BNTU4UYhgcVWWnc4dcqmxkJ76OmpiiJOHEQPDSORBiICrQWp5b14auayWqSEk8UNd1U4eDxAxF6lrKlbXWUoSsE6t2KUPvHINkrRQji+NByrAlkkgECelQkMLq0S0x9gL4XPwMUmZsrSXGSAh+im0aOwuaupbS5SyGiEMkEZFjhejk2Bx0MYwOkDEyCchxV4kUEzEEbFXhvCemmHsI1CRCjNcACW0USYOxmhikD2HsRhDBI033V7oXIvv7+/jggBpjDRyKaEr5PtV1Le/3mLIrRW72crXiG088QQyBv/rWt3LTkSO5N0IfOBGSZiwyV+rwB6pQKBQKhULh2qAICYVCoVAoFAqFQuFVIePdg2ijBHB1WWwu0pWfi4vgueef56mdJ1HWkAafi4odq1WL1gcZ++MgfHCOmBKXL19GaU3Mg/uu6xico+8GKcWNMRcGN7LTW+uphFh2+0vvgQ+emZXHVNbmrgByL4ClbiqausquBfJA2JJSP5UZa63p+g6jzJTnP+7Yt1ZNO+ZDDFKwS5yikchdAV3XMZ9JVE9lK5TSuUMhTdejp5LkJM4JB8pYnBtkoB+jdCEohTVWOgWUou/dNNx3bgDI5y7uglFoccERQ2Ss/h27JJqmEXdDCDk6iexiyKJAlMG7cx6tRQQIQYSDppnhnGM+r+m6Nr8zRKQIOcpJ3ipp+lMrRfCytsF5rDEEI10XOq/lGHc0Ps9oIwKP8wxZKLB5fSUuKhc/G00cpFNBoocstqpzQbN0X9jKEoKf3tVGmykma4xrWq1WBB+zA2IUSAI+SAeGzl0K3kPV1BgjUU6jW6Jtey5cvMje5T32l0ve/c53ctONN05xWKMcl7uYIal/6z6SQqFQKBQKhb9oStlyoVAoFAqFQqFQeEUoJb8l2eydvz4QD9KhX6SDYmUfPHvLPXaefop+GHDDQNf27O+vWC7bg2FtHtAmoOt7+r6nXbV452lXreTetx2rtqXvOryXiCOJ7Tko8K1shTYaYw3WSm69UuAGh9IaW1l0HvZaW1HXDU1TU+Xvi4tBE1NCaYW2WmJzhoEUx54CnTPxTe5AOFinMQ5IKY3RMox23ouDQ2kW88X085jiJFCIA8DKDv1Dw3ZjLImI9+KQQElPQCLl87XoK3bdkwUSgxQcI5n/k2giAkTbdnl4rdCo3KtgDu38l+fMZjOGYSAlef7Y7zAKRyEEjNHyGtlpMu7WD95jrQzUm7omxUjIoonRGq0N3jmJIjJjV4XKr5OyK0PeS8FLyXJKieDFXVBV1eSaCN4zm0nhckxJXCveTyKN91l0sGZyn1hrqap6ugdjUbS4VwKkxNAP9F0vpdFNg8vHQZHFEZFjQsj3OAsEwzCwaluWqxV7e/t899ldnviTP+HfPP71HNMlTgbSQSeFGH3Sy0aHFQqFQqFQKPy7pjgSCoVCoVAoFAqFwqviRUNXDjJapjFoAkIMXN67zLe+8y26oSOlyN7lfbpuIITIcrkCZNAdwgqbs+4H5+j7Huc8XdfjvMN7z2rV4r3PhcyWummwRqO0DLyNsWitscoQrUQnzeczulVHcJ75rMEYfWg3uJQCa6UwWudhN5Ldn3esp1UixoTzkTpG7BRbk4+Q4hTlM8Yc1bZBkXBuoLZSUqzHYbOSx1R1jckDc6UVdd1ItFMYSAqssRiTCMFT1RXd0FHlHfWLxQKUwgdPs6jpW1krKe6V7oQYwfvIMDjW1hZopXFDj9Iaow3WiBtCIw4OrcnDdg1Y6Z4IkbaRQKFYAAAgAElEQVRtxb2BIimdY6YknsmYiqqy+R5KV4BKEWM01mistSzbTqKAtGaxWEwODpdLpQG5n1n80FpD7ghIQEgRosJWFUYbog8ioiiFNgo39FhjRfhRirqqGbyb7oet5D3lvaOqaqqqyu8Vk6OpQKns9rAmO0QC8/mcdrWia1uc9yzqObP5DGtFtGlMLp3OokBV1cQYSDHke5nYXy5ZLvclEmvWEH3k8e1v8Lqjr+OvvOEN2NniIM6I0cMxflUoFAqFQqFw7VCEhEKhUCgUCoVCofDKmbZOXyknXLGDWsnXIQaW7YqnL/wZq3aFj5521dH3Pd6HvCM+TTv4+37A5d37XS/ly13bMQxSDtz1PW0eSsvAWTGbiZNgHMQbracYJGstMQSuu24DP3i8GzBaonzESVChlcKOJcJKegp0jgpyWnoBtDYEFaceBCqJCWqaGd5Lnn9Vjf0AMsBujGFwMrTXWmGspaqlsDmmOA3CQ4xUtqJ3TpwASjoTImka5CstUTfGVCjUFGOklcI0FV23mhwCzvWTmDHGEM1ms6m0WGst7gUFMUVQGhQYLfFKEuUkg/6Yo5Cky0DWJuVuA9n5rzBGEyNopYhJHBFKKWojLgE/DNN9kL4Bj9IGYzRGN3R9h7WWoe8hx1spxCkSYiAGcQVoJbFRjCKFtVJu7BPWSvdE8o6hlzUf44e0Nng/5C4GEQG0NtmZMMYUjS6SlDsr5L3tnCMEeV8ardFG55JklaOTDIkgYlMuTw4hMGtmWXwxDIM4a4ypmM1n+Bj47u4uf/Twwxy54UYWszX59CSpMFf5Oq+ICSsUCoVCoVC4BihCQqFQKBQKhUKhUHjVpBfdMD0FG5GAVdfy9IU/Y2+5j/Oe55+7zDCI08CHQO/8FCUzDAOkhBsG+kF21zvn8V52xMvXEh1jqybveDfUdYWtDLNmhq2s7FhPCaiAhPciMCz3loAUNK9vrMsgWCnqqspDW/FRiAgh0T113Uh/Q37sGHlT13V2RXQHET55UD4OgSWHX1bFeel66AeDD152wGsZwi/WFvR9Dz6htAyvUQqjNG3bEmOiqitsZVnMakKMaBQqdzUo53DDkOODNFXefR+CRByN0T3OuYPhdy54lj6BCAq00RLFlIWBUUCwlbgW+r6nrmpCDFO8kPx5sJveOUdVVbkUu8uihEQWBZjEnRAjMYRJfKmMQTU1Gn3Qb6AUtqrpQkuTH2eywCOF0FJOLO4SWX8fA8SANRatFD6JMKCAtbU1UopobaauhXF9vJcuDaVUdrroXN6tCD6XQmtYW1/k95TPIsFAArQxVLWISForiauyhr4fRQRDXVU4N9D3Pc8/9xxawbPPXmTzdT908IlJarr+9OIfsEKhUCgUCoXvG0VIKBQKhUKhUCgUCv8WpKv+Jtn0q7Zl5+kddp97jq7ref65y+zt7ZMStO1KioEHh9GGEAMhZ+F3XYfLJcvtqmVwXpwKzhFjwlYV1hiqXIpsjMkxNWM8j54G+FrLQF8rw2KxkLLgJMeQsmVxJSTSNDy2xjKEAYWaonfGrH/VNOJOyANx7/1UuDwWJVd5YOycw1QWa03e2e4J0UungdFUdS3dBdFDdiHI0Ft2348Ci9YSuRR8wKiDLoWx7wCYhuAhSJTP2AtQ1zU2X+cwyJA7JcUwSIRPjPJ6pEjT1IeOoUhRFIJx+G6MOBfG11RKTV0KIcjwe9Y0JMiihXQENLMZbdfnSg0lUUpZeIgxZIEmXhHnY40RSSoEog8Ya7G5AyLEkLs34iSagJruxVjqPO7oTylirMQlWVvTdR1VVWWBpWK5XE7Xo5SaipLlWIHl/hKlLSoFFovFNOSfip+zkCSdIFBVIjI5N0wdHrJ+VmKQ+oFhGJgvFrkjIYcZKfnsKMa+hCIkFAqFQqFQuLYoZcuFQqFQKBQKhULhVaKuKBc+iDWSeJu26/j2d77NhWcv0vU9zz33HM899zx7+0vZpT04XAiE/Mv7gHeeYRjo+4HVqmN/b0Xb9ezv7dP1HSHEPFDWNE3N2mLOrJnlkuQ6D7VzJr4106DdWosCmnlDVVe0XYdWmspaKit9CrP5jGpWU9cVKUZiSgyDY7lcTu6CcVg9DD0ul/eKeCCDa+ckPifFCCTquhJRwOhc+CzlzHVdE3PpsspCh3cBozVuGFBaTdn+dV0zn8+pmzqvVaQfevosVIwRRsZalJKh9hgtpPW4U98To2c+n08xUuOAux+Gqc2isrLHTESK3OFQVVmYcDRNI6KG0Vir5a6nkF9PYpLGcmNrK7S2GFsRYoLsCqhsNRUfj3FWWhuc81lUidNA33uPy+KAzV0GKSUG50kojLGydlk0GbshqiyqMIkx5PM5EAhG14gUNgujo2Q2m0uRMlLO3HUtwUlHReLgvMfrHsUaW1XMZ/Mp+gnA++y4yZFJUgIduemmIyzmcznHFK/8aF0r+sHFB/jU3Xdz9689wIXD3/e7nP3N+9k+9K0LX/4Ud999N5/68gVeK+yde4Av/sFr53y/n2z9k7u5++5P8cDF7/eZFAqFQuH7TRESCoVCoVAoFAqFwqtCRs/593TwzZQSznsufvdZLjx7Eec9e/v7PH95L4sIA4PzuBDo+wEfAm2OOXLe5z4EhxscfdfLr6GfduZX1lA39VSUW1UVxli8d1P57zgklp/JY5qmoc5DcdnxnaahvjYKpRXVOPzWFQotPQrayI73JDvgJXJH544GGfQDVFVFXde5l0DcClprKSFOiZDjdsbd7FprGVwniCHmDoBx0G2wtsoRSGr6PzZrxbmRYiLlnezjtcaYsqiAxCIZcSGkKDv9R8EBVBYDJJKo73uJJkIxn8+pcozReI/Hx5lcLj1GGoGaBIcUIyHEvAvfYa10I6QkZdHBe0x+LopJ5Dh4rTQd22TXwegMMEZTNTUueOL4vssiC+pw2XUOB4qyjqPAML5vxnszCktTjNHQT86K8THj40DhBo/3AaVlfcgiwTAM4uZQIrKMmHzcUawYxQ+UypUi0qNwww03YLTBDQ7nnXyWEozOhGuXXR749Ce59+ELuJd/8LXL1+/lE5+5n3PL7/eJFAqFQqHw2qIICYVCoVAoFAqFQuFVkge36qAVIZJICi7vXeaZC88QU2J/f8nu7iVWbUfvPWiFzzvinfeEEGhXK1bLFd2qo+sG+q7HOUfbdZJBHyNVHvSOu+zH4Wsi4X3eqd/3hBDoui7H3TBF2ECibqpctmulP0Ap6qamaRpSDJAi3jm0Nixmayzma6yvL/JrMQ3BmWJ54jQQN0Z6CIyxuehXduCPM2GTHzfGJ5k82B+GQXapB3FkVOag4yGmSNVIibDzDm2NHFPD2vr6tMNeBtbDFIVUV80UR6SUDNHHaKRxQC7nHyB3LejslhjXyrlhcluM91opiVhS+TVTYuoDsDk6qKpsPq44G0LwU7eEyX0WWosoYm0lQgtMMUPiqEg5jkphK4u2mmY2p26a3EVQY4wheDfFNo1RRuPXzjl57yTpuRiFm0lIyN0N4xpWVTX9ijHSdR2gGPocp2UtzazBZGfJuCbOOVar1SSwHBaoQHobjDZU1pJiIobEfD5n47oNjNaH3C3XjhHhpfG8thWETPTf7zMoFAqFQuE1SelIKBQKhUKhUCgUCq+adEhMGHfs98PA0888LWXKLrC7e4nnL++xWrVSUKsNSkvfAEpJpJEPhCwGOOdo244QAkPf472U90qnwcEgPsY4DeGn8uNpaA1ayXB8HBxj9DTM7/swDaDruhYRQVm00hhbkRLTbnZxBoTJCSDROdW0cz6lJB0LMeB8RCsZWI99Aj546qYGzBVuBO89GikPDt6jslNCYo1kgF/ZSq4hKWLI01s1dhOYQzvudXYzyOCapA6G/kqhtQzfh2GAnOSTEpPTQmWXgjZqci7UdUOMUiwNKgsMEFNCGwMx5k322V1gxV0wFjzH/KcIH2OHRMT7gy4IcTSIeDEWQY+ODhSkkGiyoyMmMEZPHQ5pjANSWRBJUpJ9uOxao9C2vsLpAAdikOvdFCs0dnOMgoBUHiSc8yjSJJSM50hev5RdKn3fA0xixeiEqeoakBipRCDGxPpiTt2I42SMmBo7Nw7O8bUhK4wc/YGjwAU2N49+v0+lUCgUCoXCXyJFSCgUCoVCoVAoFAp/Lqa4GRI+eJ797rN8d/dZeud4/vnn+e7uLqtVy97e/rTje9wdDooYJMPeh8AweLp2yTAMDINkyxsjToQq71jXWgGJGDwuBrogRbzBB9lZrzVp1RFDlMgipVhfX5dBu8Tm59Jb6STou46qrpjN5gxdj1aJgJ920/ucoa+0BmIeJussgvg8eI5YYwgp4oJjLI8Y3RJojzVWHAZG/vfLGClsNtbSzGb0wwAgOfxJVtVWNVrLADynBRFUoK5quraDKWZJ4pGCipBLocUfoqjqRobmzuG9I4QgDgVjiEgMldIHBcMizMgQWyuN8zL8Hn+mJ3FCA1qKq21FgoO4JqWwlZlKhg87Bbx3WGPoB4e1Ca1Dvs/mUGeCCEUhRbwPUhTdd/kcIynJucZ4INio3KPQDwPGWim5zqKCRCipaeA/vgcTKYtFdnJzjPFMKa+pd07cGtZQVTV9J/fJ+4Cx4/VYuq7NkUlyo6rKotSctm3xQ8jrKIXWi7U1VHaFOOfFqRADKZmpIPrg03UNcfEBPvVr9+e+hC0+d/fdwAk++A8/yIkfPMoRNjl6WEfYO8eD//w+Hvj6Dq0HtGVj88285298gHffsvEyL3aBB37tU9zP+/jof/1mzv0fn+f+fBy7tsmbf+ynuPNdx5hf9ay9J89w/2/dzyM7e/gI1Ec4dtv7uOv9JzmSJx9b/+RuPvdofpUvfYq7vwRHf+KjfPTHX0YE8buc/e17uf/h8+wOcj1Hjp3iff/pHZy8KR98OMtnf/letjfezYd/8Q6OXX2M7S/w9z97hvl7PsLH/uamfC/uce5ffZH7vvI4O0sPWOavfzPvfcE6HazJh+9s+e3/7UHOD5b560/z148+xL94uOXEz/5DPnjr1S+6w32/eg8Pdqf40H93J8dfKpOiPc+D/+y3pntmrz/Gqb95F2/4Xo/P9/j3tnfYk48GdmOTN//1O/jAO29hQwPPP8g9v3IfOze/j4/+3fdy9Sr7hz/LL/3mNpvv/zgfedfLvS8KhUKh8P2mRBsVCoVCoVAoFAqFV8TUh3AouGeMwOmd40+/+U3atmPv8j6X9/bZ31uy3F/hnZdf3jP0AykX8A6DI/jA0A/0XcdqJWXM3g9orZjNmkOlyVJaXDc1i7UFi/U1ZvOZ7BYf8/RzNM3oiGhXLavlSgbCSmOMRPekQ3E96tA1hOAljifHE8Uk5znG3Kck5ckpD78B2bmvZLe+sVaG6tbINaJIMeW+Az3tztfGHNRT56x/paXAWpwT9RQfJM4B2f1fV3XehS9DehmGi+Ci0FeU+o5D6TFyR6KXRhFHnAF936Oy42DsjiC7DMZzHY/T9R0pP4+8XqMDwHsv3QXZUZByubLOIoIxYxm0nro1xveTyi6SKWpIKeQsxLEy/ox8PK0VMQQUisE7cae4gRAjMUVcdrGACDaTi4BR45HzPfjeQS/C4bijyRFTW6rKShm0j7ghF23HnEekpNfiwMFBdk4ciDBKJbSGtbU5i/lc3CdqLMKO+bkH63JwrtcQsx/mxG3H2ZwDHOHYbSc5edstHAF43fv42D/8CO+9KT+23eJz/+tnuO+xC8xff4KTt53k5JuO0O5scd9nPsW9X3+F0UJxh/s/fQ9f3O64+fhJTh4/Cu0OW7/9af7RVcXOF75yD7/661/gzE7LdcdOcPK2ExybX+b8H9zLJ3/lc2y18rgjt5zk5BuPADDfPM7J205yYvNqSeIq2i0+9yuf5N4/OM/l+TFO5Ou5fP6r3Ptrv8q9j+WD1yc5dSvw/FkePX/1QTxn/+AMLUe49eQoIlzggV//BJ/57S123BGO33aSk7duYp/e4r7P/Cr3fOVFyqCHh7j3Nx7k0g+e4OStm8xv/GHe9fYTzIGth87ygpU9/whnL8HGf3jqZUSELT73P3+a+x7dwd0k63LLbIev/tNPcu9jL/L4Zx7gnl/5DPc9egE28z0+fhSWO2z99mf41G+dk8ddf5JTbwQuPsSZnReuySNf2waOc/pHi4hQKBQKrwWKI6FQKBQKhUKhUCi8Yg6NOvPviRAjz1x4lj85d44j11/H/rLl0vOXadueYfA5/0gcCCCDV+8DbpAoo34YGIaeruuBhDFWcvQr2S1ucrTMbD4HIs1sRl3XODdMJc9xKlm2pKRylE5gf38J8xloJbviQy4sTjKg994TkggD3vvp/MYrHHfThxBkQA/TLnqlFAmJdTJW+hFMSlS1uCQqXeG9k96CHIUT8877McomxDB1LchxNUZpQoysVkt5XIK6qfPAXob4Lufrr6+vS5xRUnTZdSBigifGvPs+RmbzOQno2laEklyQLLn+Ug5trEXHmK834UOgaeppLbQSt4DzDpN7BkbRIo7xQlFKmENyqJRI+XpTipPjIIQI+GloP3Y3hBBELLCWlEWKYRhknWPEVBbv4+R+GN0ICiW9BvnvY7zQ4TdtVVWQRGwYhQmJUorTPR7dENZaQpQuD6UVtpL7qHK/BTCVLY9ChFJk4cDjvcM5Ec3GtbXWMl/M0VquRRlDyO+rMepJ3BbpKmfCNcLGcd73Mzdif22bnXaT9/zMXZz4Hg/d/YMH2FrC8Z/+OB+6/dCQ/vx9fPI3HuLco4/j33Li5YcR391ia/N9fPSX38vRcQj+zP186n95gAu//yDnfvxObgG4+ACf+90d/Npx7vz5D3HqxvEAnp0vfZp7vrzF5/73r/Lxv3OazXfcxV0bn+Pst3bZuPUO7no5JwItZ+79HFvLOcfe/1/y4XcdevylM3z217/A2c9/gRNv+iAnajhx+ynmj57hoYfOccexWw4eO2zxyDbw+tO8J+sI53/nH3P/Dhy5/UP8Vz99/MBh0Z7nvs98mgd/93M8cOKjvPfmQ6fz/C6868N8/P2H/Q5Huf3GMzy4/Qhbw0lO1gc/OffQQ+xxhHff9gJ/xCE8W//sC2wtYfMnPspHDq3JhS/fw6e+dLUC4Dn7L+5nJ8458bMf44O3HrrH7Rk++z9+ge2HzrD9t27hOBuc+tHjfPFb2zx2doc7NjcPHrt3hjPbwFvezttrCoVCofAaoDgSCoVCoVAoFAqFwivjivnmGGqUeP755zn7ta+xv79kf7liuVyyt7dPn90H4+76lKQDoO8H+n5gGKRUue87nBtQSop3m6bJ4oFisZhjraGqK2yVy421oqlrZs2MtbU1mqZmfX2NtcWCxWLB+voa62trzOcLGQqniM2dA+Nuem3MtLtfITFB1lbTUNkYjc+7ysed5mORLzANe2OM0h2gNSkGbGWnAfS08z7G3N2gRHDIvRJyHPl+Cgk3SKyOsVK6bIzBaE2M4cABECMoiRpq6nra/R9TdgIoTd00kIfkaXIOiOBiq4oQIz74adt7VVWT00Ip2fGfDpUoA1R1TSJNPQjjLn6JmzpwVsj1KbQy02B+FGLGYb3J/RXj+kzdCnmIr3Opc2UrrJGy4rEHQkqZtRQxZ8FHDDJSHH24b2F0Jki3hcVaO63D+LjRnTCKE+OvoXe5UFpKopVKoBJ1U1M3NbaqmM3nh4qWJUJq6Af291cs91e5tDlhrGF9Y52qlrUf8vtD7oPLIkIiESfXxGsZn8uML3330pU75I/dwcf+wd/j4z/zCkQEAOac+huHRASA153k5M1A25J9AJz/w69yAdj8sZ8+JCIAWDZ/4qd5943At77KmYt/jovZOyvD7te/l59911Wiw42nuOOdR6Hd4swf5ys9fpITc2gfPcv2oXQq/8ePsB1h8+RJZO/9Oc780S7MT/GBv3X8ypim+THu+PETwAW++odXWxs2uPVtV4sCm7z9rUcgbvPIHx9a8bjN2UfbK8SLFyU+ztnHWrj+3fzUVcLK0R/P63cF5/j2zhx787t5361XuTnmb+ANNwHRT73c9sTbOa5h92uPcPhq9r52hvPMOfWOk2WHa6FQKLxGKP++LhQKhUKhUCgUCi/PWAA7DcFT7hKIbH/jCb7xjW9w3XUbtIPj8t4+3bKl7zpsVdE0DdbYvINf4bynawec9/RuwA09JBnuN02DtRW2ssxnM6q6omlqqrpGK4U1BpDBsMyPFdhK4nmMxjkpMq7rufQhpEjXtvgYclwPhBCnouCUVB7ExzwMV9MAnENlxsocijc61BWg0Xgf8X6VY5ZkEE8e6htrc5eAxBmZHMMkO/QTMUpOv3dxisiJUSKUZmbG0PdTvJHWiqQVKE1VWYy29MNA9HI9xpgpHggF2king7UVfd/LbnwFIYn4MQz91GFgrZVyZ6XQugLU1B0wRlHFELC5Y2Bce2urPHxPUtqsjURExQi5VyHmGKDRATCfz8T9kRQ+HEQkjUN56VPwUpqtxBEgAo6iriviEFGAH1zuK7CTWCFiwcGu/hACUYkTQeuxyyFO/QjT23t6vAcUQ+8gjQXUZMdLoqrG8mZxv4yuDoBhGOi7Hjd4uk5KwxOjAHEgaoiDQ8SfEByJ7JJIMQtQB9Fhr0WOvu0km1++n52v3MMv/csNNv/KCU7c9nZOvuUYR17VzvOb2fzBl3uM55mLe8BRThx/sXicTd566wYP/v4Fdi4AN7/IQ16K8+dk+L18lPt+86kX/nxXBvfnz38bbr8FuIXTp45w5ve22HriTo4fB9jjzEPboI/znjHC5+K3+XYLzJ/iX33+Xh65+rjtLnNg78mn2OMYB1f2Bn749S9ylX/tNJu/dx/bD51h7/bT8vivn+FMC8duO8lLBgdd3GEnAsfe8MJeBzZ585vmPPivD3/vOB/4xb/HBwCGlr29i+w8+QxPfXObx7cf5/ylqw5Rn+Sdt32R7Yce4swTd3DsTQAXOPOHOzA/xcnjL3VyhUKhULiWKEJCoVAoFAqFQqFQeHnU4S+kEDiGyIWLF/k3X/83XLz4DK87ejP7yyX7+/v0w0AIgaqupzz48SB939O2KwY3MAwDkKjGYuW6oq4r6qpmNpthrMmRRrLzfuwPGAe4487zGCM6D5qtNlOcjDEGawz7y+WU308WBELwKCW72Ou6zs4DlQfbedd+vuQx639aBaVyBE4ELwNjpaSkt65r3CAOi6qq8lBcTSW71hqGIUwOAK00TW0l8z8EhtRT2SqvW8Tm62vqmqau6boOrXR+TYV3jqqqc6dApKpriXyKEYwmpjhFAY0iBSHktRfBISZxYcQcnWRtNe3WTzCtkZy/xbmB6CS6xxiL98PUJSHihT10HIk/UvpgOK5zBJHSY69DlP6D7FqQgb+XsuTsGPEhlyHnaKBRgBiP55z0IzjnaJpm6ocAKWfW2mSxZpjEolHcGCOO6rqh7wd8LgS31kq8kRIHhJ2cDWmKTzpcUj30jpDjn8b7PZvNrjgXlZ8jJdijEDH2Rsj76NorSXgV3PxePvx3j/DFf/pFHnlyj53tr7Kz/VXuB+zrTvHTf/tOTr5gl/uLcR0bLxudv8ve7ks/Qv79sfdKXvB7c+k8Zy+9oPhgom3b6evNU7dz9Pfu58xDW9x5/AQ8f5Yz3wLe8nZOXC2ktDtsP/yC8oADluK8OLwM9sVyJa4/yak33scXv3WGs8+f5t3Xe84+tAX6OO+8/WUW8dkLvNQSblz/Is+/dJYv/OPPc+aZK1sZ7I1HOTK/wG575cOP/9UTzB86w9bXtrnzTcdh5wwPXYQj7znNLRQKhULhtUIREgqFQqFQKBQKhcIrIDfLjl8iw9CvP/51vn3+PMF7tNGsVitWyxV91+Vd1om+72maBlJkcI79/T2WyyWDcyhrqKuK2lgWiwVKK2ZzcTDYSopuycN/6U6wV2TbjyW5cloJjc79BbK7vKlr7GLB4Nw0BI5hjNsBa1UekjdorfHekZIM1FOUc49RhvMSqyPOgsF7UOIuqOuaEEWUIJdDG2unQl5j9FTAa7JwId0CmrqqSCHJkD3FSeQYhoGmaVBK0TQzfI7iQSlxT6Aw2ky78L33efDPVM58UGacxYFKyqatlscHH0Blt0SMmMoQezft/o8hgFKTqyDkkmNdVaQEPncljOs9DuSlINtijLgUjDEoK1FG0o/hCSFSVTVaM63F4R6Fuq6nAX3Xd9NOfu/dNGQfhYBReKgm54J0X1TZDTO6FSpb5biqgz4EEaXkeq21VFVF3w+4YSCRWKwtxCFjD5wIo4hwWECAHJnkXY5DaibxZX19Xfo8gBg1lbEMw0DIPSHk6Kwxduma7Eh4ldibTnLnz5/kTt+y880tHn9si7MPb3PhmTPc++uw8fE7ueUvJGj5CBtHgJeILera9nv/8BWy8YJegpfg5lOcev393PfYWbbiCd7w6CPsfK8In+N38g8+dOovYDBz0EXwyKN7vPtHz0knw62nruhMeFF+4ChH4HuKCbJ+hyKMhm3u/fV7Obucs/mOn+Qnb7uVzRvnzDfmWC7wwK99ivuvXvI3nZYeh8e22P5bx9k4+xi7HOV9p14qc6lQKBQK1xqlI6FQKBQKhUKhUCi8MtJB30EIgb29fb7++ONcvHCBm48epe069vb2advuioialBLeOfphoF21LJdLQgjUVcW8aZg3c6qqYjZrmM9nNE3NfDFnNpdoo7ppaJoZ8/l8ytAfB67j8HocwDvvWLWraaA9xRHl2J6RGIOIFDA5JqQ0WUpwgdwJ4LOGIoXCjOW6gPOOOO40V4dia2I6EDmy6mKMIaaQexZEdIhRiqoTh/sBDFVlJcYIGfLHXMgcQjjI9FdSmJziwVBbKairGu+duByaJl9rzOsQpY8hicAh/RDSAzD2Hyit0dZM63s4dsgYg8oDeGM0la2mdbK502Ic6kOaBvijS0FUFuR5oFcAACAASURBVHEmTGsL2RnCdC/G48hgv86ukzoLPbksO4qDoaosxuipZ2EUFOS44cprsCYXIh9yRCg1OSgOxyGBdFdIB0cjPRL6oMB5dKSMgsQwDMRwIPBYYyAlmlmTeyEs3of8ZLkXIQYp/x61CHUgJhwWKF5b7PLVz36Cv/9Ln+XMANg5m286xXt/6kN89H/4OHe8Hlh+m29/9y/q9Syvu3kDuMDW9ou5DnZ49DGJPtp8uV7lF+PoJkeBvcce5cV8Azu/80nu/u8/wWf/4PAYfoPT7zgOcYszZ8/nCJ8TnHjToYfcdFS6H57YYmt44XH9w5/l7l/6+3zyn597xac6dhHsnD3LhT9+hO0459Tt36sS+xA3b7KpgT/ZvqLXQdjj29+6al2fOMPZJcxvv4uP/NS7OX7sCBsbcxFD4gV2XvTe5h6HdoutJ87zyNd24fWnOPVqo6YKhUKh8H2lCAmFQqFQKBQKhULhFSA73IljQW7kyaee5Px3vsP+3j433HBjLlteTgPTg0GywofAcrliuWxxzmOtZbG2oKkqmrzbf76YMZs11HXDYrGgyQLCYrFgbbFg1symIfEoVIwigjrUW9DnrPoUk0TwxIDRUlSs0GhlMNbSNDOsrZjPF/kSE9pq2aGfkgzV8257pRQhenFGaD0JBX7cta9yl0LuKkgJQhYAQPLwq8qilJ6G6ilKwbLSmqREchhLn3WOzbG2EiEmeIahJ3hPlX+utaapakJ2Z1RVM/VAQJr6DABM3lGfUqKyVroqnLgqrLWgFG7w+TXt5EYYh+VVZanrJotJEjE1xjbFGCQuCXFfeO9QJGL0eD9Q1VYKhZF1rGczbFUxDMPkQgjeoVSirsUVML7uGDcknRwJ7wMhRKKPuYhZBAznJBbKZsFjHPCL+yHkXooxzkpNpdpyzmZ6X3nv6bte3CuVFC1Ll8KBCDUKE+N5jvFSw+BkzY2m6zvqppqELCkRryfnhjg6REiIh6KNuKZFBAsVgKN9keG3cIQ3vK6i9ds8+JWdK8uW/SV2l4C+kSPX/8Wd1bH/6DRHgZ2vfJ4zV+Tze3a+9HkevAS88fTB0FqLgNi23csf/OZTnH4jcOlBPv+lq67nmQf4/O/vgr+RN7/lyBVPs2+Tof727/8WZy/CkVOnOX54+qJPcPr2OcRtvvh/nmXv8AC/3eLe+7bBwy1veRXBP/VJ3nnbHJ58hM8/tA033s7pV9I/MJ5Le4bf/Z3zHDYT7D70eR548sWf1l66fMVjiXuc/adfYOsFYoSw+ddOs0nL1ld+m+3n4fg7T790d0OhUCgUrjlKtFGhUCgUCoVCoVB4Wa6ebbrgefKpp9jdvUTTzNFasbd3mRQTla1wXiJmYoq4YcB7T9eu8D6wvrEuPQi1RSuDNibvMDfUTZ0jaWqMlh3wJkcFaaWIYdyJXk1igggDZipC9t7jY2BwjkhkNltI3I/WU4/tOEgeI3S8dxgk+ieB7BTPw12ldc7HrySqyErcks7HkJ3sKg/x4+QeGCN0ZNh8KP8+GYkn0uqgsyGmg9dTMnHUSqO0QiU1XVtMEYPBDQNVVQNKnBZGiqMh5W4Im0uP/XT+Som4IfczMbgsHBiJl4opToJAImGNPVhTNzovFCkFjGlIORpIqwOHyOGMf+mziAdFyyG7CZS4L1zfS6TSJJqIABPjWDwdc6QTuf8hTWsqopEBEj4E6aBQeoovMkbWfRSydI6Bcs5fseN/dLfovOYpJWKOiKrrOjsxDqKpgOkcxvNxzovAkbsgpHw6cOSmG7N4E7FW8mWcG+T9kns+nPe5myN/zriWa5aP8MM/COxs8zu/8TnOHb2F9/zMaa4Op9n8jz/AyT/6LGe/cg+//PAx3nzLEWy/y/knzrM7wOZP3PHycTuvhpvfywd/cot7fnebL/xPv8RXjr2ZY0dg99zjnH/ew9otfOA/OTS0PnqUTWDnX93LZ1bHeMNb7+B9b/leI+0NTv9nd/H4Pfey/eV7+OWH8vUsd9h64gI+WjZ/8qc5fbUwMhUM73CBI7z75AsjfG55/4d495Of5sFH7+UT2w9w/MQm836Xc9vn2fOwcdud/M03veBpL8nYRXD+W3DkPW9/wb35Xtzy/g9y+txn+Orvf5pPPCrX6J7aYvsZz3xtDstDD37TKU6ubXH23Bf4xK+cme7vue3z7MUjHLmxZffSBS5c5Mpy66nH4TytPs57T5RxVKFQKLzWKI6EQqFQKBQKhUKh8LIc3jQN0PU9ly4/x/7+io2N6xiGgXa1khiausJoLUPpBF3Xsr+/h3MDzbzmhhuuY+O6ddbW1ti4bh1jFNpIwXHTiBuhritsZVnM5rKLHxkmO++mQfsoJoyRNOMO9qZpqOqapJDooDwA10rjnUMrRV1VeC9lt3J94wUeDIxTlK6CccjcNI04BVLCGHto4CsiQIwBkkQEjXE2EqEjcT3W5n6AXPo8DtBVdjMYY64YfvvgpyF3XddYY7DGXrHTPkYpBR4H8OM6jNFIKEhK/gwx5Dgd6SiQDodEXdfZuRBJKV4xyJZBucvrEXMEkZquo6rsNFCvcym00WZai7G02eR1i97T9/0U0ST30U6xTilJqbbOrg0f/CQsjOsz9mNIoTREH1CIIAJQGUNT1VRZCBljiEYBQVwUcYo9MsbgvJNIIm3wPqCVlrJvow/FNR3ugZC+hhC8dCpkZ0aKia7rsNYyn4vAlpKIEqPQonO3RgL6YeCKj9a1akbIHP+JOzlxo6V9couzDz/Ct18sTag+zl3/7Ye5462bzNvzbD18lrOP7dAePcH7fvZjfPjH/zwZQy/N0R/7CL/wc3dwYnPO5fNbnH14ix1/hGPvuIuP/eLPcfp1hx5802l+6j3HmOtdzj18lq9+/cJLH/z6k3zoFz/GXe84xhG/I9ezvUu1eYI7fu4X+MiPvfj1HH/rCWkWeP1p3vNiE/36GHf8/Mf5ufefYLPZZfvhs5x97DztxjFO/8zH+IWfOXG4meCV8abT3H4jwCan/9qr6B+ob+ED/41c43X5np3bP8qJ93+YD73zKpGlPs5dP38Xp994BPby/X1inxtvv5OP/OLH+Nu3HwUu8O3v+KteRHocAOa3vfMvVkwqFAqFwr8TVLp2fZOFQqFQKBQKhcL/r9ndfW76+siRG76vr69Wz8ggNk86n372Ir/75S/xL/6fL/PDP/xDHLnpBp69+CzD4PLu7AhIPFCKkb5raWYNi/UF62vrOZcfgg/s7+/laKM5GxvXMZ/PWF9fwzuPNZau60hKYmfInQDOOSnGHXrZiV7bPKwVN0Dfdfjgs/NBCncvPH2RS999jh+4+Sb+vWObMuQNibqu6PseW0vBs1GG1aplb7ni4sVn8d4xny+YL+Y0VUWVh8TGWhFHZjNCdKSYsDk+qG5kSmaNnQSBxWJBu2pFaBhdGDlWRyklO9p17ljQGh+8DMitRWmVC61lSO/y2qQIQy6EHv/PrqoqqrpCaXGESKRPnDolAC7vtXz+//q/2d9b8a53/ijv+NGTDE5KsWMI9O2QHQVjyXKO9IFcrjwKLiKqOOcmp0CM0uUwiimy4156KLTS+OyKIMm5KkTwkeG8zx0UOvcHRBFt8v0PIU7dCmO0kveefhjkuquaFKXrAcCFgLFjKXdguZT1H0uYR5EgJXFgDP3AuSf+hJgS112/wQ/+0A9is2DVtu1Ubq2z+6TrOtp2oGtbOXc0fd+xft06i8U8n6dlPl8QY6TvewBqY9m47jre+IY38LYfOcHa2hrWGLRC+jy05nV/5a1/OR/swv+H2eG+X72HB6//AB//O9dedJB/+LP80m+e59R/8fe481W6LQqFQuG1zL+L/6a/fPnyX8pxD1McCYVCoVAoFAqFQuEVkqZ/QghYbWmqhtmsmXb2e+8Jebe6NpIxP5/PueGGG7jxxhtZX99gNp9LP0IuAybJ8HTasa01dd1QVzXOOYnhyTE4YzTPGGGklCYbBrDWUtcy6E8xEXJXQ1PXEr/D2DkQJcdfK3yUzH2XB9Jaq2mQ671H5eJfRSKFOJ0fSHmv7OZXGGsxWvoNnPcEH6ZIIzEGSPRQVdVYWxG8h9ynMDog/JTfr6XcOUZiysP07LaQob5EKY1uiwMnguzwH2OTbCVxRjoP/ZVSNHUzOQHGXonqUF+EXJvKQ22Vr0nip8i7942x03ofxAzpqVh7DOeRnoKQOxA8KYqwZM1YbCyOiJDdCzGEKRppyN0Wo5ihtGYYBsYt+0pJx8T4tTWGmEu1xzVR2RVjsosj+HhFSbJEQImLoa4qSAnnHD6IoGNtNTkWRjdDXddTL0KMka7riSEQY8qdHI619TWM0bSrlr7rGQZH13WTcBFDwIVADJG+66V2ZFSBrt1co8JrgL1//bs8eAmO/+ipa05EwJ/nvi/l7oYiIhQKhcJrkhJKVygUCoVCoVAoFF6WAy+C4L1DG8VibSEFx30vA/EkMUHjALquK6w2zOczlNHUjQyyqxyD472b4l6kqFgG5sMwyKB16Ak5TiYEiZxJNqGVQltL74Yp8sZoiVIad5wrhXQDaJN3i4tIIDvXq1xsLMP+ylZTvI5zjr4f2N9fMvT9QeGwMSjUVIY87tSPMaKtJig5z6qqpigf8pA9wbRTXymmwX7Xdcxms1w8LINoayzaqGlYHZMMwI21013QWhwM5P6EMcLHWCPCikoH/Q1ZOBh7G6yx9H1PnISRLDSgiUHuRVAqlwDLZYyCQRoH/rn8uKrqK0qLx0H5OISP0U+vgxojpLJTI/nsGmnytQ+TGBPCQR+CcwN4smMhTOXX/dBnYcNM5QLWGKLWhJSkf4CDguVEuqJoeSxBVvkfcTzI/ZH7bIk5CmkUEQ53K3TdwND7yaUQYyR5z3wxlwilJHFHbvDyfg8hC0gQQ2AYBrquA17YTluCAwqvnG2+8InP8zgte3seNt/HHbddO6OeC7/3aT7zLy/hl3u0fs7J//wnX3F3Q6FQKBSuLYojoVAoFAqFQqFQKLxCxuGmmnaHb1y3jnMDMTsApNBYhAJrjYgJTcVsMWc2n9E0NdYeDKX7fpgECKXVtLvdOdnFvVwu+X/Ze9sYy+77vu/zfzjn3HPvPOzMPpBcUivJtLBSvIoYRTRMxXJgGabR0E2CyA34QkarFyoQIxEKFZEF2EAa1CoStRYKJ1CK+kUSmEaJVE6rwHIrCqKL0rUSUya30arS2qEhrcgxudydnZ07956n/0Nf/P7nzK5CiStLMhnn/xFEzs6cOffccy4F6vfw/TQpNqZtWxHm9p0Il614CrwPqeibCudRJszLspKfuyTD9QGUuA7KssJaizXSZLDWTs2NGCLr9ZqmaRgGn/L57eRg8MHf0ihIufk+pKn8gbIsKcsSlLyn8ZjRaTAMA7YopkK9c07iiW6JZFJKS2Z/KnqPTZcxukmkyhKFM06xe++nKfwxJmiU/Y6T92N0UNf3qZguRexxY4CASK7TcxgZJ/m9F8fCWOCX6f84TfiP2wMmbR10nRzjvJtik4wx6ZJjiocajj0X6drleYisue97hmFIkUrc5pEY37dWavIQ+OSQkPulJv/ErRsvIMV6kT0n/0GSJNvUVIqI72D83I3nH4aBvu9ZHa1p246+69KWCKCk0VQUBRubC8qqnDZFvBfxtLgc5DzjPYQ49num+53J3BmbbJZLlkuHveshPvDB9/K9t1D8ydnd3qK5uaRhk/N/9W/x6NteP02OTCaTyXxn5P8Fz2QymUwmk8lkMndOmvzu+44YPFVlaZpGpryjFLyPp/4txlhsmlpf1IsUFVTgU+F9jL7R1qSJdpXy8D1t29J1PdpoglKpmC8FbqOlGB1DxBRG5M6oFFvkMFWF0ooYUowPqYCbirYxBFAaUmF5nLCXXokSd4G10++OE+JjVJCIgD2lKSGGFGVkMNZOk+yjBBmURDClKf8I2LQ9oY00BsZtgbG5MMZDQSRG+X4MEPDEeMv1aA1RNjkkfojbJM4KhdYGrWXCfyyQS/9Apal8k8TLSEPI9zjnKUtzWwOh77upCD82JMbrHsXFYzNhbH6MzZo43sm0VTBuCSjU1NBwzhOjQqkxgkjijGxq4qBgNqtFapye29igIW1DSINLHqMPgSJtImil5bOSGjO3Xy8MbgAUQ+8IAYxR0ybFKGgeXRbGGA4PDxn6Pn1+DF3f0TQty8MjQoBTp09SFOLtWC5XNN0hdVUym80YBje9vnNOnu0tsu9M5jvjLA//3X/Aw6/1ZXwL7Dvezy+947W+ikwmk8l8L8gbCZlMJpPJZDKZTOaOGNNWRgFvYQvKsqAf+lQQDUQC1hqKUoS/xhqJK7IWnWJoyrKUaCEtheXIcYF33AyAOMUaaW1QKYaoKEqKopym0zVgtcFoMzkEnHPTZLgtJPJIiulp4yFtIYwOBGMM2uqpCdG23RTnUxYlYzqQRDDJ5LsfHH7wEOQ4P4hIeHQQjJPtMUSRQRcFzvmpyG+MnfL8QUrIzru0ZaDp+m6K35Hj5Z6Ka4Hb3q9KkghbWIIP6c9q2tKAmO63nuKH3DDIFH1k2lrw3k1NjRjjVJSXordcpTEa7wZiCOlZFElc7NMmgpkigELwEomkFbPZDOcGTIpIcoPHmmI63iWfhUinwxQDNMY1aa1TZNS4kXEc1TQ6NUIQ58K4TTFuthBhvV6L+2CMZ0pxTCKPlvun9Ch4Rv6O3OfjbZIwff4lkihii+MGxvLwiPW65eWXrvHSi1dpmlacGUPga1/7BqtVQ9/3uMGJVyEGur7HuWFqIGUymUwmk8m8XsmNhEwmk8lkMplMJnPHiMRYYnCCjxRlcRw75MZia0QbiR4qCisi4iSsHXP/x5ik4KWg33XtVMCWDQB5rRB8Kv5rqipFyzhH27W4YaAoC+pZRVWVAFMGvVJMnoGxED4MgzgbrIiERzmv0lJMN8mRME7Vj9P64gc4jtyJwRNDpCzKdC9C2pCQjYiu66YpdpcK0DFKEV78EQbnBml4JJ+ESHwLQBGSfHgULxttUvMmTCLoceNhvI8+FbvFC3FrJJFc+zAM8v3kBXBuOPYKFOJ8CGkDQgrzNn1tbiugF2WB1oYyibLH9xkjDKmhJNJqed0Yw9SAGqXHIJsY4o0IqcGhKYpSJNMxMKtnDG6Ymhmy7RKnyJ8iiaHHZ2KtSQ2oFNM0bppEsXuUVTX9eXy+EKfIJHEcpM9vahiNmyrA9Dt937Ner6WBUlcsFnO0led+6vQub3jDvWxubdI1A4eHK7yPHN68SV1vcHBwSNcNcq/Ta3d9R9d2EjGVewmZTCaTyWRex+Roo0wmk8lkMplMJnNHKKTI65zDDVIkr+uasii4cWOfMRJIK43R47S9okpFXMmZL1LBWoTBIYTkQ2iY1yKpXa3XeB+mIm4IHmvKtCWgUszOwGx7C6MU1ayiKAuGYZgKx5LJXxKCx6cCcQgBpRVFYVMEkPgEiqqiH/pUlC7ReLROcUFaE0KKF0rFepOK4DqADw4opnskRXSR/7Ztm37f4X3K4Q+BsignuTJKYYsCUkPC2oJhnMQ3ss0xCp2HwR27DgZHNBJH5NwgLgYizss1FkVBjLIV0TYNQ99TVbM0ZS/PIsQ0zV8Uk1zYpm2QGD0mWIyRaXu5ngLvPNVsdrz5kZ4PQNu0WCtxPmaKGgoUhbz3wlq8l9+pqlkq3INsTJQYI+8TpaZNDpBzSxNKGkxjUV82OOzkLiiKgq7vpmaLShJwpaRR0/eduDiUwhhpFBR2lH4fNx9Amh6KsflUpo0Sx3q9om1brJFNDHleA7O64tTJU/gQMFZzY/+QG9cPiV4iuSqtODy8SXjxGidPbrOxUadGyUDbtcQgn1uVZ/0ymUwmk8m8Tsn/lpLJZDKZTCaTyWRelejjNFk/eEc39FLg15aNjU2UUqzXK5nOt4aiLKmqiiIVfW8VKBtjAUXbiKRWsvI1ZVVSlgVVNWMYBtwwiCsgSZxHUW9VlWxsLKjqio2NObNZmZwCAW0k877vO4w+3ia4VTw8Ri/JZL5E2IyFe6WgT3E4xhqGfsD7gLF2kgiTooR8kBgclHgaIpEQI0orfPDTdsRYnBYpdcAFj7biMwgpZqcsCow9bnBUZcnochB3g0zQOzdIAd6LUyAEpvgeyfAnOQA0znnc4GQbIfkTYhJEy/aCbENIdT0V61PcUQzy5+BTzJA/diLEyFR4jzGmjH9kmyDIBsLYIBq3LMbjtB69CyY1C0zyYXQ4NxCjRytSDJFENEn8USUbAcNA1/e0XXdbfNG4LSDRSbKRYo1JDZU4bSmMLgylDCGIKHqUKYuoO/kavKMfBrm3kCKfHF3b0TYd6/Wa1dGa9WpF13XMZnXyd6j0WbJ0Xcf+/g2MtRTWoDHcPDhib+8aV68dsG5a+mHgcHmUmlXHMvOcdJTJZDKZTOb1Rm4kZDKZTCaTyWQymVdldMHGKJEszjtmswprDPP5nLqe03Udfd8TQqSqSuaLBfV8PkUaxRhZrdZTPM3gnBRQU7Z9PZtRlRVVVU0ROTFGjDVYI5PnVVmwWMw5cWKbej5jNp9hjKZrW4ZBIpZCEvd67zFaPALD4IgxYLSaZNCDc3jv6LsO0SczFcxRIimWc8jkejXF+YBWGq0Ui/mc2ayiLAtUmnL33uNScVvOJTJfYy1RSQNCZMUSzTMMct9Gze5sNpN7aw3OO1L5m6KwUzSU0RbXO7wfo4JGx4RED8UQ0NrivEcbWUSPqVg9XqO4KdKSupK/jI0Aa8UN4ZPY+Naf9X03xRIZaymLEmvMFAPVde20rSBnlbsbk69B3rOjrKoUR6STWLtJTQHxYhyLqtW0ieGDPNc+3d9bfQ7ODVPTZtwcWcwXWCMy5LGZ5FNDytqCECPWFpOjI6SGh3OOoR9EFp6iudq2xXmPTQ2fo6MV117e5+bBYZJYgzWWay9fp+87TuxscbRe0Q9D2oYIDL2j6x1t59n74+scrRqapsWH11u0kWP/mcd54iu3fOvlJ/nERz/KR3/90vftVZfPPcmn//XV79v5M5lMJpPJ/MnJjYRMJpPJZDKZTCZz58TIMMi0tkvF2rqu2dramuJq2qZBa4PREnE0ug1imlxvmpbVaj0V/2VaPUzbC6vVEc65lH1vJzltURRUZUldzyjKkhCgbXvarqfte9ZNM02ql6XEDRWFiH/bRorU8/mCYXAMzsm0epB4IZA67jj9r8d4HcQ/MCSnwTShHhzOOwKBCKkpMU61S0VYp+K3TtPv3icfQHIkgMQCxXAsXB6L/G3bTHFDx5P3nq7rIUpxvSrLqShelBZjtUzEw+QLGJ0EYyFeRMORrh8IEcr0bMZC+vj64+bBGDU0nkuG9gN926Ej6OWSjaMjZs2auSmoymo6Vor64qKIIeC9NDqUUtKMSHFRJkm4ldKTE8O5YfI9jOLmsdlirJ2aUaMnYXy/wzAQUYQQadoW5x3a6OkejELv48+jRCSFtI0xXsvos5g+g84RQqCezdg9ucuJEydYLOY0TUtVllhrZeOm6yDKxsVsVrK5MWcxnxNDZFbN2NndZmtrwUsvXeOFF17m5WsHrJtGRNHjh+B1wP5vf5KP/4uLXA1/ii/6lcf52K8+wXOrP8XXzGQymUwmc8fkRkImk8lkMplMJpN5VVQa2Y9A13W4YUjuAym81vMFGxubyV/QiaxWaay1LObzFE9TUpYVXdezWq04PFymYrIIiI2RAvtqtZL4nhikiJ+m1E0qeMeoWK3WtG1P3w9J+CsRPGUpjYPFYoPNrS0Wiznr9XoqGtfzmqqSmBw3DKhbBMQQ0UpTWItNrocxzklrI34BI9E8prBU9exY6hsCCtlUQB1P0VsjReuyrFKRWOKBlNaEJNi1tkhNB4W1Bd6LrNil5oRzUkQfBpeK7ZHgfYr/gaqeYa3GFoWImYnyvmCKy7HGpg0EETcP/YB3fmpUjO6Brusm/8H4u1prrDH4JNXu+k5eVyvuvXaTt1y/yQ/4QDF0DEOfNgpkowMibdtIgyCdaxgGQgis1820uXAsQB73MpJboJoB0phomob1eo1PWwFFUVAUJXVdTw2Qvu+xacvCOT81f8bGwdhYOW6WyPfGbZSyLKYmhfNOZOHJ96C1Zr6YU1UV29vbbG1vUc8rdnZOHDc6lGJn9wSHN49YrxvOnr0boufEiW188JzY2aZe1OzfOGB5tOIbz+9Nn/exnfR6iDVywb36Qd9rXovXzGQymUwmc8dk2XImk8lkMplMJpO5A46n5mWaXeJ2tJWYoHlds7GxQdOuQSnm9Vwy6m1BPwzs7+/jhuN8/aZZ0zZtmvCPzOcLqtmMoZfJ/77v6doOrQ1VXaGU4mi1JkQYvGPdrLCmYLExRxuLTlLgIk2Hg0pxN5626YipQG2UxiiN9wNaWzRQVpV4DZxDaYXrZWNhcD1Ky5R/8B5bzzCFIfUKsFajtZmm9k26Dp+aIIQgUUZpU0GnJkRM8T5aKRTiU9BGY4xiGHqU0mhjUToQhlT4dhLPNBbazS2RP0VZ4EPAoqiqEuc9wyANATjeKhidEf3Q0zuZ7rfWUFgjUgQkKmg2m02xTCF4jLFTNJPvO4yx1Mays1xx/xAoFxv0ZQ3P/zHfuP8NbP/Amzk4uEHX9lhr8c5Lwyidc3t7i+Ajw9BRliXtas3cBY5S86lYN2ilKAeH6wbmixmddxRKoctSBNXWolAMw3AcRwXYosAF2dLwSY4tnwcgShSTSVsMsmFxyzaGMSnhKWJS3JFzfmoiLBYLecbp97VWLBZz6nmND7Ixo7VmPp+xtb3J9f2b+AiFNcy0Zb6Y89LVq2hjuOuu0+y98CLLw4Zr+/spqkmRLBWZTCaTyWQyrztyIyGTyWQymUwmk8m8KtOQdIwpI1+m20MMU7zRyZOnuHFjXyKIqmoqiB4e3OSlF19Ea0tVzuj7nrZr05T9QFmVbG1vYYyh8S3NuuXw6B/yqQAAIABJREFU8AhiSFsMBdpo1us1h4dLukEaBHU9k0ikoqCua46OVqzXa7a3tyHC0A/0g6Nt5LVIUTko0uaCXOFYhI4RurZLv9fjvU9ROzItXxQFZSUS5HGy3VopPg9Dj3OOoqyIQ4+xFq3FceC8S66GgFXiL7DWTFFPbnDHAuIo/oMYZBujLEuMNqycn55EDBFlZCJ/LKRba5M8eKBI8UEhSONBrlWeYEjNjaF3kLwL1awipCijoijwPlAU8n8V9VR0jygV0jV7iJETy4btosSd3CGqyF2Dx5UzWNQ07Zr5YkFVlsnl4Dl1+jQvXX2JN73pB7C64KWX9pjNZtx8/gX4g68RT20Sh4Hdl2/QntzkzPPXxZWxs8Fq3bHamhO0Ricvw9go8d5NfgOQRtUYK1UW5SRYHl0IWmvcMExbEOP2x7RFkuK0ZMshTDFb4+/GKFs5TdNgjDSIbFFM55hv1Jw8tcu1/Rvs7O7gvaNZrakXc24cHPLHe1fZ3tlmMV/QND0vX9un7fopEku9pp2Eqzz5y5/giZflT5d+7aN8FLjws/+A9585Pspdv8in/5dP8+zzDQ5Lfd9bee9Pv4/3vKn+pvM59p/5DI//9kX2Xm5wALbmzH0P8N7/7BEeOCmfs0u//lEe+1K6gs99go9+Ds785If58E+c4d8jXOY3/tt/ytPdBd7/S+/nwjfnLOx9ho//ylM07/oAf+9nzqfL2OfSE5/mid9/jqsrB+M1/yd/jffcv/kK7/8C7/8H7+fCK96bV/rZK7P/lSf5rc8/xVefl/dud87x4E8+yiPv3L29GLPc4+nPfoon/u0eyx7Qlt1zD/LwLfcIEE/FLz8BP/lh/tb9l/mN/+2zXHrJyfFveS+PPvpezlX7XPxXj/OZL15h6cBun+Ohv/6zPPK2zdsvLix57nc/zWd++6vsfdt7kslkMpmMkBsJmUwmk8lkMplM5lUZGwlRQT90U+ROaQvCEKjKku2trRRvFHDeUaWi9LWX92nbjp2dDSnOR5kU18bgmobNzU2qWcl6tebGjRscHR2hlaaez6nrGZsbmyglRd2uO6Lv+lTM7SmajqZp2d7eoigKlsslhzeXKfrGslqtcW7AO0c9rylLizE6RQQFSJFHowgYJJ7IaENRlAz9MEmRYwipwO8obIFzwxR1VJRlitHpb98EiOCdAyONF/EOK+p6zpDE1MSIMVqm3VOx3loLSciMUpRliQ/JU6DTtcQg54tx2jawxqYGSGAUFY8y4tEPYK0Vua+S1wzB0/U9Rhc0zYq6nksxfpQyxzA1E2QiX4Hz+H7Ab20TY6S8cUiczdDesb2zw+poxcndXYrCcPWla1ir2draom1bDvb3OVwecerkSSCwPjhgq10T24LNdcupq/scbdQsbi7x2mBUR7sw2KqkCRJxNfkaYjgWKOu0KuL7aWMkcixkHmf9u06aSsfNIHEgiH+hSNsYGqJ4MpzzVJWZYpK6rudoueLg4JCNDYntkkin1HgB5vOKN567l5s3blBVM67vH3DiRKAsK4YhcPPgkMVig6YZWC0bnBu4NdjptaPm3gsPcP7yZS7vNey+6QHO7cIbt2855I8+zT/85SXN5jne+s5duPYcl65c4jP/0x6HP/cRHjk3Hthw6dc/zmNfaqA8w/l3nqfGsf/cV7nytS/w+C+/QPPzP8dD27B7/wM8sLzCxa/tU589z/m7a3bPfnNTIqHP88Dba57+vUs8fdFx4Z23lzWuPHORfTZ5zw+nJkJzicc/8RgXl2AXZzn/zjPUqz0u/eElPvOrl3j2Jz/Mh16pYfFdcvXzv8InPrcH2nLm/AOcXTTs/dvLfOFffJyv37jlNV96kl/5R0+w56TRcOHCLuw/x1e/9gUe/+8vculnP8L7f+j2e9F8+XE+/rk9hrvO88A7C7mnl5/gk483vGf5FE9dO8P5P/8Axf5zfPVrV3jqn/8T+NBHeORsOkG4ypP/+BM8sUd6Nmepu32eu3yJz/zqV3n2pz7Eh378e39PMplMJvMfNrmRkMlkMplMJpPJZO6IKDpi+q6jSxsFRhuZOveBxcaC3Z2TXLt2jRA8WlcsD494+eVr2LLAOSn2dl1H2zapkB7Y3NpkXs+59vLLHNy4gTKGuq45cWKb7RPbBO+SpHeOSZP8TbNm6Hva1qap/CTpHRxHyzXVTKTMR0dHEuXT92xvb1GWBXU9l2aG85Nktx8GrC3FIRDEhTCbyfaEMTr5IDRFWWKCFO3xLmXyG0yabu+6Vqb+Aa0kUkgnX0FRWJx3U4Z/UZYMg0MrhUnxOSo1OUbPAjA1X8aJeO8cRVmKEHoYmC8WgLxO17VUs5qQXAE+xfyMEUMiOh4gIo0Ba8UF4QPedRRlKRFRRYH3nrKQaCpjFF3XSTNErNA0hca/dIC1ltmqY9m0lFsbKOCuu8+wc2IbYwz7128AMPQ9s6rihedfoO0H7r7rLg72r9MfHqEVVN5z9saSzfUKd3Mp0UYzy2pWUAwOh8dYkSqLjFkaCmN8kVIK54+3O7wPkwvBaHmPQy9ujyEdN/ogqqqi6zoYI66USfezo6wK6U94z3q95mD/gOVyRdcNbG5uoBQopenahmo2w1hDpRX33HOaoXNcv75P9B6i4vr16xS2YOg7Yh1QEYbBJYn260COwCbnf+pRduwnuLzXcPY9j/LoD6UfpS0FVks2f+JD/PxPnp0KClc/9wk+8fmrfPGLz/HIufvlm3tP8ltfauDsw3z4b7+XM7dsDlz5zY/zyd+5wtPP7PPQj+9y9kce5dHNx7j4tX02f+gRHn2Vwv79P/Iudn/vKS5/6RLunQ/cUth4jqd/fwk77+EvnANwXPqXv8HFJZz90Z/jgz99jqkkv7zIY//j41z63D/hN879Pd73lu/qxt3O3mf4Z5/bg8UFHv2v3s8D44D/f3qJx/6Hx7j0ucd56l0f4j3bV3nysSfYczXnf+bv8IF37U6ncHtP8Ml//CSXfv2f8oXUcJkufW+Pcz/9EX7uR9Px4Qqf/oef5AuXn+Kpsw/z4f/m+H4vf+dX+Nhv7vHlL1/lkbNyX6/81j/jiT3YfdcH+Ds/c/74njRX+MyvfpKnPvsYT174MO89/T28J5lMJpP5D54sW85kMplMJpPJZDJ3iAKlcGnCWyuFdyJDVjFC8Jw+dYqt7S2JCBoG9g9ucLRaY40hBM8w9FOx3YfAfFGzsbGg73uOViuMNSzqmpM7J9ja2pQCcJQmhrWG7a0tdk/usNjcwFpLWRbTlP24aTBO0g+Dw7tAcFKUr+sZUZGibsI0AR5iSNFAAa0kQsl5T9O2hLRdoJDNgqHvpygcayw6Tf2PTQabYneqopRbFiPaGIqiSF4ELWLerscNjtIWWGOZzWaTHyGEML1u13Wp0NyJ98ANKBUJ0TP4AW0NPngGJ5Lj+WIjTevLNP6QBMCFLTDpPXZ9T4giltaKyd8gcVSKIsX0yAaFStsaEgeltCIQiFbTntllb2eDAzfwUhx4frvmuvdcvXqNl69e5/Llf8fVq9dZNx1b2ztcfekqy+WSs/fex87OCUC2AQyRou+ZNy1RwfLkNnSObnODYV7Thg68R2TUIsWezWbTNsjocnDeE5WS5+4jhbUoJN7IhzA1VADKFAtl0vseY4nGZxlCnKKSAGnaxMjhzSP2bxzy4ksv0zSNSLijSK2NvT0OylpDURnO3H2Kc+fu5dq1AwBcCBSV+EAUkbqeMaSNhHEn4bWNN3oVtt/DX7+liQBw5oEHOAM0TTN9b/9rewyl5cJP3N5EADj3ZhmN/xNLnc/+BX5oB/jKszzb3/L9yxe51MDZv/RjnAXon+XpLzVQP8hP/ZVbmggAmw/w6CPngYanf+/Sn+w6vgXP/esvsg+cf+TR4yYCQH2Bv/bjZ7GLJS9ccXDlab7wMnDfe/mZW5oIAPbsw/zMj+5CuMIXvnj19heoH+SnfvSW4/U57k+bIBf+8u33e/Mtb2UX2L86nuM5nv79fagf5K/9jfO335P6HI/8xAXgKl/4N1e+izuQyWQymT+L5I2ETCaTyWQymUwmc4eoJEse5GsfAU3bpkl1IrO64r777mV1uKQsK65d32cYBkKUWKC+lwJ638nE/HwxZ1bX7O/fkDiksmJjY4OTJ3cIKHyQjPoYA4vFHICNzTm2sFy/vs9iY8HGxgKt1eRmaJqWrusI3tOuWwbnmM9r5nWNtcUUaaS1hhhxzjGblTSrjuADfT/Qti1t20LK1x8jhHQq9McQUIjAWAraSBE+5fBHIrEVB4J3Du8cVTUjxpAaHQ5rZgAiMQ4erccMfokvcoM0E/q+px8GET4biyIStMiBbSqWay3yX6l9a0L04lJImw6DG9IjHCvUIj4mRrzzeOeZVTNpYiQJsRTUw+QWGCOrtJHmy74BfXJBtTzCb1hWp3bojo4wXZfioiIvvLCHQnF4eChxTMDVa9dwzrFaHRHcQGtgVZUEW/DS3bsMaOy6pUDhZyW2aeiAamMBtkChcElOfOs9C94TQsR7iZSKSaDsB4dCTZ6LYRgwGIIPdKFLt0U+P1olgXZqIlgrjYaqquiHgbZtWB4ecvPmIWbnhMir02aNMYaylAaSfD6k+YKCU8VJnn/hJbyv6ZqbbG6d5PBgiVKara0N+vGe3fLP2euWnV12vtXPrl9lH9gFdt/9QX7h3QCOZtlw48XnuPrSC3z1D5/j8nN73+VFnOXH/tJZnvrNyzz9xSUPvluq9Ze++DQN53j4Hal6/+JV9gB+8DznX2GM0l64wPl/cZnLL17lKvC9CfPZ5+vPN8BZ3vjGf7/ksvmjH+KXflS+dl+8yhI487bzvJKV4OyFH2Lz/36Kqy9+09Xt7HyLZ3CGs2e/6Vva3l74efnrfL0B6hf43U89zrPffIpmnxpYPv8CS8694nVlMplM5j9OciMhk8lkMplMJpPJvCoxVTbjKFv2Icl9QxIXR4ahZ7aYM3hH7xzLoxVN001F6fV6hQ+BYejRRlOUlrvvvnv6fWss9XzO5qZsIqjUSDBpot8NEkUUgsTRyDaC4ebBTWb1DO89fS+OgsODmywWG/RdT9d1bGzUMnGvVcr/h3H6u7AF1hTMZoqbBzcxVibxbVEQgktT51KgHtyAxWCsoe87iqLEeUepS7x3EKWwrBTEEKfzo5U0C5TCKC2T/cFjjZmEv1op+r5jnLyXor7c46Io8CnWaDGfE9Mxxlhi9Bgtf+46KWo75xj6AWPN5EYYo4CcGyaPQ5Gm6EdZ8LFgWqKMpMkyo21bqqrCYFA6ElFEC+tZwUpFlNF0URGcY922soGhNTEEjBFXhfcuNVmEvu8ggpnPuao1mAIzK0V0raAsLFFpqnrGoCEi51MR2rahKCqM0dOzCSHS9R2z2QzZO1EEJ76IGCOmLOm6btq4EO+El0ZXCNOmiTaaMMiGR1FKxFPbtQCpYQbEyObWBtvbW/K59n7akogxYstqirgKXp7PW37wjTz//FX8sMuqlfd+6tQJtrYWOO8IQUTaUccp1up1yebmty4uD3C8Y9Bw5fOP82u/fZnlrYsHtubszi7Ny/vf3WW840HO/eanufLMRZbvfg+b/UWe/jLwtnfz4HiByxssv91Jypriu7qKV8LBALDLmZPf/sj9mze+/QF1LUX9b/7+yTPsvsLh3xHNHpef+TYNnVVDA7mRkMlkMpmJ3EjIZDKZTCaTyWQyr44CAnjvcIMjhohWBrQIeI0xtG2D0Zr5fMZe1+E8rJsG7z1HyyUqRb6MkUKzasb29gnZcIgSc7O5scHW9hY6Qpem6GfVTIrLgHOOpmmSTLmkbVqOjo4oyoLd3R2R4bYtWilCgKEVB8HGxoKyLCaxcowK78cCu0zYO++SnFcKz9oYIBCJ9F2PmVVSyFaWoijAFsQQJRffGNqukwgn7/FBsvnrei5NgCRp9j4QVJim5UMIzGYzvHO4VIwO3tN1HT4Vl4mREKJMuFcVs1kNSjEMA84NVFU5NVfGLQJxRpCm9UX03PfiitBap4n7iLHjRoX4AERSXEySZucGhkFTVTMRNAODc9SzGfOyZtU0MBcRtNEa34+NDA8qUFUzurYRf4Hz4n8gSkOn7wko0ApVVTRdS9FFZlVFsJY2xUZVGxv0qyOM1hKjpRTGiPx4jLUanMQ1xRgpbUFRlBA9Q/BoI24KYIoxssawbhppkvRdipOS+1aWJW7wuGGYmlygpp/V9YyyLDh9+jQo2WgZ5c1j5FVRFFM8VUwNiq2NBT94/xvY2lzwxd///1Bac/be00QlzzuEQIiR41bLf9hc/e1f5ZOf24OTF3j4Lz/EW992hp1qk7oEvvwYH/21766RwOaDvPttn+bKV57l4s338NBzz3I5wIV33eJM2Nxhk1coxI/0DcN3dxWvgEW6E/tcvQ58m2bC7vYOcPVbH9BIMf/7wvn38UsfeDAXhTKZTCZzx2RHQiaTyWQymUwmk3l1YiQQcS4wZdUrjTGWorB0XZuKpw4VYffUKQ4OD2naTmKCmm6K0IkhUJUVd99zF9ZKQbjve+aLBfW8RmtN2w8slyuWyyVt27Barei6LmWwywT/MPQ0zRptNBsbGwyDZ7U6koK41gzdQPABYzVlVRKJzOfzFM+UJu9TgVgBrh/oup7eDaAgBifv1VislRghrXWKHZLCdEwSXoVKRWfxGmgtUuJxmr0fetlsIFLX9VTwr6oK76WpYLQU+0OMlEU5TbcDIob2nqooCDHQdy1aK9l8SNscMUSapplicYy1EoWklNwHY9Jx6cKJGKPR1qIM2MJiiwIfPN3QElXEFhbn3NTYQMXUKAm4GAhRNgGUing/oI1mVtfEGDBKEbwjBJ+2LzRVVSKxWOC9NG3kXiqqsiTGIDFOMRLHBk/aoHB9n4TJDmtL2QZJTS1pnkjTSDYMPDE1p1BMGx5DiojSWjNfzKcGAEDXt4QYmNV12nAIU7wVyLZA38u1njlzip2d7RR7FcUfkTZvlFIp0kg2QGxRUFYVRVmwWMw5c2aXd/z587z5jXdz79nTaOS4wQ0iXP4z0Ue4yqVn9oCzPPJfvp/3/vD9nN1MTQRIUT3fLZYLbz8P7PHsl67y7P97GeoHefBttxxy9xlxJfy7y1wO//4Z3KVLXE7H3R5rNND033Rw/3W+/jJ3wC5vvK8G9th78RV+fPk3+Pu/+Pf5xGevYM+cYRO4+pXLr9js2Lv0ZYk+uvt7E7oEwMkz4lD4w0tc+ub3CLhn/ikf/cW/z8f/1XPfu9fMZDKZzJ8JciMhk8lkMplMJpPJ3AEpT997if2xlsLaqdA9OhLcMBBDYHtrC63Fp9B1HYeHS5q2TX4FqOczFhsb04S5Uort7W2KoqDrOg4ODji4ecDh4SE3Dg7o+562bVmv16lwrThaLqlmFW94wznm8wXXXr7G8vBIJu+7HqUMg+vZ2NygrAqU0VMxfRgcSmmMlflvmaBXGGtp24a2bWQLIU30z6pykg+LL8Bji4LCSuZ+0zZScO87bFHIVsS4HeAc0ftp86JrW4wxLBYLqqrCWkuMiChaSTOh60W8HGPEpUn4cXMiprgnrfUkcfbep3gcT9c202t3XYs1MnPsvacoS4nQiYASr4I2Imae1bVsjYiBGWsNs7oWibBSNG1D27UsNjbkNUNyObgUDZQiqPq+p67nGGuSu0I+Jz5FJiml070uUiSWI0bZuCisTbFPYSrw37x5c/qcBR/QWjYobFGgrZm2DbTkVeG9xw8DXd/jkyjaeUc/9FN8k9bSBGvalmEY0u+OWwcFxhoUiuVyKc2gtuPm4ZIX9l5k/+AGb37zG5lVsq0wbkiMfoSylOgk55zEY8XIkGTO1hoWi5o3/8BZ3va2H2B7e2P6PPXDkLZleM0dCVbLZ2Zo/oQy5Ikl+9+U3uP2nuDxz79CIyG9ZtO0d3x2+8C7ebCGvYuf4uk/hN0HH7rdhVD+BR58ew3N03z2t67cPt2/vMjjn7kM1Dz4wxfSN89w5m6Ay1z6t7ce3XDl/3xKmg53wP3vehe7wKV/+RiXbj1NuMqTn32axsEbf+AcnHuQh04Dzz/Jp754+4aG23uCT/3OPuhzPPSu72EjQV/goXfVEC7z6f/1IstbGyzNJbknDu5/2/3fu9fMZDKZzJ8J8hZbJpPJZDKZTCaTeVVkfv14QlwiimKKwJFGwny+mHLvy8JycmeHP1KKbhgYvKfpW7Y3Nzmxe4Ld3V1ApsdjCJzY2WY2q6ac/+VqKXn/PjCbVbRdjw8eiCwWC5RS3HvffXjvuHbtZW7ePOTG/g2MtYQIEUXbNaCgqkopDhspUPvkJqiq6rgYn5ogIUSJxUFR1xY3DBSFpSxLjLFJritF4TFbX6lRuiwxO33fo4DBDVQpr382m3F0dERZlKhU5B+GIb3fDmNGJ4THWpnMd95RFFUq/EfqOk3Qx8Dm5iZtK1sJWmnaoUd0z9IY8F42GKathsmxLNP1IQZ08ipYY3BDTwwSgaSNprKlSKFDSNcyMF/MpzihtmlBMXkBhqHHGk0/yFbCMAx4L5LsqppNsmaREsvPjTFUqqJKPoG+HyhKkWEbrdFAYSyta2QrpCgAne5fTBLuSJFcB+ApC5EbG2spC5tcA5EiFLRtNzUNQggMXjwJbiryF8QYsNoyqyoOby7p244YIl038Ad/8EdceX6PN73pPrZObOGDpx96ZrPZ9HkAGIZBNkq0Zuh7cUXEiLV2amTE4LFW7onWCpfisGQhYQz/eu3YvfsMsMfl/+OTPPZHZ7j/3Y/yUPWdnOEMF955lic+u8cX/udf5Lm3XODsApoXLnH5JUd9cpf6+v7tEuEzsj2w97uP86vrc7zx7Y/w8NteJaFfn+eBt9c8/XtXuMIu73ngm03Dlgt/43088LXHuPg7n+Rjz57l/vNnqFd7XPrDq7gAuz/8KH/lLce/ceGHH6T+0tNc/tTH+NgX38r9uwNXLz/HXvdG7r/vKs89fwdv/9wj/Bc/+Ryf+NwlHvvYxzh3/n52q4a9S5e52sPmO9+XXvMM733/w1z6R09w+VMf5xc/f463vnkX9p/jq19b4qi5/6/+DA9t3+l9vzPu/+kP8J7nP8lTX3qcj11+kvMXzlJ3+zx3+QpLd+v1ZTKZTCZzTN5IyGQymUwmk8lkMq9KTH/x3qONTnEzbiqIG2ORyKMC7yXWZmdni63NLXrnWTcty6MVBwcHVGWVitI9Qz+wsbnBfD6XafquY71e0zYtQxInr1Zr2q5FoShsyYkTJzhz5jRVVXDz5k1eeGGPw4Mjgg8oFMZYlDY0bUc9r6nrGVVVUFUVq6Mj2SawMjUeQkArTdO0k1tglB977zHaYJNgdyyGG22JIbBer1FKMa/n0hCJIW0g+Cm7H5jOOauqyUlgrEVpjXMe71MhO8UIOe9A6yQ7HuT3tJaAnSgxPqvVSmJ+hmF6NlVZUlUzhvF9aU09l+aDG4vcrp8aIGMkUj8MgEqbCMiWRmpkGKNRRlFW1SR9DiGgtEiE27bBuR7vBiJyvuDD1FAamyXeS/TQuL0wNmXE4SAj0dZajE4NniSlFufGPDURZGvDDdLMcMGDkk2CqqqIEfpeslpG/8Qw9Gmrw6XafKSqKvq+xxibnltMvgnHMDhCDEmCLdfpXWC9anj+hRfxLnDu3BvEgRFCagTIRoE0VCSGSbYx5P2VZUlZlpMI3HtPYQsKa1CIp8MHL5+F8Ar5O68F5x/mfW/fxTZ7XHrmIs9e+bbK4lfkzI9/kJ/76QucreHq5YtcfOYSV4q38vDPfoRf+K//Cvdr4PmvM+l+Tz7EX/+xc9R6n+eeucgXvnJn8Uf3/4hM/3PfQ/zYN/cRAOoLPPrzH+HRHznHLle5/MxFLv7hPvXZCzzywV/gI3/jPPWtx7/lfXz4g49w4b6C5muXuHjxOdrTD/GBn/8gD+18B+//Jz7ER/7z93B+x7H35YtcfOYy+4tzPPQ3P8LP/80Lx69513v50M9/kEfefpZ6dYVLz1zk0vOO3Tc9xKN/9xf44Lu/h9sII+U5Hvnbv8AHf/oCZ6t9uSdfvkKz+QrXl8lkMplMQsX4Wi9NZjKZTCaTyWQymVdif/9g+np398Rr+vru8AV8COwf3OBf/97vEkOk7XrcIELZWye9vXdTzMzlP/h3PPX//Bt67/DeUVrDX3r3Q9xz9p40ke3ZOXECbY4lwYeHS17845fSK0dsKr4vFgtOnzlD8IG2azm8eZN+GGjWLX0nRe+maen6jhgU1ijO3ns3OzsnOH1ml62tDZqmwzmXooFkIt8Yg+scq9WafnBcu7GfZMUKowylNZw+fZoYpThvC4v3jnpWMzhHWZWEmPwPMYioN025z2Yzooopr99M2xtaG7xz6BS3VJYlxEjTtvTDgA8h+QUiG4sFLhW6zehqUFLcHxsEYSpAK/pBGjRb29vT5H+Mcm+LYsbz33iBz/9fv8uNgxu86y++gwt/7jz1vKKa1XRdixscRkuzyGhpoojQWO6bSY0VYpgijkLaZiCCSx4BacbI7xRFQdM0KfaoTtJrmbwXn4F4Bo5WR8yqGcPgKIuCCFPcVVEU06aDtQUuShE+OkfTdTjvk8fCpA0DK4X74CcRsndO5NYhELzHpUZVVZUM/UDbSuNh6B0H+wcSRbS5YLVa8bv/5lnO3nsP737oL1IWmmFwaQtB3sd8PqfvOozSsglTViJPTtFF3vupwTNuQpRFQSCys73DO9/xAHefuovZrMIYzT1v+fPfz3+8/+yw9xk+/itPsfFXf4Gfe/erbDBkMplMJvMa8Kfx7/SHh4ffl/PeSt5IyGQymUwmk8lkMneMUooQISARO0DKmzes1+s0dS2T+dYazp49y6nTJ1FaCsv1YsFdd901/c729rYIflPOfdO0tG1H17V0bTdF4Sw2NrjvDW8AIjcPb3L92nWGJOEtigJb2CR+LlBR0feyjTC351uQAAAgAElEQVSf11Szcioqu1RYH19fp9iZoBSD93S9FJKLooCx6G+MTN57x3xDYpWIimFwVNUMrbRMmFclSiuU0WOC0ORr6NoWUCkKKqIUFGVBUch/Abq+n4rxcrxGK52y8yXwxjsPkRQf1Cc5ciDEyHq9Zr1eY7RE+vTpvYwxOSFE+q5Phf8g0VSIZDnGiFaKwhYSzzQMlGWF1oa2a3HeTz4HSFsWKdpq3ErRSiKLRmdBjJH5YpE8GeKMGON9YgwsFosUzaSm89azGd47FosFznv6vufg4IY0OJzDuR5jNMZoYvQE5xgL+WVRiqQ5RmbVjL7vcd5NTa4Yo2w2JMGyD4G+7ymKgvW6pWlF5i1OBpF0R0SePaTXefOb38DGoqZpWny6J7KNI/eiKqvUFAKXXAx939N1HcC0nTB+9tZNM3lCYggEAnnW7zsgLHn6s0+xr8/z7nflJkImk8lkMt9PsiMhk8lkMplMJpPJ3BEKsMZSFgXNeo1RGh9dEtRKtEzXtSLW9Z62FXHt2Xvu4sWXrkKM3H3XGSCwubkhUUVFIQJnFOu1TKy3TYMbwhQDtHvyFDs7JxiGntVqhVKKEzsnxEWgFKujNTf2D6gXC5k8HwasVZw6tYu1hrIU10FVVRhrJ0Hx+PehHzhaHTF4R0AmyLuuEzGwUczqGcpoylmFcz1FYaWYr2WafnAD2ijatpUishJZcUSK9CiJ5AFS00BNk/oxRJquQaXpfa0lHqcoSoKXexC85OnPihkxSNFcKU0IIlcuy4r1eo0txGsg12NwzlFYi7UGpSzOyVaCdxKjE0EEyyAy5WadnoW4D6KXzP7FfEGIkb7vxfGASJpHEbVIhsWZYYsC5zwmxfUcHS0xKWYoJjcFSuGcm6J+tNYQ4xRDZI0lhIjWBlCUVcEwONquwxqVrqWb/A/Re6L3hBgp0/bCOq4YnGNW11RVRdt2KZ9LIpnGr8f7bbSm6QfaRp6FyKdnHNw4YHCWo9UR9913D3edPsl6vZqijMZnXtiZuCaCw6XGADDFQY2Nq1HCDBw3skJkdbQS4XdqIuRewqvwld/gY//7V6FZsuzh7E89wgPla31RmUwmk8n82SZvJGQymUwmk8lkMplXRSHbCMYaNGCNoZ7VaKWmoqlzMjlfVbMkIdZoFbn//jdTliXee+bzOfV8hlIynb1er1M+vadtW/quJwbZdrDWcurUKe6++24k4kgm2k+cOMHuzq5MrTuHD4HBDaxWR6k47dg9ucN8LinfWmmMlTz8qiwn8e3oQXDJ9TB+XymFSnn6xhhI2wPD0IkIVzHJeZWSTYthkGz+EGC1WhOJ+Bgg/bwoihRDpG4T72qjmS/mzGYzmf5vW7q+l5gkmK4rhEDfdccOgyAFd3FIrNL9dzI9P7gpmkkbg0kxSs45jDbHP0eaAWUlwmOlVIoCkvgd5yWqyaZmjzQxYN2sp6+bZi1xPlrTd90kF+7T/bClbAlI4d1SzWYURYEx8n9FRcg8Fs9FdG2smZoKw9CjtEFpnbYChKIsaZqG6ANa2+kc3nsWiw2stVRliXduipUa47a61ICCqefDMLjJUSCbE0YaGN6zbtY0bcPbf+jPUVWWYeinc41NgsIWWGMprGU2m1HX9fQZA6iSY2I+n2OMmaTcfd+Dkg2T4EfZsnz2Mt+G7U2K5ZKls5z5kQ/wwR//PngEMplMJpPJ3EbeSMhkMplMJpPJZDJ3iBTAQ4wopTFGUdQFfTvgnGT4oxTrZk1ZFBJboxWbmwvO3nWa5/shTaVLwbXrO/q+J4RAVclUvXeOtm84dWqXc+fOYQvDcnkTrUdPQo1znq6XqJv1quX69WtSzHaetu3Y2trgzKlTGK2BSNs2EnFUljJt7twkBLa2JESJDJKYm3Iqwt/69Ri3451DKU09XxC8Y71eU1QFRVGhlMOHMRYpojRJIi0ROrNZDTFikg+iKiuGYUgbCBWD8yhtKArxJVhrcX5AaSO/SxTPRFnSti0hKmKEWVUSoyL4SFQK17b4SYzsUYpUIJcNiq7vpkZPWRZ45wneUxSWciOd28v1xRgnebRW6bqrWfJhRGwhef7WWmIUybH3EnmlxigjLRFNi8WCo+WSsipRaSvBGEsIfto+MEbikapKrsNagx9kU2Nez5lV4lqIAdnaiNA1DWhFn2KrjJHPYlXN8MERQ6BpWqqyTP4MaQYZY9J1eJwbsFZTz+pJvmzT5snQO07u7LK1vUBrMwnFQwjUdc3Q9/JZXK+YzxeyTpAirMZm1RgBtV7L1odzwxTFZZOs2cdIGJsqKY4q8y04+zAf+e8efq2vIpPJZDKZ/6jIGwmZTCaTyWQymUzmDpHGQFmUDMPA0dGSGD1lZSEeC237vk8F4igT/MAPvuUH2dxasLx5yNFqRZeKr6N0d7VaobVE4Nxzzz289W1vo6wKYpQmw2xWURQl1ko00HJ5xP71G1y/dp2DGzdBaQ4Pl4Tgufvuu7BFIVFG2lDP5/gwFm9lMr3rO5HuekfXyqaBFIh9KopHurbFaEWMQeKMgLKsUCh8kKn+uq5R2tB1PX0nGxnOOXonUUpaa9k80Pp4myCKvNgHPzUdbh7exDnH0A9TrBJIsVwppDGBTLb3fTv9PMZINZvJBkdRpHsv8uambYgRmrYBpKjdD32KJArpe4qu75jPa3kvqYA9DD0++Gl6HsAHjy1smuJXKK0gMm1ljH6HqqqmgviY/6+1Zr1aiTC5F/+Cd26KRyqKIgmIRVQ9yon7XjYsSDJnHwLGFiht6PthakTFyHTvxVkAbdtQFiVt11JV0kQwxkybHqP0uqoq5os588WCqq5QGpwfKIsCsYFE7r3v3kkO7pxPkVIlfZJAj89qGAZCagKJYHpNjCFJmcWZAbBYbEzbDKM/QTwhkexIyGQymUwm83okbyRkMplMJpPJZDKZ7whrC2KaTI9GsV6t8SGm4nULSqUCshREjRZfwV133cXLL79Ms+6Am8znC6y1HB0d0TQNhbXcd999zGYzQES2btAiyE2F8PW65+hozXrdcuPGTQ4PD6WA2/do4J6776KqJE6nHwbqqsQaS1WKFLdtW8mttxI1FKdJ/cB6vUKihyTeRhmNMSJxDmkC3RgjAuS+ZV5vsF6tiCptNAwDpRbRstUGl7YcjBZp7zihHoJLhXebpNQF1sixSmvqeo53A5GIwaCQCflZLc2UGEWcHFIMz/71fXyIGCOiZO8cRVFSlFbkz0pNkUbGmEnCrFOEkzGavpditvMuRQ+ZJIVWkygbwBYFq/WashQfQzmrpmK4UpqIEmm0NqxXK4wxx0LpEJJsWlwNSmvKFH00RjhVVUWMYXIL1LWIjZu2oa7nDMlvoNKxWmuGrkcZnYTF0hwZmwTOORbzBYfLw+k9gDQSRBLdJxmzwvsoTaPS0qxFkLyxsWBWV5SVxTmJpiqKgr7vpk2KGKOIx6NEHcVb3k9dz2lbafwMwzBFWikl1whQlgXOuUkULf8Jf1r/OGcymUwmk8ncEXkjIZPJZDKZTCaTybwq42YBUdwGY45927R4H44nz1Oki0zhy4S6d57CGu677z6MKfjGN75BDHLMcrlk6Ae0Utx7771sbW1SlgVKa9brIwbncG6Qafquo+t62rbn6HDFetWgtZ2ig3ZP7XD6zCnm8wWzeU2IydOQJtnbrpVzKRESd11HUUphXgre5ZTTXyRxcQwB78XDEILHGE01K7HW0DbraYLeeX8sHy4KjLVUVSnxQjFQJrHzWMDWWmNTUX/drKfic1lKJFRRliKwDrJpEJFp9mHoKcuSWVVJzJQXDwPI9P+4oWCMoa5rirLEpsl3NTV4dIo2UvIsk69g9FV0tzRbUEzeiDHWqigKnHcYozFpSl+EyhGt9PTzsXAv8Uhu8gTMZvUkYG67jqqqqGazaXvD2gJtZINjlBMX6Z6mjyBRRULwk+OiLCUuyabNEWPk8zluU4xF+3HjRGs9bQeMWxfWWrwXgbU2Ilyu5zWnT5+iqoop4sp7nzZF5D761NyI6RmAXPdqtZqaCKPE2jmXnnN52+aBCKuZNiuyIyGTyWQymczrjbyRkMlkMplMJpPJZO6QiIowqyrKsmQYFG4YsNowKCnM9s6hU5RNCBGtLaumZXNri43NFXVdcePGPv3wRrSR5kM1Kzm5u5siZf5/9t4+xrLzvu/7PC/nnHvv7OzsznKH1Ehe2l7TQ0LDdqVqDdOQWpiqJcRUQ8MUXAamkQipikBwiFZOaaVUoTqxGpeo2UQ11CJKIRemYSY13dAIlZqGKERMozQrU+tyBO+U2UjciGNxKM5yd+bee16el/7xe86ZWZLLl1oUGev5AIvdnbkv5+UuNfp+f7/vV/L6jbXEqCisQSlN13bsTWfsXt5jb3fK7u4udV1TzxvqesbR5aO87W1vYzwaEQm0dYtNMUbWWKw1VGXJdDaDVPTsvGc6m9O2nfQLpP6CppEOgUOHDkmxtLXYQl7DuY62aVBao5TBE4hpO2CY4o9Ryn2VZP4bLcaFUiKsO+eo63q/fyH1FcQYqet6yO43RqNUgVaG0XiEUpHgPV0q6S2rUepCGNF1U5q2oaKkMAZiSJ0GfugAkOl/kahDjFg0VSWCuPNezAYUphrRNLVsRGg7xCVpbeiaBqNNKleW3gfXdaAUtijSPZdeAG0Mk8lEPjk+MJ1OMdYwm88IPgwGRdu2aOfkuNLznPdDyXMxkq6Kup0xqkb44NNGTEVTNxhraTrZ5lBG03QtWurBU29HipJynmo8wrluMJ96g0FMHk89r2WrIKQ+iqJgcXERrQxRpU2K9FmfTCbyPOdlhyBECisF2P3nwaWCaIlcMukzZmiaZthOKMfSf6GU6pOUcrxRJpPJZDKZtxx5IyGTyWQyGWDjtz/BJz5xP489d/Crjp0nHuTRP3mzjiqTyWTeWvST0kUh09NlJdPsxljG4zHG6CHmphdSfRChfTafsrAw4ejRI3Rty2w6TdPnhqXDS5I337aEJK43TU1ZFkQibdswnU3T9LcU1kpEUeSFF17Ae8811xyjLEsWFhYkjifF3CilCDFgjMa5LnUyiLAbAYVmPp9TN03apPCMRiNiFKG5n1LX6fWMsWKitB0BKe1t2kam570jeJc6BPbLfA8tLsqUvZapfYn3gWo0gjStPp/PiTEyn0vhtNaKmMTlIkU7KaVwPsjrRDX0AzRNjfMpLkfLloCYAuxPzCMbDTEJ6EqB0oqQroUYPwFjDaNRNcQhVVUpUTwoyqKgKqsU6xPStL+YKG0n5oZPE/dF6qhQSrYMOi+9Eei0IRID1WhENRqhtMbHgDJaDJvCSil2jGhjaLsubZcojDUoJG7JuQ6lpZxZopLUcJ6y+TBiPp/TtG0yBjxdJ1sIWmvp0Ejifv+5dd4xn89kc8QHjhw9wmQ8Hj7/EnW1b5AAhLh/vrDfGcGB6x+jRB31/Rs6nR8wmA37/crZRMhchece4/5PfIJP/PbGa3r4y/98+z3idR7ry/H6jz//7J7JZDJvJNlIyGQymUzmKux86bPc94/Osp1jijOZTOYKqqoi+MB8NkOlqe+9vT26rsO5jqIsU458i0JEW6M0VVmxcvw4RVFQNzXWGiaTBaqqpK5rbBJpAazZLzfuJ+VBROK2afE+JIEblpaWWDx8iIUFyaPvum6IYOrLnEOIKaO+SCLyCAW0aZK9KIoh8kay+kfD1xYmhxiNJxSlCPrGGMaT8SBgmyTaV2VJYSy2KJgsLGC0pq7nw3Ww1mCMHkyX+XxOXc9xzovQHQLj8YRqVKGNpiwLyqJM+f2ytWCtZTaX8mTnAiEJ5BJ3NGJhYSHFI+kkYEeKYn+roCxLkalTeo41UpI8Go0oi3IwNYpCYo16UyjGyLyucd4P3QQHJ+9FlLe49Pz+2sxn01Sa3KaS44gLgRAjTdvggkQzaSvmQeccTdelbZFZKuSW7Qp6AyhFJRlrUch9lntnZFtCpUiqFKdUGCvRXKkkuo/h6iO4pOS5ky0MHwHpuSjKkslkIgZD54aNlbKUTQmd+ick4igOnRJ91BPsmwp9N4S1djAX+vvTX1+t1L6ZkDcSMpnXTf7ZPZPJZN5YcrRRJpPJZDJXwQX3Zh9CJpPJvCUZjSqZDHea7oBY7YPHaMmbr6qKvb09EVcRA2Dh0ALHV67h3KZiurfH0tISk8lESmzTBH9fROuDxyjJ0Y8h0nYtu7tT2UyIoJSmrmtG44kIxFqE4YXJmPayk6n8lHPfbwaQpvvj0HcgxcQyoS+GyGg0YjabAWKYSC9AoG0ajJb4nn7TQqMobEEXpYA6eM9oVFElo6Bp5lgrRcOzbk7nHOPxmKZpho6ArvVopam7etg+UFpijYgRHzxalxRFigHqWpx3OCdFvyg9XDtjDJE4TLhrXQAwHo9xncMaSwR8usbyGA1pWr7rpITZ9CZLKk22Vu6tUhqlGMqF+ygmpRUaQ4xhENCD94MYbozBdR2mKOicdAjYoqAoK5x3RAVaKUKMMAj8HeO0CTCcW5Rcprqphz6LmF4rpnPpNy5GoxFd16KNkcekYus+WqgX/Pty4+l0ynw6J4RIVRQYqzl8+LAYCkUhGzCIkdAbTs45mqaVLolE//re++E+x36bwtjUr1AM762UbHp4L5+DTOYVOX4rH/+1W9/so3htvAnHmn92z2QymTeW/JNKJpPJZDKZTCaTeU30kUGFLYeJ7hijCMnaSPFvmqyWqW+ASACUMoBiNKo4srSMUZpDCwuE4Omn/GezuUT+VCOsLQBFXdfM6zld56jrhtl0Tj2fsbd3mfFkxGQyQkeFbx0xeEAKn0tbYI2mqOwwLW9tIdE2CoqiJKTp9j5qRinF5cuXqOt6OGdtJPKnLEqUNlRFSdc6ZtO5iOAh4rwnBi/dBClyRyuFQnL3m7pJUTl+EOF39/ZwztO0DU3boLWmLAqK0iaTw9C2HUSF1hJjJNsPhoXxAkZbiVcKEnXknUchordsP9jhnk2nU7TRtJ1E/oQ07K4Aq2VLoe99sIWYFm3XJvE79UxYi1LSrdA5NwjsWmmsNvLL2kHwt0Wxf12RbY3SSKxPlyKQfPDDAH7btrR1neKm9oX/XrDXWjMejYkhMBlPKKyl61JkUtcOkUXzep76OzopqHadHHvaHujPpS+m1lrjnaeuG5qmQRtD5xpsIVsWdV3jgkdb85Ltg+AD49FYoo9iRKdopX7joC8eB/n34b2InEVRDAXSRSGfSaW13BcV94vNM5lMJpPJZN5C5I2ETCaTyWRewjaP/fr9PJryWDd+6xN8Alj/hV/jrne+qQeWyWQybzq9uGy0TF2TNg6MsYPR0AvAMkAeh+n74ANVVXL06BGUCpRVRbPbADLJfXn3Mk3bEGOgKEu8k7x6QMqWd/fo2pb5fE7b1iwfuwbfeqbTPSBNtYf9TAttNNaIgFuWY5SCruvQStN1LU3TpPeLtG2bxGWGCCCtVfqzFPyKIG0gelyXNieiw2jZBCiriqiibCk4B0qhlBQHk7YW2k5y/b0PdG03TKIrLbE2Lk3RDz0TyeAA8E5exyVB2lorfQM+EmOgLFI0U/pe27aAxCL15+JShwHIFkdRJME+bTZYK4ZPbwroVBTtnJPJe83+8XiftkE02mhms3q4fv1npTectNbpeBgihrz3eOcGYV+nx6MUTduysLCA0YayrIZOBufdINS3rQjwWktsFun+j8cTfPDM5zWHFg9hbSptLuLQb9HGdugrqOdz2qbB+YAx0stwZOnI0NsBYg70162PdTKpI6LrOkbjMT74IXqpjywyaXtBzj8k46xgNBoNXRIu+GFbou9HeEuYCbvnefz3H+HLm1vspltnF1e58T+6jdt/4iSLLxpLnG+d4dHf/xJnLuzgAtiFVW78ySsfu/Hbn+CBJ9e585fX2PhfHmbjksMeXeP2/+wjnD4GuB02Hn2YR//oPNtTB1jG77iRW//C7bzv5OLLHt9jf7LF3AHasrh6I//hSx7r2HniER78wzNcuJj+7SyssHrzrdz5oVMsv0ZVZPf84zz8T7/Mua1dXHil93t5+nO/67/7adzvP8gjX73ArpPr9K6/eBd3/PvLzL/5OA/9H3/AxrMOtGXlnbdx5396C6v9MT73GPf/+qNs33wXv/bz6wcu/gUe/71/PFwLu3SC0z99J9dfcQTneehXPscZTvPRT93ByQPX58znP8lDm7D43o9x74dOHDjpr/DZTz/MhYPvF3Y5/y8e5pEvnWPrle7R1Y6VORf++UP84/75dszqqdu56307/Ob/+HKPT+/5xd/loX+2yU4LlMucePcHuPMvnmJZQ/7ZPZPJZL43ZCMhk8lkMpmXMObt66dY29xkc2vO8g+e4sQyXL/0Zh9XJpPJvDWwRcFoPIZLLyRRNaCUiLQhBCJw6fLlYVOhNxckFidw6PAhFhfGKCSiSDYRpMfAOU/bOZQ2dM6nsl7P3nTG7u4u3sN8PqeqRngfaNqWqhqJaWBt6iRoCMEzHh9J0Uoq9Tc4FiYLKfpHYdN2AWlzAFLevjGMU3yT9x7nNYWViJy6qXGdI4SIVlK060KgqiqarqUoLTEJ7SHKCrgxhi6IaeA7j49ReghswagaERGhvSgKtFbJANmPwXGdk5JfLXFOKNDGoJTGB9kCmUzGqcy3kB6AthvimsqylC4L7+TclQjV/eOrqkr3UOHSNZeoo07ikFJcj7aGtm2whcV1HdZWtKFNj3V0XUdZVkNMkjESL1UVJcH5Id6oLCuMlteKUToelCKVb9u09SJGiFYKawzBe5r5nIDEPYUYUUqnImoxjZzrgEDnZXujKEXE77qOmIT62Ww2nE+MkaZpqJuG+azGOTGFlhaWqEaj4RoUKc7qoBGjtR7+Tozo4OnaFuc9Pm07RFLkV7q2WhuKoryip8F7T1VWVGWJtXqIjzrQvPzm8OxjfObvPcpWsCz+4Dqnli1Mt9h4aouNf/I5zm9/lE/97L4UPf/6A9z3WxvMkcefXIadpzbksU/fxT0/v854ePQWj/79DS6Xa5x6N2x9++28/Rgw3+DB+x/g7K6I62vvXmE83WLjqQ0e+dwGX/upj3P3+1fSG27wwN99gI25ZfnEOmvD8W3wyOfO88xfvpc7bxK5Y/uLn+X+P9zaf00cO+fPceFfPsh9F3b4+N23svIql2P7i5/h/j/cArvIiZtOsVzB/JkNNr8l77f9Vz/FHTe8lgu7zWO/cR9b24ucWDvFSSfX9Mzv/AN4ZpWNL5/D/uCNnHp3x9bGJttPPsxn3Jhf/cunri7ezDd44H94gI0p2GvXOPX2MfNnNvjK79zHV64we06y9iNw5slznLsAJwe/4GkuXJA/7X7rGXY5QW8HuM1zXADWbrpRvhC2eew37ufRLaBcYe3dq4ybHc5vbvDI587xtQ/ezd0/+UpXc87Gb9/HA0/O5Vq+8yTLbouNJx7kvj8ZH/iMHGSXr/yD/55Hp7BywylOLczZ+n825f5d7PjUR04zzj+7ZzKZzPeEbCRkMplMJvMSFln74J0ctfezuTVn9X13cmeeZspkMpkBEYgN1hq6kARo75lMJhhjuPjCRZQ2uM5RFGm63RpiJEXUVBxeOoxzLVqLGCtFyJYQRGSXaB+J15lNZ+xd3qUqRzzz3BZKKRYWDtE0DePxeCixNdZSN42IyLYg+IAdegO6JLx7lFa4rpNSYNfRdR5jRJTuS4uVBmNkGl8EYeliCD4QYsA7z7yTfHxl+ql7k0p0HUVZYrwfjJRevG7ahjaJ7gALC4f2i3uB0WhEjBCCZzQeM0qF0c5JhI/WmqZtUEqiisqqQhsrBc2p0Nd7KTC21hBTybQI4XYQ/XuKsgTYNxu0o6lrQpAyYDOW7QKtjQjmaVvCaEPsey28IwQw2qSoIEdVjXDepailmET+tKVA6jMgorTGWPkMVFVFURRDgXPTNLQwdG8orahnM6pqBCok48rjQ8Da/X6Ntu3QWhGCGD4k88FaiRTqDQtrLJeby9KPUDc0TUtVViwdOSJF28k8UEoNGx79pkZfNB1CkC2Rzkksk5KdAu+9xEm18hkH2RLpzaE+3qjv5ZD705sIwJu6keA4+38+ylYYs/4L93DXOw/Iu/MzfP5vP8TmV8+w+bMnWQNoz/Lgb28w16vc+osf4wP9+HwvOj/5EF/YXOeOtf5FdthZuSMJwPvvufF7D3F2F1bf+zE++qET+9/bPcsDf/dBNv7wf+ahEyLY7/zLx9iYwtqH7+Uj7zlwfBce4b6//1XOP3kOd9M6lk0e++IWHH0f//l/dRsnBmF9zpnPf5qHt86x8eyt3HrtK1yO9iyPfHELFta562/cxfrBy/HVz/Mrv7vJma9tcscNa1d/jYFttuan+ei9d3Ayvc78X32OX/m985z58pz1X7h3/3p/eJOH/vbnOfMnG2yEU5x62WBquW4bU1g9aLRwwPw4wPqpdXhyg82ntrntRHrshXOcmyOu5zfPcz7ckt7L8bUnN4E11tflnl74wm/y6BYsv+cj/PUPr+3fo/kFHvncZ3n8Dx7gsfWPc+vxq5z+5hd46Mk5rN7K3R/7wP6mxcUzfP4zD7H5sk+asxvWufNv3sWp3uH4T87ywH0PsrF5hrO7p7llMf/snslkMt8LckdCJpPJZL6v2Qiv/phMJpPJ7KOUxlqDsTYJqREfAsYaUJKf33VOYm8QQbWua7pWhPsYYTKuOHRogbpu+dM/3eL5559n9/JlEXetTiKwlOZevPgCL7xwibZzfOf55wkxMBqNZKK/sESCTMh7TyBSjccyhV8UROS4rDUoBSYVC8/nc5q2o26aoSi6LMvUpSDGg5TglkwmE0ajSoqDU/a/9wFbSqwNKmILS1UWVFUp2f4+YJSS6fx0HuN0XCFC0zSUqSy4ns8oSktVlUwmY+l3KCyjqiJ6P5gss+mUuq6TIRMJ3mO0IgZHYSxE8D5QN5ciVl8AACAASURBVA2ybxAARdM2dG2XJuk94/E4lRprFIoYPFqJadMXKnvvpCQ6mQwiojdpQ8FQ2GKIPOq82xfKi6QKKujahhg8wct2SYiRoiyToSOl0aCw6diNMYxG4xQHJdslhbVopdBI5JEy8joqlV5rkO8B89kM710S/uU7oOnalsKWQN9XwGAGNG1D23ZcurTLpd09TFFw5OhRysrivaNpJXarj1KSbRWLQqEiFFY+N5GI8y6ZSKnQ2VoUGqLEdnnncK4bthjks556J0JAKT1cxzef8zy9NcYefx8feOeLZsTH13P9MSA4uvSl3a/+CzYDLL/3w/smAoBe4dYPnmZcWp7d2r7iZdZufteV0+ft1zjz5BzGp/ngT5+48nuLp7jztjVgzpl/tQHsl+pefP4iV9TrnriNe371U9z7c+tparKTGKL6IjvTK06E0x/5VX713o+9sokA8I2n2RpbVn7iA1eYCHI5rpdthq57uWe+LCfe94HBRAAY/9BJeY1jt1x5vfUaJ38YYJud56/yYuEcZ78+h6X38TPvv3ITYOX9H+Z9R1/0+BvWWAO2nzrPbvrS7reeZpcTfOD9a8B5zp/ff+3Np4C1dd5VApznzB/twPg0t//s2pX3aHyC296/Dmzzlf/7wlUO1nH2X55hziLv+5kDJgLA0dN8+P2rV3kerP2FO/dNBIDxKU79CEDNvL7KkzKZTCbzXSdvJGQymUzm+5rt54GrTU1lMplMZiD2Bb1K+hAKY4golI7oqAjRY5XBJiFX4oPS5HnKyDdaQVAsLR3BmILpbJft7edSlj5MFhZQSgRx7wNN0zKf1Uz3ZkynM5q6FuE5RSUVpcWaEqUVIQaatqNIufdN01CNS4nB8YEYpdC3rEqcc2Ik1A3GiBjc9ziA9ARopbCFlb6GQoqfAUKIhBgJiFhsrEytG2vQSlOOyyGKKKQInhA8dS1bFjE0cr5aYZVNkTcS5VOVVcrGV9T1/IpC65B+39vdxactkL5UeTSqhmx+ayS/3xoz9Et474aCae+7odtCNi3ELNBKonrmszlKp22H/ntX3EOLVk5KiXvxVAFK7llRFFhraEPqYojFcB3aZk6IkWo0xrVNuieNdD0kEV2lD1tpCzSK4D2dl6l9hRqOt9+OAIXVms5J3NB+P8d+NFPT1oxGo+G9RPD3dF3H5UuX2L28S9PULC0tsnTk8NBX0McaxRiHXghtNG3dpK2EQJc2LfrX1FrLto6RjZwQAzpGolLEyH5cVfr3MRqN0r8rJV0ZUhExvN+bwxq3/81PcTtAO2d39zm2vvUsz3xjk3Ob57hw8cpHb31LhOMTP/QyQvDaHXzqb734i8u8/QdeJEV8e5stgB9ZY+1lxh3t+jpr/2iTzW9vsw2s/HunWP3io2x96TN88v9aZPWH1ll/97s4ddMJlsuDz7yR0+8es/HEBg9++pM8fHyVkzfdzC2n3sP1q+PXJois3c69/83tALjpLpef3+LCt5/h6c1zbD51gZ3X8hoHz/7oVfoUVldfErFkX23087kttgJw4npOvOSbq9x4w5jH/9WBL5XvYn3tITY3z3GuvYXTpePc5gU4divrpywbf7jJ+W9uww0r8Cdn2QhwYu1GuU7PPc3Tc2D8DP/idx/kay9+u/kOY14aj7TP05z/JsD1XP/Sg2XxhhtZZutlrueYw0tXu1PbbH+H/LN8JpPJfI/IRkImk8lkMplMJpN5Dajhd6Nlklxy5hXOdVSliMNaaymp7doh+kUy4VuCNzRNzeJokabruLy7i3deynmViPQmZd0757j0wi4vvHCZrnXs7U0lBmZcEXygKAsOHVogRukDCCGgUDR1Q1M3HDm8xKgaScRRjLRtB0kc9iHgnE8FxDZtL4hQX5YlxIixGq1BkeJtkPgm5zwoJSW6SqFSGfLl3V0mkwljrVKxbpOm7CuaFmbTKTpFQo0nY3kPYyX6RzEI1/2lNkkk77P0R6ORbHYkcXtUiTBeVSMR1bUCFNV4RNd1NHU9bFXEQjYB+riirpX30em+KF3ivEM56VQw1tJ1c4IJOO8wwaaIJk08INS3XStF21qn2CCfooQYtgqUMjjnKYoSWYSQ6CNr7NCpAJHgA21TS/yS97LRAGhrknkgMUgHY4G6TqKvAnEwPbwKWFNIJFUyG2KI+NQPUZYlWknkUF03NG1L23aMqoqjR5dYPLSQzJ8wGEx9j4NsggR0ioxynXQiSPRUB6hkVhTp8yGfZZ0in6RPxA19HdbadM1S7JPW8KYaCAe4eJaHfvN3OfPsFfP+2KMrLI+32Znvf00+tiusXPNaX9y+VCDfvThMyL8s5Zji4N+P38rHfmmZh3/nYb72rV22Nr/C1uZXeBSw157mw3/lDk4dlfda+/DH+eixVNT73AU2nrvAxpcfAbvI2k/+Ane+/8RVsvn32fnjh/jNh86w3R74orYsH19m/OwO86s+88W8nuv0GvjO9isaGYtLL5bzLTeunYDNTTafgtPvPM/5p2D8npOsHCs4ufQoj58/z+5PrbC9eR44wbtuftFrzLfYfGKLqzKdM4eXMRLmzOfA0RWWX+552l5FoFrk6JGrv53L28WZTCbzPSMbCZlMJpPJZDKZTOZVUWmiGiJaKQpb0rUtHoXrPIURgbkoCw4tHuI73/kOXddibZGeL1sK82bOoj7M3t6U2WxO23Z4VzOZ7Et5bdvSNA27u3s0dcPly3s0zZzJwoT5bEZRWJaOXMNoVBGDQsV+mltRz+fEIPFHRVGk0HoRhvvj0UpjUllu14nAbqxBazlW7zskBSliC9lUsMYSYpRCXeewRSlxQs6hS53y7UUEjkR5fAhobaSTQKsh8mk0GqVNBE1ZFLRdQ9d5VCnnIZsDPpUf798Dm7YtqqoixCDifAiATLKXVYULHhc8bddhtRyDSRE8XTJ3+r4CrTXapvOzlqZpUFrhU6FwiCH1FaQibe9xRMqyomlqjO7jeCSOqLCarnPDZgeAS1P61hp8CAQvnQbamH3RPMrnqyzlfLooWxlt11IaTYh9EbRLpdzy+lGJvSXHaJNR4hhVYzEsvAdi6t5IBcna4IKYCtPpHvW8xjnP8ZVjXLuygtKaSVVR1/UV2w0xRimI9i1FUdCl/g4pEvfD/ZRljzhshVglnQ+kLQOTSrR1MqD6+0x6/lvCRmg3efA3HuTsdMzqj3+QD777naweHTNeHGPZ5rFfv59HDyjn0nf9Z5wMXzzKIlzdTGjnvDg8yB47xR2/eIo73Jytb2xw7usbnH1ik+1nz/Dgb8DivXdwUgN6kZPv/wj3vB/cxQuc//qTnNk4y7lv7rL5h5/l8+N7+dhPXGVLAHB/8iD/0++cZb6wyi0f+CDvummVo5Mxi2MLzz3G/b/+6OswEr7LXCOi/NXMhHo+hxfZJIvvvJnV37/A09+4AIv/mvMBTq5Jcfb1J+Dxr5/n6bDC5pNzeMfNrL/40qzdwa9+5PT/DzFpzHgMXBTz4+pBRplMJpN5q5I7EjKZTCbzfc3KsTf7CDKZTObfTXoRWgFWy2R75x1Kk3oONN4H2q6T0mNrGU8mdJ3n+ecu8o3zT3PphcuS149mNm+Yz+dpYt6xtztjPqtpmoZ5PaMcjYkRuq6lqgqs0Sijh64C7xyz2YzpdEo5GhGil1gZrVFpGtzaYhD8I1GieGwxxDb51EkwGo2oyhJjdJoa77h0+RJt09C5DhWhmdeEENHGDlsYOgnFVZmihoDOtTKF3jpADVsaVVWhgLqeU5WVmDDJQOi6NonRbhDKQx+dYzSz+Sz1LQQicZiqD87jmhbfdkM2v9IqnbMmhkhZFpAClFCRojBok8RyIlEhE/5lmSKHdBLqNbYoIMJ8PsMYQ1XKOVhjUDGiiJSFARWIMdAXBiugcx1a6+Gz0xdAOy8mC1oTYkQXlqKS9y6KghgiVdUXUIfBFGjblvGooqxKdG9++EBZlHSpi0AreT8pg5a4otlcPiPT2ZS93T0u7e4RY+Daa48zGpVDRFFd14Oh1Qv/09l0MDRcMkTEiIqDeSDRTjYZDCEZH3GIR+q3TvqtG+cchS0oi4LC9v0Ob7Kd8NQZzk5h/J47uftn3sfaiWUWF1MMUNhm60V5/avvkJyarRf1IABw6XE+819/kk//1plXFtuvWxFh+V9vsvkyE+ZuY0OKeK9bYYUdvvL5T/Mrn/w8Z1rAjlm94TS3/sxH+Pjfupfb3gFMn+bp54GnHua+T3+S+/6JxC/ZoydYe+9t3PXX7uVXU9nzhW88/YqX49wTZ5kz5vTP3c3t713jxLFFMREAtrd4mbP+3nF8lVXNVa7bLk9/82WsmaU11o/D7ua/ZuOpTXY5wckUNXTj2hqE82x+SQqYV25a298sOLbCigae2mCjfenLuic+zyc++Svc9/vnX/pNAK7nxAmAp3n6ZWoUdjc33txrmclkMplXJRsJmUwmk/m+Zv0V/pfQ6lTTN3dXf1Amk8l8XyKiqFEyQW2MhRhRmiTQdxKbn6aspbxYjAVjCv7fp/4NXz1zlu3ndti9vAeAd56LOxdpmw7vAq7zdJ1jd3eP8XjEaDyibRr582iENiK8F1ZiY7wL7O3t0bmOUTWSDQUkvieEgNEmlSnv/4dfJsAVRksnQr+l0EfiaKVFjA4SuzSfz2jbVgqB5QwpizJNmhuslevgXEdRiJhcNw0hRJxzqVBX0zT1EH3UH19RFBQpv58IIfhkRkjHgvwekvHCFbn9IQSJ6+m6QWQ31g7nGHwYDBLnOpaWFjm2vMTS0uE0ue9ouy6J2FBV5XA+ZVnKBH4nZc19V0JviPTXK/gw3Gsxbexg2lSjEdZK10BRlmhjZFsk7gvwKKibeuh/kNgkRQSC9yLKp00EmeZPxkJhqVLhsTYaH/zw2mVZ7r9+IoRA0zbMZ3NeeOESdV2zfOwYS0tLqBR51Jsc/fZDbyzINocbiqubpkkRVLJxI5sSaniumDXybyKGONxn57qhsyOGgE6GlcRHqeHXm8384uUrxf+wy9nfeYiNFwnWi+86zZqG7S8+yGPPXvEKbPyTx9gKjqMnb3zl+KDyXZy+eQzzM/zBFy5c+b67Z3nwkU1gzOkfWweWuf7agrnb5PEvbV1ZtuxSqbI+yvIScP31HJ86dv7oy5x9kaa+e0nOb/noywbtvPhqsHPpRVbI7lke+L2N1/DcNxC9zi3vefnrtvPV3+Wxb73ck1a48aZleO6rfOGr23D8Rk4mt8Befz0rzPnal77CLsus3XSgtaF/r7DJw//7WXYPfg7mG3KPHJy86eRVDtbyrh9bZ8wuj//jR9k6eON2z/Lwl14hLuk1kn92z2QymTeWHG2UyWQymcxVWL5uBdhi859+lgf+zQonf+JObnnHm31UmUwm89agz48v0Liuow2B2AXKNJF95MgSreuo57V0DCg1CNXPP/8C397eYTpv+IF3XIdL8S7zWculS7t0bUddt+zu7qK1YmXlOLvTKZHAwsIik8kCZZqGL6sK51+g6xzapngYrYaC5KGsOHgIgIr0k/I2mQVGawqticaCVlKU6x0mxepoYyhsgfOOQonw7n1MBc0eCBS2pCxLFAofJMKo7ToRkH0YjqWPArJFkcT6QuKRjKZz3VAG3KYYJuccXdtKqbO16esWk8qJe9FezIKOznVJ9GconlZKQfRYW3L48GHWfvQGfviHf4i2azBGI7aPlEeHToqpi2SQKCW9BE1T03WS698fo9YaIjRtQ/AeW1i5xzGCltiesrA45wYxvzcE+u2EGGMyfGRzZDabMqoqMQ2MSt0KEWsMRhvZwkgmhlcBuk5Ko20xGBDehxTpAiiGYuVRJf0RWmn29vaYTmdorbnubddSVRXWWtpWNgUObhb05oJ0IYhA2ccs9X8/+Pj+vsifIzGKIdS2bXrc/mezLKXbISYD5S3BDac5tbDB2fMP8em/c4YbTy5jmx3Ob15gNyyzfHTOzsVttp9DoozGp7nz5ze577c2ePTvfZKzN6yzuuDYOX+OC5cc9h0f4MM/fvXoIMGy/rN3cOqbD3D2n3+WT39tlZNrK4ynW2w8tY0LsPxjd/LTN8ijV//j2zn1R5/n7Jc+w3/7xInhGC88dYGdFlZ/6jZOlQCnuO2nvszmH2zw4N/5JI/dsM7qAsy3Nzn/rTksrPPTP/nKITs3vvsU4yfPcv73Ps2nn7iRk8sWt3Oec9/cxR1bZnm6w05fAv1nvvivn5Mfuotbzn+Or/zzz/LpJ+VadM9ssPmsY7wwhulLn7O6/k4Wv/w4Oxdh8b0/sn/cx6/n+jFszx0svZObX3RpTn7oI7zvW5/l8Scf5NObj7G2vsq4/2w4WHz3HcM9ejnsO+/gjpvP88CTj/GZv3WWEzecYNnJPS7GY/gzhkTln90zmUzmjSVvJGQymUwmczXWPsAdNy9j51tsPHGWr114xRrATCaT+XON4kDgSgRr9ieoIyLKS1GyQxszROO0bct0OmVe1zRtg3Mdo3GF0rC19afs7s1pu9QH4D0XL77A5cuXmU1n1HXN0pEjLCws0DYNrutkAn1UobVCG0PbSu5/07Q0dYPz0meAUhRlkbYh5Oh9KksWnVtTlSIeyzaCTODLFLxk9Pf9Bl3X0XYi0PvgRcRPBcl9Z0F/vn0Wvg+eLsXXaCM9BMQIUfoTtNJpil9RVVUq5nUpL59hWj+kPgEph5ZjNkYKiK0thsgipaRfIYQ4bEuIgYBsUAybIXDNNcuc+IG38wM/sCqdBF07GCpA+rsahPJ+Kt8YKZ6u61qE9BAJUbYSbFGkKJ+ALQpc53Duykl+229JGJOiiDwxSodD/5mR87NEtR8D1X8CezG/bdvBSAnJJOiPMXiJgQox0Llu6CDojQujDfP5nOl0hneepaXDHDu2PGyLKKBr28GA2d9ASK+fNj76/oT+9fsNjnjgvslmglRB2FQS3RswMcbBeJBNDnp/682nXOPOX7yTW35wGXYvsPHEWc4+tcfR99zB3X/zHv7Ke1aAbZ7+t/tT3+N33sU9d9/B6dUxO0+d5ewTG2y5FdY/9FF++WO3SiTOqzFe585fvoc7f/wEy2yz+cRZzj61w3h1nds+ei/3/Oza/lZDucadf+Nj3HbzKuN5OsavbzFfWecDv3APH3v/vqS/8pN3c89fuoUTxwp2Ns9y9omzbG6PWf3xO7j7v7iL9VdpWrY33clf/0u3cOIo7H5zg7NPnOXcpaOc/tm7ufeX/grvOQ48/zRbLxP38z2hPMnt/6Vct8PpWpzfW2H9Qx/jI1frfjhxIzem877+h04c+MZJ1n5E/rR4882cePHzyhPc9ov38tEPrbNa7cg9+voF5osnuOXn7uGXf279VYqrx6z//D187EPrrBaXufD1s5w9P2f1vR/h439RNhkWlw6/7kswkH92z2QymTcUFWN8q/y4kslkMplMJpPJZA6ws/PC8Ofl5SNv6vv7y8+IQJqKcJ99dps/3vhj9qZ7tE1D03WUVUFIQm9pCi7vTfnOc89RNw22KFBKhNxLuzP+6GtP8o1v/FuOLi3xoz/6w0wmY7qmQWKTDN/+028zmYw5vnKcxcOHePqb32R3d5d3vOPtHF5aZDwZs7y8zKUXXuA7z+3Q1B2HFseUZcG1165w9OgRlpeXJMooKolLCh7ShDkKVBABOHjPaFThUq/CwmSBsiwkegZo246maXHODwJx17aMRiWjqqKqKiaTCUorOt8RvAcU83rObFpT2ILOdSlqJzAejSjLSkqejZHS5uD3S3i1SoZHJKZYpr7vQCkxBCbjMaGPAWq71KEgPQyRXqRO5oCSrYGqkq2JS5d2KYqC6XSPa44do6lrTIoeCiHSNrUcKwziv0T3SOzSbD5DKXWFcN6bL0oplFY0dZuOTzMej3HOSQQWYk60qdhZBPUChUIpqFJPhI+B+XxOVVVEQGtDXc8lGqiTzQ2lNW3b4J1EI4nxIJ0KbSP3uBftu66jLAr2plO+/afbbG1t4Z3nR2/8Ua67boW6aTBaD8ZBf25d1+G9E4Omj8kyhqZpsNaI6RHjYCQ0TZPOG0YjkVT770cfhs2M3kggXeOVa1b4sf/gPRxZOkxZSpfHO3703d+bf+iZzFuBP36AT/zOBqsfvIe7f/K1xE1lMpnMvzt8L36mv3z58hvyugfJGwmZTCaTyWQymUzm1UmT8imtRaJ50kR1RKJnQFGYgujDEEdTVtWQGQ/QNDWjUcnx49cwHk944dJlnnnmT5nN53TO0bYdO8/viKg8KrGFxXUi5I7H4yE+qLAFs+mM3d09mqYZCopRMfUnWBGAo5QR+9Qv0LZtiv+RXz5tASijcd5hkyBsjE3RRVdm5PdFwdroNOW+H5WklEqCvkytu84PsTrSN1AwGY9RKHQS0V3nhtfqJ9x9iikS40ANYrhKWwIc2BSQt4/7ondIE+8hEvuyaaVTRwG0SRiXzQq9Pw2Pkmn+4KlGo5d0MWitUjny/gR+H8VjiyJtb6T4n3S+vcje9z5IzI+8bt+zALIdEmIY3sumyf0+LqgsS1TaAAkhiNGSiqj766OSiVEWEhUlXR3+CrPDeUddS3my6zquvfZa6YlQiipFDPWIgeAPFCb3BkB/nHIOxpi0nbHf36CT4dNvVOhkUCitUwm1HLfEb4FznrfOOkIm88Zx/vd+hU/+7ft55KkXfcNt8eg/2wCWObmWTYRMJpN5q5I7EjKZTCaTyWQymczrQ5EigfSQ8x9ClIn4VFCsFFSVCMEhiIhblmWKRdIcXznGddcd5+mn/y3T6ZR6XlNay2w6o20aDi0uMB6PWFiYJEFeyoJHo4qyqug6x87zO4CiKEYQ5tjCsnDoEAsLCxirQSl8iHTOEbxsU4ToB5G6n/TvupZYi0A9mUxSpE0HyPZCXddDyXDfi6CAsijQWqJ6OufQQeM9hACu88QgU/KFLSgKS2EN1ljarksT+mYoQu7aNvUniMhs0vXVhZRJhxgGQb+PyAER14uiENPA7D+//z0i5y33SI5b90XCMeKcGBdaB+mDSKaFdx6dypKlwyEVaisYj8Zoo4lRYpAAjLWURIzWNI3HuY4QZBK/6zqM1ihlCSEMZcYhvZ5KUU4+BupUQl2UJW0ygKKX4ukiTfCTyoiHUunocN6n4+mIqMHw6WOPiqJIXQeO2WxGWVUcX7mGokg9EqjB2Oi3DvrfxTixg5HTb370cUhaq7QdIddCp5gsn45bjBAJnJL+hRLvHU3TDPcPJJqKPpjqrdKXkMl8Fzn5nvdw+KuP8/jnP8nXT9zIiWULBzoWln/8Dj74ypUVmUwmk3kTyRsJmUwmk8lkMplM5nUisSy2sEP+PkgFQF03g+gKUBR2mJB3nWwIxBg5cniRd7z9bRw+vEDTduxNZ8zrmhADZVWyePgQR5ePcujQAm3X0tQ1WivG4zHeey69cEkeW5YYoynKAmM1o9EIbTQhSnlwjBBiZF43Un58INlV9Os4dCz0fQlaS2cCMdK2jqZph2gb59ywiaC0lE5rpbHWDEK09wHnAz5NsaNIIrgazr9ru2EIPYSAj0H+31mvH8fUwQAiyGsxIfo4I6X0ECnUdh1t54hISbIxRq5D2kYYhOkYianfIvqAHowUEfZBvhd8GP4uJkaUIudOjjmmc+yn8qXIOgwdDbJhoSRWClKPgB66BULww5ZAUZRiwhhDWVbDBoOUK2ui99KlEAKovqTaUhbV8BooJfdBKzrXMZRpp3syFDuHyHw2o+s6jh+/hsXDhyisXNOmbYaNCtLnot+a6Aut5Xux/+QM2yblgW0GlUyOHmMM3sv5ds6JueU9Wu9/XSmdIquSqZJNhMyfV07cxsd/6U5uObHM/FvSN3H261u466Tb4uM/czJPu2YymcxbmPzf6Ewmk8lkMplMJvOqpESjAWMUxho67/BeinW7rksiaqRpPMZoJuMxo1HFbDZP0/mWru0wtuDa48vsrL6Nbz3zbZqm4/DiISIwGVccO7bMoUOLuM5zcWeHuq7xPqQMf5ksXzqyOAi13ioKK30HruvQkwkKg3M1xhRYK0K70RqNQkXovEzKd85RjkpUVDRtI9sKxkq5sg9wYMJdJsoLrEllycZI94PVONcNxxmTaD8ejykLOwjz3om5oBRDV0MMUsBsi4IuTbV3bcNksjBMykci0Ue0NiLWa4Ux0i0w93OZvI9QlSp1EZDeMwnjKWYnuEBwEjWkU4GxSVP1fYl0WZU0TUNVjaR8mC79vUJrTV3PB3G9rmuMMehCo5UYJUT2z9fLNoDSCoOhaeYS6xSkaFqle6KUSpsRWq5B6hPQRqMiQz9BL/CLWRSwSg26u1KKsqykRyFFVvVCv1aK2XzGdDrFGMW1167IZkeKruoNon6ToH8fYCid7k0G6TawxBgoy2Iwdfr3LNM2Rd+BMEQy0Z+HfAa01smEiFhrhogprvg9k/nzhT12itv/2iluf7MPJJPJZDKvm7yRkMlkMplMJpPJZF4ncRBM++0ErXuhlyTA+yH2ZTweo5PgGyME7wnecejQhOuuPc7xa47Rti1KSYmtQp6Dgst7u+ztTYlRSe9B6EVfRTWqGI1HIlIbTVXJNoKxBmsMPgQUaphal2iaMHQ7FGUSuK2mLAt5rjE452nbjjoV53rv0Uq2KsqyxBqDTvE7AKhI17Y0TTOUJoc0VV9VJcZagvdyLEku7qfvY5CtApnEF6NEOgaK1Jfghyn3fjp+KDgOMRkIMVUlxFTeHNNWgcUng6eP+DHGDBFN1WhEDHHI81dJ0O9FdO+lxNgciEzqz23I/083te9N6J/nXEckpntj5P5Dusb7JcOkjoO+LFp6H2I6BoVO96w/5pgEee9duj5OziGZPWXqHQjpPvSxRX3sUdPUXHP8GhYOLQyfZue64Tof7PM42EuxbySowWDouyf695F/B/K9g/0a/d/7z6CYQSG9uxr6LlIg1Xf/aVatAAAAIABJREFUn2smk8lkMpnMd4FsJGQymUwmk8lkMplX58X6plIsLBxCpVz8Kk2Cl2UxiL6gKKxlYWGBsiqTQBwk4oVIYTSr162wcnwZpeH5559nOp0ym8v2wryu2ZvNqLsObQxVKcI3RGxhZEsiRf0UtsCmcl4An7L4nXfpcPUQsVOWJWVZMh5PKMoSWxTpa8VQPtw0DW3XSmmyczRtQyRSVSOsLcRIqUqstcko0QeKf2UPwDnZgvB90S4cMGBEVO+PLwJt3VDPawCsMXStHL8PEkNkkwAvpo1Mubddi3cOa0069zgUFyMWRcr5FyFda814MmaysJCm7yVuqt9yCD4M5dDeO9q2pSwrDh8+LIXKrhsKn73z6ZpLkbNPz9UHzQMlon4k0nUN49FI7ofWOOeloyBdlz4+yGiN9y6ZJmI+GWMYVSN5nxDo2m7ocvDBE0nF0gdKnGMMWGtpOynYruc1CwsLHD9+PMU+7W8HyOPjYAr0EVK9ObAfcWQGwwSgrueD4dMbOb3J0hc294/tPyPW7kd/9TFP/VpFthEymUwmk8m8VclGQiaTyWQymUwmk3mdSDHsZDImJsE0QtpAMBhjsVYmw7WxlFXJZGEy5MMDaKXwwXHkyBLHjh1lefkoly9fZjqdMd2b4r1PRccNTd2gjWY8GcmUutZYYynLcohbMleIs1GifNLkvAi8Iu9XlWxRoEBpmRAviiKJ3ymKJkSadt9EgDiI0sSA1tL9QJqa7yf6Q5TNBJt6IUJME/FaJtfDcO56EJBVmvjvi5+11nJ4SnoYiqJAqfR+SmKAhg0QJHe/cy5Nx+tBIEcxTLrTxyOFQNt2tI0USHfp/EzqfOgLmGUrQK5rb0ioJHFL94RsZPgDXQfEOGxqSGeGGkyBECT+SqfnyTlrYpQNFrn+huA8wXmcO9gpIPfWBymDDjHQb8GURQmpp0GKjmWDod8esankGiJNKsw+fnwFa9MxDJsFIu4bY9JmTL89E5NpoA50RpgrehBiil3qTQj5/IXBiOg3NORzGKQrxHWDGdGbEzGGwUXIRcuZTCaTyWTeimQjIZPJZDKZTCaTybwmpLAXeiNhPBqjlKKua+r5HFC0bStxM6kjIAT5fTQaURR2EPZlZlzhfcex5SNcd+1xRuOKed3gOsmadym7vm7qFF1UAXHIljfGQpqEh0hhpTNAincNIUq0ETHgvRgC2ihC9IToaZqa4AM2xQFJ/IymbTu6tqNt3bBdUZYFhw5NUEo2KaqySOXLnvl8LseoDUSVzAcRhpWCshATod8O8F4KnL13YiIkYbtKWxEhhuGxRVFQlOV+dI6RrgZjzWAWiIAdKYtiiB8ikrY3ZDJfYo32i4XbtgGgGkqZ1SB4A1JaHEmdCDVt1xKClwn+JJAXRTEI6EMUElCV1SCKa2MG8R2grmuU3o94cl1HTBFAhbVYY4gKggKfPic+SO9FH89E5MAWSQWodG6eECM+BFCawpbD9ZnOZkwWJowno8HEcd4R0+cZuKIfoTdf5PO8HwnVmwt97FF/HWTLgNQX4q54fB9x1BtTXfp890ZC8CHFcA3/0r77/3gzmUwmk8lk/ozksuVMJpPJZDKZTCbzqvRT1yhQaZK+qkaURcVenOGjRymZ3If9gtmY8vutMZRlRdc6AmGYZG+ahoXJmJXjx/j2s0e4fHkPlE5T/vL9tu2wxmKsTtP99ooi2z4UJsoovzzWGJyX8mdtDDp4EYpTRE1IQjDDRLwI4go16LjOOUajETFKYbDRGpKAr+in6pHjs0UyBzwqaorCUGoR9iOygdHH5HStRN5UVYmPAaU0SkvngTEWhUy897FBKhkGfUQOpAz+1MnQi9m96eGdCOqFtWnDwA+FyEopXNdhrEUr6bCI6VykB4ChV0JMGDGDyrKQSfoktvdCeQgBH0UkN9amzQz5DPRbKdZaQgyDQWSMlGIbY1HDKcXhWimlKIsS5+U8QgzYZMYk5X+/0yGEtOFghw2MvvTYpc6FrusI3rN4+DDWmvSY/W2K3kSRe1Jd0Ymwv+USDnQmhOHrQ5xV2lLoujYZaGEwHfpYpJB6GA52Xchre+maUOqAh5DNhNeGY+eJ3+Wr4zv5wE1v9rFcjW0e+/X7efS5de76tbtY/y6/+vybj/HgP3yMzYsSk7b603+V9TP/6xv2fplMJpP5/iVvJGQymUwmk8lkMpnXiRgJ1hSU5ZjRaES/KWCtRA6pJOhLLIwa+hN6Ud07h+vcUEq8et21HD9+DQuHDqG0xnsRYiVn3lFWJUbrFFUj4j/ElI8vBkbbtoOoa4z8Xx3vPE3TSMb+aDQIwIW1BB8GYVuleB/vnYjnSQwnMkzKe9elOB0paoYUS5Sm7uu6xgcRo4uiZGFhIcXc7EcsSTmyiO1Ka+kDCJ4Q+nz+IM+3xXA9rS0wel+477dAmqaBCKNqRFmWVFUlU+4pPqisqiFOp++FKAqbjq8YYpXKQjY5tNL7gjZ9w4JEG4H0GlgjBcnO+WFjoc/876f5+y6Gvrx52E7QWjYOUuyQ1loKiLX0RXROrg1aYVIPRfBezj8ZF2VVQfq6vFcrx0bS4ZPhtW8oiCE1Gk+oqoqyKAcDqzce+nt4sL/g4N/7z1RvUHSdG7YJ+sf1v3SKqJKtlL502Q9RTH0sFeyXOU8WFrCpJFoNtljmtbDzpc9y3z86y3Z49cf+uSRs8oX/7VE2L8LK2ilOvfsUp3946c0+qkwmk8n8OSVvJGQymUwmk8lkMpnXTYRUXqzSlHXEWpE/27YVkdRKf0CMgcl4zGw6w1pDm8Rfoz3GSF/A4uFFVt92Lc98a4u27Zg3DV2aCoeYImw03kt0TQQ652T6PsT9PoAIxhrqukErTeNaYghDNFIIbig4ttZilB4EbVD4IDEzbSsxOjqVSdskNhtj0EZT2IKucxgrAnnTNIOo3uf2KxQxBIj7UT7714xUKiyT/851QN+fELCFpTDlMDUvPQR9TFGkrmtiiEMvRQxxELv7AuGQthWI+wJ1jBI3JH+OaUvDD5sNTdOkrQO59rpfGUh/7kJLYQv5fupOKJII3psIzjm00cSQyo6bBqVSAXfqFZYYpYgOCh8DwYsSrI0mek/TNmmbxKaSbvnVl1DH1GEgYrxsmPSbEkZr2lR0LAYOTCYTib7S+z0dvSmzX84sx39wE+HgZo1EGklMlLX7GxAHN0X6jYa+J6Gu6yEKqUjRU33UkdYa5zqsGYmBIolKcqdyT8JrwgX3Zh/Ca2CFW3/p17j1jXjp55/h6Tmwdjt3f+R0Eni2eeyNeK9MJpPJfN+TNxIymUwmk8lkMpnM60AEdyK0bYP3LpkFDIW3wDD17Z0jBIkfKsuCyWQiRcJRJrt7Q2A+m/H2667lumtXpLS4k9Jd50R4L8uCoihlEh7J1ndt6gJIIrJK0/TGaIgRH0ToHlWVTIGrPs9fhF1bWEwhk+5VWQ29DtPpjBgZps37jQSUwqeYoIiSouNOMvHn8zlKa8qySsch7xWclyumFV0rPQMKmIwnMoWuFCruF+yGEJLpoLDW0LUtdT0fynq1NigUXevwLgwlzgqGboSDU/mFLaRbQkHXdjRNMwjnSmspNEYRfExxQUqKkZOB4LwTw8Ua5GJL5wNA3dS0XZc2QiJFUaYtlJT775z0NESGbQUplJZS4+A9bdPSth2k6ykdB34oJJYiYnlr570URHsxCbxz0kvRxyLFSNu0+GSkeO+ZTmcp+smidN9foYZtg7IsB9F/6GCAFxUqx/1IpmQc9N/vzYT9bgWGzRcp4t73BPpYraIohv6F2Uzubb9hISZCRA014pnMa6Ac5ynRTCaTybzh5P+tyWQymUwmk8lkMq8dUToJBOqmxrkWY/SQ+e6T8NxHu+g0jQ0yrd1H7LSpT6DrOoqiwIfAZGHMD/7wCXZeeIHpdAYKmrZFIdsE1aii6xqaEJCCXSMmRghobYkhMB6PUSiMtXR1jUnxM9roYSo8xEhMU+Z9cbA2Bn0gmqffhFBaibgePFYriQDSOsXzSNlz57qhb8EWJpkFZhCN4WDGvkT+RPY3AkBh6LcOIlVV4ZynS1sRMUa88oBOsUIiuDvnGJkROoncWitcKlXWOgwCt4jsEtcUQsA7jy7lurhOtge0kbLksqyo6znGaiL7XQH9axlj5P29bIVIebBGK0PnZvv9DkaKoZWCwha4IKJ/TGaENfvF21optNGUSnoYRIDXoEh9DxLP1BtGYkw4MWHSdTQ67h9bX+id+hNGI4mK6pwUNveP6zdM2rYdtgau7C4IV/QZiJlg0ybBfmHywa4F51wq+9ZXvFZvEvQdEL3REELasIn7xoF6q8z7XTzLw//wUc5c2MEFy/gd7+L2n78D+4VP8MCTB/L3n3uM+/+/9s4+xq7jPO+/mTkf9+5qLXMlUeqKXtmhlZWjVcWopmEaZQDTsJyYRpRGbqEgNAyhVRELrVAoQSpUDhAUMarmQ2jUQAaioolhBiFixYhQM6lpmEaiQHZMx2ajVcSNTVukyY29ipcmV7vna85M/3jnnHt3SUqkxURKMD+BWPLec8+ZM/csILzP+z7Pbxxi+bZ9PPKzmxz5L/aeXeHoZw5w+NklltfChNDkVmZu28M9H9jBdF+pCPkC3Mn9dxd85n8/zck6Ybjtdm4t/5Kv/J0ctfDJh3gImP/QI+y7NVzie0c5+Klu/UA2zewdd246P/Dcfh765ALzP/OLzC18nKeeXcVm08x94N9x7zumL7I5Xe7By21gt0cXyEgI+8J7H+Qj2xdGGQfJkK3bd3PXB/ewferlzr3p+s/u56GHgOvu5MGfv3gqwiXvCYBb5fgzT3HwC8dYWrNAwnDbLez5ibvYfaHFFUsc+ewf8YWvnmSlBpIhM2/bw96f3H3evawef5qn/uQwx04VWCCZnOGWd+/lrndtZ+p18vhHIpHIPyU+/OEPX/Kxn/jEJy76XhQSIpFIJBKJRCKRyCWiukhjvPcUZUHdNGilJTi4db3Fz2YrF2MMeZaRJNJlbhuFwvQF3C7s9trrpvmRW+f45jdeEGuiSqYcsjSTjnAvVkNaa5I0RddNPzkAITjZ6D4g2du275A3RqOMwdX1mH9/6CxvpJjZBRM3TdN314NY7qhw3S5DIUulm70o1vvCMEqOlWwIg8pzKbbXtQQnh+yAxjbQNNLd78GGYnSXL6Gg30uTmH4SwzlHWVVUddWHA+f5QCxxxgKAjU5CZ78IAYPBAK0zlGp6kSfLxbPfBauortidZRneI+HIWiZQOtHDtSIgoSBLMpkoaRoUcqxCYbTBJCZ07ovdk29HwcS+BZMk+KaR97o1p6nYJUlcBXgXQpkNZVWRhJyELkRZdZkLBEEj2EN5L6KHtQ2Tk5PkWU5jm1E4dDe9wmhSotuHjq6wL+JK1j/HXYZCXdf938ctkrqfE8MJqrrqpxiKYp1hPuwto2RfsrEwaBeeRfk9e8357mEe+81DLDmYmp1n+7Ww8vUjHPi108xc8yrPXSyw/9f3s7AGyfVz7JgbQrXC8cWTnPzSAX71OwUP/9wuNtSe669w4LdXaLbNs2PqHCf1m/iRa1tWFxdZXCqYfvMOZqfhphAPUDy3n1/95AIFCVNvnmf7dEJxeoHFLx3gV587xr4H72F+uHFZS//3f7GwOmTuju1wepkbt11MRAAYcuP8DnacvcDtfXuBxRctzMyw9RW2wi4d4onPL7A8Ncv8HdM0pxdYXDzEE//jOHf93H3suu4Vrv+dZRafX6LYMsuOt0zD1TcyvMgnLmtP3DKHf+tRDi0B2Vbm7phhWK1wfHGBg08c42vve4AH3j12d+Pf6dWzzM9Pw98dZ+HZgzzxzRPs+4V9/bmXP/8Yj35uCXTC1rkdzExaVo4fY+EzT3Ds6J08cP8etkYxIRKJRK4on/jEJy5JTHg5EQGikBCJRCKRSCQSiUQuGd//lOJoyfp6wXAwxBhDVdXn+c2LN77u8wMmJiYoqzJkG0jhtXUSiJznOakxvGnbDFVRceKFb1NXIlR0nf62qfvir7ViFWStxSQyVZAkCU1jJRMghAFrpXDe41pHludyXcTapg1+/HmeYZt2Q5CuiAeQpAlaKSkodzugxPanaRoa20hhPAROW9vggrWTeN6rvlCdhGK2VhoFYSJDRJLWtmFNwSqnt+yR4rhtPWVRUpY13nkRRpSsj3Au5zxGGwmhDh32+JC9gO8Dprs9cF467rvj2zDt4UKIdRfyrIOFEISOesQCySRJ342fGFmH7HkXDO1DUd9iEoOru7wDaF1LmmXYpkEl6YaJhySV3AeQqRYdBJ/OGgkjYo5Mgnjquultp9rWhWdPkeeZCBxO9TkH3TPaPUfjUwWdqDU+UdBZGXX32bZtH8Jsre3Fpk4wG89YUIo+u8OFvfVeRK3uemmahOPD71dwD3vtWObw/kMsuSHzP/Mg+24PJX23ytHff5QDz766sy994Y9ZWIOZ9z7IA+8ZK0a7kxz8tcd5+oUjHPneLvaMCxZnV+Bf3s/DH5gde/GdXJs8yuJSwczue7gnTCJQHOHA7y1QDGfZ+3P3s/v60SdWvvI7/M8nj/KHn57nlp+d31AQWTl7HXf/0r3svFglfgNTzL3vHuY2v/zdwzz2mxYm59l3355XFBJWnltgJtxXd1kptB/nqT8+ys4P77hI0SZc/8XDPPr8EsW2H+Oef9NNIiyff/hl7snJP/5dDi3B9Nvv5T9+cG4kThQnOfjE4zz92f0cnn+QPdcBWI7+gYgIM+95gPvfO9OvWe5lgT88uMj8B+fg5EF+93NLsGUn9z5wN3OjE3PyM0/w+J8fYv8X5nnwPa+0c5FIJBK5XF5JTHglEQFiRkIkEolEIpFIJBK5BFT4r/u7d54zZ85QVjVtK+HEdV331j/SfS7htCP//5bhIGdiOEGWpeJ/z8g2x9qWNEkYZCk3//APsWX6jWK9EwJovZfw2i5Q2FqLbRuKYh3bWBKTkKYZ3o2shEySBjFDPPKzNCPP8n5aQik1Cm52jvX1IgQGN3jvCFV8PGLHkyQpWZ7h8dS2obYNrXOYJCHNcslnQISUuqkpixKlJDshSzO0UiTGMDkxKUHEtQRPJ0nKcGIC53zvl59lGToxYVoACYAOVkraKPJBjsfJJATQ1NLt7vG0tsV7CZTOB4MwNQBplvYF8joEI9e1iDMiMhByL1TIKEgI4wFj4c4aUCOBwJh+YgQgTTMRGcIEgffy/Rltgp2VlWK8SfCu+/5tKMLLdEFVVpKxEUSmziaqmzrQY1Mo/TMasjpsEKkmJyf7vIKu8797NqELfA5CypitlXOuFwjk/tlwrSRJ+nvtGBcbvPOsr69RVRVlKZMjXcB1kiTk+YA2TFXIZ8NkTv+75s+7t39QXlzg6IvAtj3cdfvYXICeYse/vou5V1VFWOHE3zYkyTx73r2pWKxnuWkbgAW3+XNT3PrPZze/eEFWv3aERQcz7/nQhoI5wPTb97L7OiiePcLX6k0fvHmeH70kEeEiFAvs/+1DLDHDnf9+33kTDxdkuJP3vX92wxTB1vd8kN1bgOef4cjqq1jPGJe3J8c58pcrMNzJXT89t3HCYTjL3vfMA8t88S9OhpMf4ZnngS27+eCYiACw9d3vY+dkQrJ8mmXg+Fe+wgpDdv7UuIgAMGT2/XuY17D85SOcvDK3HYlEIpFNXEwsuBQRAeJEQiQSiUQikUgkErlUFNKKrzzOS7G0rusN3e+jQN1RIC0QirMtaZZIIVZrvDYoo6irmsQklGVJnmc4HBPDnDe/+U2cPrXEue+fpSwrXnrpJRrbkKZhqsCJuODCNfM8RyslobZGYysRNtLM9IG3VV2NCskh1FcpjXOaprGUZUldN6RpQpqMrI3yXEKUVfC19+GPWCZJVoJ3Dqfoi8kqTFK0rQV8b4WkoLc+EkGDft/64nIo4ttQ7K7rmqqWLvssTWUf07CP3pOYhErJ5IH3PlgSSee/UlLodl6sebzvpgqg9TIdoY3ui+jd9ER3rk4s6PIZAPAepcVyKUtSTGLClITBGE3pHAkEGyERF0bPCBit+xRiFaY0wPcBxaMuf7C2CZZVhizLe9uqsgzF/zARooJYIOsVUQkkt6NfN2x4VsdzDDrhQCk1lpNBPzmTpmlvi9S2YjXVW0ONTSF4fB+s3E1ZdDZaHc55kkT1wkwXpi3pzFfm1/UHZmmJZWB6bo7znPCzeeZvhsXFH/Tk0+z6tw+zC8AWrK6dYfmbyyydPsY3vrnI8VMX+9xN3Ljt0q5w4ltShi4XDnJg6fz3VyzASU6egJ03j61s200/eIHELnHoif0srA2Z/9B97Ln+lT8CwFvnLiDMzHDLzUOe/vJJTpyCXW/7QRc14rL25I0nOFEAw9M88+QBvrb54GKFIbB66jSrzDJ16oQU/t/yVmY2H6vnuPuXfiX8Y5mFbxXAkNNfOsCB/3feiVnJgbMnOL0Ksy+bERGJRCKRH5TNkwmXKiJAFBIikUgkEolEIpHIJdDZ2Sg8DinWK236CQETCr9doVV89kdWMdLdriWDIAQgO+9RIQPAOUddVRRFyWCYY5uaa695I+94xx38xZeOsLa2hjaKppHQXmsbPIkUfJ0DBZNXTYFSlFVJlmW03tFWJSaZQBsRAeo+dyChXCtxrhVrIW367vEu3yHPc9I0IcvzvhBPC01T0oTAYQkrTnoP/ySVNeElr8Ejwc7Ouf5+JUNBLHiSJJUisvO0nU2OUmLlI8EHNI2VSYkQ5Ds5OeyFiCzLQri17Ls2WqYRQlBymqYkRt7XSqGVdPaLBZANUxuj7n7vvYQjWwtGxBYXApxbGwKTje8nJ7QyIxHEO4w2/ZRF08j0gDHJWPe95CZ0IdV5noP3Yl+kNWma0La2z2lwzlMWPgQstyTG4JzYPeX5gPX1tZADMcqHABgMBjLB0NRj4oLpBYFuPeP3PbIakoDs7jOdkDM1NdVPz2wWfpxz/TPfiQPjQlrbtmDopxbSNB0LYh6d4/XA8t+JNU5ywcmDhGH2Ki9QnOTwgU9yeHEVO/ZyMjnD9JaC5TMX/tiF13NxVl44ysoLF10ExaaJhPPPv8D+h/azsPnlzcHRbpnDjz/G4SWYee9H2HfrpY81bL3hwhY+U1dPAYUEIl9BLmtPiiUWv3oB1aFjraAAppx8i1uv2XKJqyhYev4oFz9zSVHC+SpWJBKJRK4UnZhwOSICRCEhEolEIpFIJBKJXApKMgdQCuWhqaWA34acgGQw6Duruw7urtDava612LckaUKaZTStlW71LBMxwENja4Yqx1lHYjQ3zlzPLbfczJmVFdbXCxEQnBSnJyakSGuM2MUo5WmaGu89ZVmKzZBWIiKo0X0453GN2CNpFcKUte4L351XvdaGPB9Z9jjvxXKnrkPhHvHxV47WBjHAtdKtr7pzSsiyUboPCzaJFN8JXezGaFocdSUTGaBQWlM3DetF0U8KGK3I0oQ0kSkGY4zkHLRiwZSY4LWvwCgp+HcFfryH4OnfBUwbY2h1i9FGPqMNrnUhmNjgrcU7Oa8IIS5ISd1Whn1V0IZnQTKSJYjatjZYA0kuQCiby6RDWENr5TMKsb5qGjmqacReybViG2WDGNA9SyrkHbQh80FsinyfXzAcdsXcUbZB9zx2OQbjz2k3ATGekdCHQ4drNV04dBAROsskxvYDRrZa3eeAsDejzyVJQrG+Tpbn/XRLd/3XeiRBitvLFy1iv7ri9jKHn3hc/PdvvZN3v/MWbrlhC8PJIYmGhd97iP0XERIujyl23/8wey/NDelVULDw+x/n0BIMb9vHfZfp7b/8vTNwgSSFM99bBoavXrTZwCXuyYvh59zd/Mq9O1+5aKTliIvdy/nMcfd/vZedV/TeIpFIJHK5XK6IAFFIiEQikUgkEolEIj8ANhTildJUVcUgz0IRXLrVxUN/lI9gbYM2ElqcphlZllEUBWbMGsa2LW1rqataLGxwKA1vvfmH+JtFx4vLy6A0ZdXgvCMf5gwGQ8qiYXJyMoQh+17MyLMMrSUUWBuNclLArSqxCDI6wXsXrJVSbNMEH33Td5ObJEVpuRetDUVRUtV18OOXonPqgrd+25JmhuFggNFGbJBC13lfgEaCgZumJssysjRFG4330gpsjKGxLeV6RWtb6rAmgCxNybOMNE1Goo33+FD49ri+2K2VFoudtqWu6z4EWmtNVZbkec7ExARVVUsgtNISSuxlEqJpZD1plkowctuO5Rq4YB+lGAyGNHVNWZX9d53oBNtKl3LXvd96h2tblNYhDyEJQkA3rZLQtJLVYJuWJNW01m4o6hutaZ3r12ZMMpqq0IayLKiqki1bpkmSlLqu0FqFMGupftd1Pcoy8J66rns7I6CfVpA9l2O6TIQuYwGQ/IogzEhgtmRuWGv747u1y/Mte6GV7r+vLgi8E7O6CYXXnK0zbGWB5cVFVt+7dWNjuFvk+Dcv8rm6wLKxyGBPnNgY/fviAkeXgG17+ciHdm9qOl9m+TtXYPk3bIVnl3luYYm9s5vNdpY4+N8f44t2jr3338uul22in2ffI4+87LWWP/8E+58tYOZOPvIz81x2xMK3vsESc5ssgZb4xrcAZpm96XJPeGEua0+u2cpWDctfX2Ch3smOTQV/+9Xf4aOfPsn0O/bxiz+5HbbdxCxHOfnt0ywzt0lKWOXp3/oYnz07z13/aR9bbwBeXGRhwbLzjk3lqPoov/PLT3Ly6p3s+893sf3K3HokEolEriAxbDkSiUQikUgkEolcAhuLnI1t+pDec+fOhaK67bu0pWit+sBdHbrdnXMkxpBnGXme9zYvqu/Uh7YV+xhCeO7ExJBtb5phYnKC1rYURcn3z61SFOvBrgYGAwk6rpsmdJJLF7zWSmx+2i6ImLFJCelox0uBucta0BqyLJUiOgSBo2VtbZ3xkGEJkpZwXGN0mHwYTTjYRqwUCRHgAAAPoUlEQVR7siyTArprg12PA1QIi7a94DIYDPFe9WHB49Y5aZYyMTkh4kOWBY9+yTnoAos7S6Xu+xE7I03byjSBMabvfO/uWe6jCxBOxGoofIddR75So4Bhj3TvD4cygYIfhWV7L5kRMgHRiQjhpxvtPXisbYIQJctpncO1Xr77zgoq5DUQPqf66QARZZogkIjtlO+Pl6J/uDc3ClUG+gL/eI4HIeB5fGIB6MWi0UTNKAOke6676YJuD7o96wSHcausbuO77xZFeC5G535dcN0uds8Bpw7zyT8flwEsS5//LEeKTceHwjNfX+Br4+8VJzn4pxcJU1hd4cyGyQbL0ucOcOjFCx9+MZLQDd8UI5OkrW/fxayGlT9/kkNLdsPxy59/kqfPgL3mFuYv1YnnIhTP7efjn1uCmd3cf98e2YPL5czTPPn5TXv8OVnj8Lad/OgV6tq/rD3R8+x6+xDcIk996iir499TscCBg4tgYfvbQql/agc754AXD3Fgw71A8dxTHD4F9prt3DIJ8+/YyRBYPHiAoxuCpAsWPvUUi87CzfNRRIhEIpHXKXEiIRKJRCKRSCQSiVwyXTBw01qqusR7z7mzZ7lxZgbvoaoq2tb1Xdriey9+8LapwWsmBkOaxpLnOeW5s5hQxE6SEIDcWkxr0IlBa4VzLddeew3urW/lK395lKqqqGrPme+fZZAPMEaT5SmttSIIOM/ExFCsZHBiiaM0KlGsr63Rtp48H4SicSq2SmhA9esVuxxLa00/tbBeFLStR+uuOz3FGMVgmIfu8+EoSFqcixjkAylGo9CpTEgoxOomSaS4XFUlWiuSJGN9raC2Td+lX9UVaZoyMTFBYhRJyBDQWqOQTASn5B6zTKqOTS1WSNqIlZTROoT7SqUzTVLJYdAGKWy3YTIgiDnW97ZJIMXwNA32PnUlAcuDHK0VZVlI7kCSSEE8XEMbHUSSsPdmVIS3vsVohTaGqpTJC7E46sKhFXVdY7QWC6ym6cWA3tpIKbySnARrG6qqAuCqySm0NtS1/LusSpzzffBx9yfPc0AEhNa1GyyLuryDzibL2pFANm6T1L1mjOmP6QSBXlgJ5+pEBqDPapDJl/A7FcKmuz/qNbU3GrLznn0s/vp+Fj7zKB89Msf8jSkrx49xcjVlOIRiXDAIheeFLy/yhx/7GEfmtjNtl1k8vkRz03ZmXjw+8sO/bp4dM4c4tPRFHv/l48zNzzCkYGlhkeV6yPQ1Q1a+t8zSMnDdK690+oatwBKLf/I4+7+5le3vuodd23bxoQ8e49E/WOTwY7/MkTffwvbphOL0AovftZDMcOe/2vXqLPhfOMijv7dAQcLWqVWe+T8HeOYCh930rnvY9XIh0ZNDznzuUT76V2N7fNbC1A7u/un5K1ewufry9mT7B+5l96nHefrZA3xs8bB8T9UKxxdPsmph6o67eX8fVD32vPT3MsSuHOfYC6vY8XPffBf3/thpHv+zBQ78t49y+OZ5Zibtxvv+iSgjRCKRyOuVKCREIpFIJBKJRCKRy0Mp6rrsQ4OLoqCuKvJBTppmtG3Zd4dL5zxYKz+VlsBlraUoro2GUPLPs5y6Edsi21pSn+Gc5A0oDVuu2cKN2/4Z699YpyhLVlfXmJpcQyFTC61UocE7jJKcASUlfFAapQwgmQRS+IUszahsgwuTAkrpsZDljLKoqKqStm0l2NmLpc4gz0mzFKOliJ6mabBtSjEmoa4q0jQL+QJtH9rrnO+v09kn1XWNMQlltUZr3WiiQ5lRsVlLZsOo2C3FZqXFWqrr0pd8BRVyFEbd8V3HvW0tWZqhtJKQY6X77AEg3GOY2FBa8hfC6wrJicjyTGyKlA6TIzJdoZA1umB91HfvJ6OcAdtbBimqqpJivJfjszSlDIJAEnIk6rrGO0eapthQnIcwhdE6SBStddS1WDqlaUqWia2RTAnI+rvPjYsCvRVTkvSWUF12BEBVeYbDrLc06vZFchgMTTPKABkXGrpjOwGhm67obJKcbbG2Ce9L7oRka/RBHq91TAIM59n3C/fz9Kf/iMPPL3L0u5BcP89dH95D8fuPcWjTVML2n3qQ+7Y+xcEvHOPkc0c5mU0z+657+dCPNzz1X8aEBLay5777ST/9Rxx+fonFry5DMmTmbXey78d/jPnvHOChTy6wdGIJbt1swXMB5u7k7ttO8tRzSyx8dYlz2/aya9sUU3fcy8M3HeXgpw5z9NQCR19ArnPb+9j7k7vZ/mqDfNfOhE59y/Li0Y32TWPYW19BSPihu3jwnSs8+QeHOfpVC9k0s++8k3s+sIPpK1ytuaw9yWbZ+x8e5pZnnuLgnx6T7wlItsyy6733sPeO6Y3FpOE8+37hAY4cfJJDfyXPi5x776ZzJ8y+/wEennuap/7kzzj29aMsO/5e7zsSiUQiVw7lXzfzk5FIJBKJRCKRSGSclZXv93+fnn7ja3p9VXx3ZLfj4dm/fo6//pvnOfGtb3Pq1Ld5y+wsN9xwPWVZBR/7JhTVzYYA284SxrqWqq5YWy9ovUN5+mK7TC80TAyHZFlOVVWkwWpodXWNL37py5w6/bekScqNMzdwzZarufW2HwkFc7EdGmYZ+UC6zr3ivG5xkNfyLGd9fR3nYXX1HKC47rprwmc9L60WrK+v0dqWwTDHe/HRH+QD0swwOTlJa1up+4brTE5Osra2Bh4Gw0EvHjRNzWAwpKrKfkoDJV39dd3Qto4kSbHWUodJBHwXTp0wzAch3FlR11Vf9K7rmjRJRwHBYZqhLAuxIRoMqeqatrWUZcVwOJC9bh1+LFhaIZZIoKjKgjTN+vcB8iwHJRMZ60VB68IkQZdvYS1pmpFmspa2sRLg7ERs0MaQpSmNbSScuXFkec76+hpaaSYmJ1lbe4mmbhhOTIwmD8J0RVPXKK2wIYjZo3Bty3pRUBQFk5OTfchyWZb9FMC4FdH6+nq4X81wOOwFr7KU70REHZkYaIJNVic4gIhNZVniXBfqPLFh2qFpRCDoBIvxyQQRmzR1VfWiQjf9Mr1lmp3/Yicz129lEKY9rn/LbX9fv9qvgmUO/8ajHHpxnn2P7GP+tV7OP1ZePMyjv3GI5dv28cjPxl2MRCKRf+r8Q/w//blz5/5ezjtOzEiIRCKRSCQSiUQir8xY+5F30mleVRWtl+LpmTMrmCQBLUXXzrN/3Jt+vHPb1g15ljHIc/IQvtwX+0Nxt7O56exl2tZy9dVTzM39MMNhTl3XvLS6Sj4Y9J3irm1JTRKK8J7WtcF+JgEUdd1QVTXeSzG5DUXuzj6nW6NtWs5+/xxFsU5dN+iw/ixNuGpygjSTtlmlQGvViyTeeeqqlvwF14InWAeJlVHn8Q9IkHIQEJqmoSorXlpdlS78bvKg9+QXESRJ5bNaiQWT0UYsjZTCJBLwrJUU2LU2MhHh3ViXfCrfmx2FJ+e55EtIUT0FPGmWYbvMiy4kGMArXCvTAxIorfFIYLAZm4IwJglTDtKZnySJCBVNE8K4wSQhkFjJ3tZ13d+XBChrklDU7wQm73wo7mvw0FhLURSkaUqe5b1Q1NkXdfZaMmXgSdOEiYkhWZb1Bf7uObXWbphU6KY5uhDl7lnOc7kfydhoR9MeYcrAOResiuinHLpztU5ELMnXUBtyFZQiTCK81tZGkUgkEolEIucThYRIJBKJRCKRSCRySfSe+a6lbmqaupZCrLV8b+UM+XDIYDjEj3nBd4Xzrvu685MHUB6yLBsLtw3d36Gz37mWqqokSNd3/vRw05tm2HH7bSjlqKqKq66aoqpq2lYEgy682aNIk4wkyRiJCBVNI0VhE6yCkkS65js7mqapWV1dZXX1pd4yZ3JyEq0Tsjwny1OgRWlFY60UvvHgxUJnfX1d7Iy06TMbxHJHMhIAylKyBs6trrK2tk5V1lI+VgZjTAhelrUNBgOZeggFdOdanBdLnK6jvStYd8KLJxTctSZJZP+zNCNN095uJ8/zUTaAG4kunV1PJ4w471Fa9dZIHrGoStOUNJGMiaqqaW0reRdhCkEbg21bsjwnz/OxwjlkaUqSyP503k3eexrbkKSSd9F1+Hd2WI1t+g5/7x3rxTplWaK15o1Xv5F8kGM7gSRJevGke760VmSZCCXGGMqy7AWCzv6pO38nDoxnM4znHIgo5PpnWaYXZK/xIvQYpUUMCQHQ3RRIZ+Vkre1tpbrnu/tNi0QikUgkEnm9Ed3nIpFIJBKJRCKRyCviu+hi1/nEu77bW6E5s3KWoiho6gatFK1zKGsxxpBlowJ7N5nQOkdjW3wofo8H2SahOO28R3sv9kBti3OeprEYo9l24ww/fPNbOff9c72fflWVpEnKxHAIOJI0JUkS6qbBexemDqQonIbpANd66qahLGtAoRThOqPC8GAwCCHKMBwOevFEKYdrWwyauqmDUCBd51ppUBJUrI2ibTuPfrF0KopSphe6QN+2RftR934nsJgQztx16Td13RfKfRBYbGMxxuO0wjsvkwmofkqjrn2fdeC9ZzgcynHGgJIJkyYUxNM0oa6rkZDgPalK+2tIpgW41tGG7AetNUma4B1hYkDT2gaFIgs5EU1Th0kJh21bQPdd+2mSYFuL1gajzWgSQGv53luZ7JAJh5FQ0k0R5HkeQrUbtAZrHQp6saC7ZwXY1obcDdeLKp2AVNc1QG9v1DRNb3/UZUjIcyoCWFm6DRMQXdZCN+lgjAEvsoC1ljRJSYxBB0ut/rzeo4NAIZker4OMhEgkEolEIpFNRCEhEolEIpFIJBKJXDrei0igFFNTbwC+g7VWfOrXi75L2xPckEKBVHz/pdie5Tk6FGDTVIrIXXd2V0TXaSohtCHPIEnFkqcrJF911SS33347zz27ELrHu0K5kwkDP7IcAhEgvPdB/FBorbCtpWks6+sFbWvJ8y7PQEJ+r7rqKkCsbIzRDPJR5oNrHYOQweCcIzFJCD9WDAYDqqoizweYICY4ZylLEQGKsuLs2bPBix/e8IarsbYhCTkHXSEaPBMTk4AXKyIrkyBSnFY45UgzEUu6ffbe4VoRUZqmJEkmCBnMeC+F/jTNQj4D/b5Y24SJAZlUqCspqk9OTtK2LWtra+QDsQ5qGnmvbVuyLMcYQ1GWKBTGJGJx1VTokOGgwj15JO+hdb7POZgYDiWguRxNQrTWMjX1Bqq6ogmTHlrrsG76Z6XLI5icnAwCSD2aMGkdasyPq3uO6lqyOzqRpROvsmw0MdFNI/QWS+E7t0EYy/N8ZKU1FrYMUFWj++7EB6MTlJLreidB4lmSBbFBRCgX7MKE3uPodchW9vz8I+x5rZfxj53r9vDgI3EXI5FIJPKPi/8PaeQwQ1RZhokAAAAASUVORK5CYII="},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d4c5612e-83ae-402b-a456-12bd07c9b892","ELEMENT":"d4c5612e-83ae-402b-a456-12bd07c9b892"}]},"result":{"value":true},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"8485aeb6ba7e87307a7e5fcf20524052","cid":"0-21","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:45.465Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-21","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T02:03:45.498Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-21\\report.html"}